<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神奇的战士</title>
  <icon>https://www.gravatar.com/avatar/24bbef706a491483f0479c7fd6328319</icon>
  <subtitle>🍉 Start with one, then make many.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thinkhard.tech/"/>
  <updated>2019-11-05T08:56:46.336Z</updated>
  <id>http://thinkhard.tech/</id>
  
  <author>
    <name>神奇的战士</name>
    <email>rocksong.hit@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双足机器人如何行走？</title>
    <link href="http://thinkhard.tech/2019/11/05/%E5%8F%8C%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%A6%82%E4%BD%95%E8%A1%8C%E8%B5%B0%EF%BC%9F/"/>
    <id>http://thinkhard.tech/2019/11/05/双足机器人如何行走？/</id>
    <published>2019-11-05T02:03:35.000Z</published>
    <updated>2019-11-05T08:56:46.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双足机器人如何行走">[双足机器人如何行走？]</h1><blockquote><p>译文：<a href="https://scaron.info/teaching/how-do-biped-robots-walk.html" target="_blank" rel="noopener">how-do-biped-robots-walk</a></p></blockquote><p>早在上个世纪七八十年代，双足行走就已经在机器人上实现了，但双足机器人一个重大里程碑是 1996 年 Honda 推出的 <a href="https://en.wikipedia.org/wiki/Honda_P_series" target="_blank" rel="noopener">P2 仿人机器人</a>，随后 P2 成了大名鼎鼎的 Asimo。P2 能够完成<a href="https://youtu.be/d2BUO4HEhvM?t=26" target="_blank" rel="noopener">行走</a>、<a href="https://youtu.be/d2BUO4HEhvM?t=119" target="_blank" rel="noopener">推车</a>和<a href="https://youtu.be/d2BUO4HEhvM?t=172" target="_blank" rel="noopener">爬楼梯</a>等任务。P2 的核心设计就是<strong>基于零力矩点 (ZMP) 反馈的步行控制</strong>。本文接下来就探究这背后的原理。</p><p>如果您是第一次阅读这篇博客，建议先观看 <a href="https://www.youtube.com/watch?v=T7SEyvPtWFY" target="_blank" rel="noopener">NHK 纪录片: ASIMO, HONDA, ROBOT, JAPAN, DOCUMENTARY, INTERVIEW</a>，纪录片介绍了接下来将要解释的几个关键的概念。</p><h2 id="线性倒立摆模型lipm">线性倒立摆模型(LIPM)</h2><p>机器人(固定或移动)通常是由多个执行关节连个多刚体模型。通常这样的系统的运动方程是高维的，但是可以分解成三个可行的假设：</p><ul><li><em>假设 1</em>：机器人有足够的关节力矩来实现其运动；</li><li><em>假设 2</em>：质心(CoM)周围没有角动量；</li><li><em>假设 3</em>：质心周围没有角动量；</li></ul><p>假设 2 和 3 解释了为什么 Honda P2 机器人总是<a href="https://www.youtube.com/watch?v=d2BUO4HEhvM&amp;feature=youtu.be&amp;t=172" target="_blank" rel="noopener">胳膊保持静止并且弯曲膝盖行走</a>。在这三个假设的约束下，双足机器人步行的运动方程就简化成了一个线性模型，即<strong>线性倒立摆</strong>：</p><p><span class="math display">\[\ddot{p}_{G}=\omega^{2}\left(p_{G}-p_{Z}\right)\]</span></p><p>其中 <span class="math inline">\(\omega^{2}=g / h\)</span>，<span class="math inline">\(g\)</span> 是重力常量，<span class="math inline">\(h\)</span> 是质心(CoM)的高度，<span class="math inline">\(p_{Z}\)</span> 是 ZMP 位置。常量 <span class="math inline">\(\omega\)</span> 称为线性倒立摆的<em>固有频率</em>。在这个模型当中，机器人可以被看成质量集中在一点 <span class="math inline">\(G\)</span> 上，通过一条没有质量的腿与地面接触，触地点为 <span class="math inline">\(Z\)</span>。直观上理解，ZMP 点就是机器人施加重量的点。所以，ZMP 点需要落在支撑区 <span class="math inline">\(S\)</span> 内，机器人才能保持稳定。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20191105110825.png" width="50%"></div><p>从上免公式可以看出，机器人前进过程中，ZMP 往后移动，导致质心(CoM)加速向前（往前走一步，有可能导致往前摔倒）。同时，机器人摆动腾空的另一条腿来实现新的一步。当摆动腿接触地面，机器人的 ZMP 点就移动到了新的立足点了（质量转移到另一条腿），这就使得质心减速。然后不断重复上述过程。</p><p>现在有了系统模型，接下来就是规划和控制的问题。步态行走任务通常分解成两个子问题：</p><ul><li><em>步态模式生成</em>：假设一个理想的模型，并且没有干扰，生成参考的 CoM-ZMP 轨迹；</li><li><em>步态稳定性</em>：尽可能地去拟合跟踪参考轨迹，使用反馈控制来消除干扰和修正模型误差；</li></ul><h2 id="步态模式生成">步态模式生成</h2><p>步态模式生成的目标时生成质心(CoM)的轨迹 <span class="math inline">\(p_{G}(t)\)</span>，对应 ZMP 点</p><p><span class="math display">\[p_{Z}=p_{G}-\frac{\ddot{p}_{G}}{\omega^{2}}\]</span></p><p>ZMP 需要始终处于支撑区 <span class="math inline">\(S\)</span> 内。如果机器人处于<em>单脚支撑</em>时，支撑区就成了单个点。如果机器人在平地上双脚着地，所有支撑区就形成一个凸包形状。如果地面不平，或者机器人由其他接触（例如用手倾斜靠在某处），则定义一个<a href="https://hal.archives-ouvertes.fr/hal-02108589/document" target="_blank" rel="noopener">多接触 ZMP 区</a>，但这就会是相当复杂的问题了。</p><h3 id="线性模型预测控制">线性模型预测控制</h3><p>有很多方法可以用来生成步态模式。其中一个最突出的部分就是将模型表述为一个数值优化问题，在 2003 年 Kajita 等人提出了<a href="https://doi.org/10.1109/ROBOT.2003.1241826" target="_blank" rel="noopener">预览控制</a>，随后就被 Wieber 等人扩展并演变成为了<a href="https://doi.org/10.1109/ICHR.2006.321375" target="_blank" rel="noopener">线性模型预测控制</a>,同时还有<a href="https://doi.org/10.1109/IROS.2010.5654429" target="_blank" rel="noopener">足迹自适应</a> 和 <a href="https://doi.org/10.1109/HUMANOIDS.2015.7363423" target="_blank" rel="noopener">CoM 高度变化</a>。在 <a href="https://www.youtube.com/watch?v=IWG3dt9HELw" target="_blank" rel="noopener">HRP-2</a> 和 <a href="https://www.youtube.com/watch?v=tcDyZ89TRAA" target="_blank" rel="noopener">HRP-4</a> 机器人上就采用了这样的方法加持下，显著提升了步态模式生成的性能。</p><h3 id="dcm-轨迹生成">DCM 轨迹生成</h3><p>另外一种方法就是将线性倒立摆的二阶动力模型分解成为 2 个一阶系统，定义 <span class="math inline">\(\xi\)</span></p><p><span class="math display">\[\xi=p_{G}+\frac{\dot{p}_{G}}{\omega}\]</span></p><p>那么 LIPM 的动力模型可以重新写作</p><p><span class="math display">\[\begin{aligned} \dot{\xi} &amp;=\omega\left(\xi-p_{Z}\right) \\ \dot{p}_{G} &amp;=\omega\left(\xi-p_{G}\right) \end{aligned}\]</span></p><p>第二个方程是一个稳定系统：有一个对 <span class="math inline">\(p_{G}\)</span> 的负反馈增益 <span class="math inline">\(-(1)\)</span>，或者这么理解，如果 <span class="math inline">\(\xi\)</span> 称为常数，那么 <span class="math inline">\(P_{G}\)</span> 将慢慢收敛于它。<span class="math inline">\(\xi\)</span> 就被称之为瞬时捕获点(ICP)。另一个方程是非稳定的：捕获点 <span class="math inline">\(\xi\)</span> 与 ZMP 点 <span class="math inline">\(\boldsymbol{p}_{Z}\)</span> 发散，这就是为什么 <span class="math inline">\(\xi\)</span> 被称为<em>发散运动分量 (DCM)</em>。瞬时捕获点(ICP)的名称来自于，如果机器人在任意时刻 <span class="math inline">\(\forall t \geq t_{0}, p_{Z}(t)=\xi\)</span> 站立到该点，它的 CoM 在<span class="math inline">\(t \rightarrow \infty\)</span> 时 <span class="math inline">\(p_{G}(t) \rightarrow \xi\)</span>， 最终会停下来（称之为“被捕获”）。</p><p>当 CoM 收敛到 DCM 时没就没有必要考虑上面第二个方程的动力学分解了。对步态控制器来说，控制 DCM 比控制 CoM 的速度和位置会更加有效率。步态模式生成可以专注于产生轨迹 <span class="math inline">\(\xi(t)\)</span> 而不是 <span class="math inline">\(p_{G}(t)\)</span>。因为方程 <span class="math inline">\(\dot{\xi}=\omega\left(\xi-p_{Z}\right)\)</span> 是线性的，所以可以用几何解析求解。在 ASIMO、IHMC 的 Atlas 和 TORO 机器人上都是用了 DCM 轨迹优化的方法来生成步态模式。</p><p>现在我们有了参考的步态模式，接下来就需要让实体机器人执行，简单的开环控制并不适用，因为步态的动力学模型是发散的，所以必须要添加反馈。</p><h2 id="步态稳定性">步态稳定性</h2><p>在 1996 年，Honda 的 P2 机器人有两个关键的进展：在硬件方面，脚踝和脚底之间加上了一个橡胶衬套，以吸收冲击力，并使地面反作用力得到柔顺的控制；在算法上，使用了 ZMP 反馈控制。根据 <a href="https://doi.org/10.1109/IROS.2009.5354522" target="_blank" rel="noopener">Asimo 平衡控制报告</a> 中的术语，这种反馈方法用 DCM 表示成</p><p><span class="math display">\[\dot{\xi}=\dot{\xi}^{d}+k_{\xi}\left(\xi^{d}-\xi\right)\]</span></p><p>其中 <span class="math inline">\(\xi^{d}\)</span> 是根据步态模式的目标 DCM. 代入 <span class="math inline">\(\dot{\xi}=\omega\left(\xi-p_{Z}\right)\)</span> ，上式可以写成 ZMP 形式</p><p><span class="math display">\[p_{Z}=p_{Z}^{d}+k_{z}\left(\xi-\xi^{d}\right)\]</span></p><p>其中 <span class="math inline">\(k_{Z}=1+k_{\xi} / \omega\)</span>，<span class="math inline">\(p_{Z}^{d}\)</span> 是目标 ZMP，<span class="math inline">\(p_{Z}\)</span> 是机器人使用足底力控制的 ZMP。对于像 HRP-2 或者 HRP-4 这样采用位控制的机器人，使用踝关节的阻尼控制实现脚力控制，参考 <a href="https://doi.org/10.1109/IROS.2010.5651082" target="_blank" rel="noopener">HRP-4C 的步态稳定器报告的章节 III.D</a>，强烈安利这篇论文，每一个章节都是精华。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20191105150311.png" width="30%"></div><p>那么，这种控制方法实际是什么样的呢？想想这样一个场景，当回放步态模式是，机器人处于某种原因开始往右倾斜，结果 DCM 的横向坐标 <span class="math inline">\(\xi_{y}\)</span> 比 <span class="math inline">\(\xi^d\)</span> 位置低。然后 ZMP 将会朝着 <span class="math inline">\(y_Z &lt; y^{d}_{Z}\)</span> 的方向生成正向速度</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20191105150249.png" width="40%"></div><p>朝着 DCM（红色箭头往右）接近目标位置。机器人挥着手，右脚向右倾斜，以便将自己推回到左边。</p><h2 id="更进一步">更进一步</h2><p>按照上面讨论中链接可以了解每个部分的详细信息。上面的例子我没有提到的是<em>状态观测</em>，如何从传感数据<a href="https://scaron.info/teaching/floating-base-estimation.html" target="_blank" rel="noopener">估计 CoM 的位置和速度</a>。下面是关于行走控制本身的一些其他要点：</p><ul><li><a href="https://scaron.info/teaching/prototyping-a-walking-pattern-generator.html" target="_blank" rel="noopener">建立行走模式生成器的原型</a>：使用 pymanoid 一步一步构建一个步态模式生成器；</li><li><a href="https://www.youtube.com/watch?v=qT9qzwCJjAk" target="_blank" rel="noopener">关于步行运动控制的演讲</a>: 2013 年 Pierre-Brice Wieber 在波恩仿人足球学校的演讲；</li><li><a href="https://github.com/Leph/PhD/blob/master/build/TheseMinimized.pdf" target="_blank" rel="noopener">Quentin Rouxel 博士论文</a>:列举了双足机器人在应用时遇到的常见问题和解决方案。</li></ul><p>有一些其他的步态控制方法，不依赖于 ZMP 反馈，例如应用在 <a href="https://www.youtube.com/watch?v=1fC7b2LjVW4" target="_blank" rel="noopener">DURUS</a> 上的被动步态和混合零动力方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;双足机器人如何行走&quot;&gt;[双足机器人如何行走？]&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;译文：&lt;a href=&quot;https://scaron.info/teaching/how-do-biped-robots-walk.html&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://thinkhard.tech/tags/Algorithm/"/>
    
      <category term="Gait" scheme="http://thinkhard.tech/tags/Gait/"/>
    
  </entry>
  
  <entry>
    <title>强化学习策略网络复杂度的影响</title>
    <link href="http://thinkhard.tech/2019/11/04/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BD%B1%E5%93%8D/"/>
    <id>http://thinkhard.tech/2019/11/04/强化学习策略网络的复杂度影响/</id>
    <published>2019-11-04T09:20:29.000Z</published>
    <updated>2019-11-04T11:00:35.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习策略网络调参">强化学习策略网络调参</h1><p>传统的基于<strong>状态-动作</strong>强化学习方法会遇到<strong>维度诅咒</strong>的问题，为了解决这个问题，基于策略的强化学习方法被提出，比如经典的策略梯度方法，使用神经网络，可以用于表示高纬度的<strong>状态-&gt;动作</strong>空间的映射关系。这样可以把维度降低，实现更快的收敛。</p><p>为了找到最优解，策略的参数数量必须要足够多，以至于能够合理的表示策略空间。在策略梯度中，策略网络常常用一个 MLP 网络表示策略参数 <span class="math inline">\(\theta\)</span>。</p><p><strong>那么是否参数越多越好</strong>？答案是否定的。</p><ul><li>参数较少时，收敛速度快，容易找到次优解；</li><li>参数过多时，收敛速度慢，容易陷入局部最优；</li></ul><p>所以需要合理设置策略参数个数，评估网络的复杂度，在强化学习任务中是非常困难的，常常需要大量实验试错调节参数。但是在许多论文中，没有提及这部分工作，只是说道根据<strong>经验值</strong>...相似的超参数还有</p><ul><li>奖励函数</li><li>衰减系数</li><li>Exploration Noise</li><li>...</li></ul><p>上面这些超参数，调整一个，就需要从头开始训练，过去所有收集到的数据都需要扔掉，这个过程采样效率低，耗时长，如下图所示，使策略收敛，训练一个 Agent 经常需要上百万次的采样，故不能直接在实体机器人上训练策略。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20191104171929.png" width="60%"></div><p><strong>So ... 怎么调参？</strong></p><p><a href="https://spinningup.openai.com/en/latest/spinningup/spinningup.html#learn-by-doing" target="_blank" rel="noopener">《Spinning Up》</a> 中提出了一些建议，或许有用</p><ul><li>从论文中查找细节参数，比如网络的结构、奖励函数和超参数设置等等，但是注意不要陷入到论文中。</li><li>在简单的强化学习环境中快速试验算法，首先要验证算法的正确性，保证在像 CartPole-v0、InvertedPendulum-v0、 FrozenLake-v0 和 HalfCheetah-v2 简单的环境中，算法可以收敛。这样只需要花几分钟就可以验证想法，而不等好几天！然后再将算法应用到像雅达利游戏和机器人这样复杂的环境中。</li><li>如果在一个环境中调节超参数，始终达不到满意效果，这可能是一个 Bug，试着在别的强化学习环境中验证；</li><li>测量尽可能多的结果，比如均值/方差/最小值/最大值，观察 Agent 在环境中的行为，这可能会提供一些思路；</li></ul><h2 id="参考">参考</h2><ul><li><a href="https://spinningup.openai.com/en/latest/spinningup/spinningup.html#learn-by-doing" target="_blank" rel="noopener">Spinning Up as a Deep RL Researcher</a></li><li><a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html" target="_blank" rel="noopener">Policy Gradient Algorithms</a></li><li><a href="http://karpathy.github.io/2016/05/31/rl/" target="_blank" rel="noopener">Deep Reinforcement Learning: Pong from Pixels</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强化学习策略网络调参&quot;&gt;强化学习策略网络调参&lt;/h1&gt;
&lt;p&gt;传统的基于&lt;strong&gt;状态-动作&lt;/strong&gt;强化学习方法会遇到&lt;strong&gt;维度诅咒&lt;/strong&gt;的问题，为了解决这个问题，基于策略的强化学习方法被提出，比如经典的策略梯度方法，使用神经
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://thinkhard.tech/tags/Algorithm/"/>
    
      <category term="ReinfocementLearning" scheme="http://thinkhard.tech/tags/ReinfocementLearning/"/>
    
  </entry>
  
  <entry>
    <title>Pybulet Gym 源码解析：双足机器人模型 HumanoidPyBulletEnv-v0</title>
    <link href="http://thinkhard.tech/2019/08/23/Pybulet-Gym%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%8F%8C%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A8%A1%E5%9E%8BHumanoidPyBulletEnv-v0/"/>
    <id>http://thinkhard.tech/2019/08/23/Pybulet-Gym源码解析：双足机器人模型HumanoidPyBulletEnv-v0/</id>
    <published>2019-08-23T08:19:36.000Z</published>
    <updated>2019-08-23T08:46:20.950Z</updated>
    
    <content type="html"><![CDATA[<p>OpenAI gym 是当前使用最为广泛的用于研究强化学习的工具箱，但 Gym 的物理仿真环境使用的是 Mujoco，不开源且收费，这一点一直被人诟病。而 Pybullet-gym 是对 Openai Gym Mujoco 环境的开源实现，用于替代 Mujoco 做为强化学习的仿真环境。封装了 Pybullet 的接口，无缝的接入了 Gym 环境。</p><blockquote><p><em>Cheers!</em></p></blockquote><p>关于如何创建 Gym 自定义环境可以参考我的上一篇博客 <a href="https://thinkhard.tech/2019/08/21/OpenAI-Gym-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/">《OpenAI Gym 源码阅读:创建自定义强化学习环境》</a></p><h2 id="示例代码">示例代码</h2><p>完整使用 <code>HumanoidPyBulletEnv-v0</code> 模型的示例代码，在 <a href="https://github.com/benelot/pybullet-gym/blob/master/pybulletgym/examples/" target="_blank" rel="noopener">pybulletgym/examples/</a> 路径下可以找到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> pybulletgym.envs</span><br></pre></td></tr></table></figure><p>当示例代码引入 Pybullet-gym 库时，就完成了对 Pybullet 自定义 Gym 环境的注册。</p><p>根据 OpenAI Gym 的文档，下面是使用随机策略，调用 <code>HumanoidPyBulletEnv-v0</code> 的测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pybullet <span class="keyword">as</span> p</span><br><span class="line"><span class="keyword">import</span> pybulletgym.envs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    env = gym.make(<span class="string">"HumanoidPyBulletEnv-v0"</span>)</span><br><span class="line">    env.render(mode=<span class="string">"human"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i_episode <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        observation = env.reset()</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            env.render()</span><br><span class="line">            print(observation)</span><br><span class="line">            action = env.action_space.sample()</span><br><span class="line">            observation, reward, done, info = env.step(action)</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                print(<span class="string">"Episode finished after &#123;&#125; timesteps"</span>.format(t + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    env.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="动作与观测">动作与观测</h2><p>首先查看 <code>HumanoidPyBulletEnv-v0</code> 运动空间和观测空间的维度大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f'env.action_space.shape = <span class="subst">&#123;env.action_space.shape&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'env.observation_space.shape = <span class="subst">&#123;env.observation_space.shape&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt; env.action_space.shape = (<span class="number">17</span>,)</span><br><span class="line">&gt;&gt; env.observation_space.shape = (<span class="number">44</span>,)</span><br></pre></td></tr></table></figure><p>可知 <code>HumanoidPyBulletEnv-v0</code> 运动空间维度为 <code>17</code>，动作空间维度为 <code>44</code></p><p>查看注册环境源码，可知 <code>HumanoidPyBulletEnv-v0</code> 入口类为 <code>HumanoidBulletEnv</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">register(</span><br><span class="line">    id=<span class="string">'HumanoidPyBulletEnv-v0'</span>,</span><br><span class="line">    entry_point=<span class="string">'pybulletgym.envs.roboschool.envs.locomotion.humanoid_env:HumanoidBulletEnv'</span>,</span><br><span class="line">    max_episode_steps=<span class="number">1000</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>根据 <code>HumanoidBulletEnv</code> 初始化 <code>__init__</code> 的参数，可知机器人实例由 <code>Humanoid()</code> 构建，顺藤摸瓜，获得 <code>HumanoidBulletEnv</code> 运动空间维度的详细定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.motor_names  = [<span class="string">"abdomen_z"</span>, <span class="string">"abdomen_y"</span>, <span class="string">"abdomen_x"</span>]</span><br><span class="line">self.motor_power  = [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br><span class="line">self.motor_names += [<span class="string">"right_hip_x"</span>, <span class="string">"right_hip_z"</span>, <span class="string">"right_hip_y"</span>, <span class="string">"right_knee"</span>]</span><br><span class="line">self.motor_power += [<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>]</span><br><span class="line">self.motor_names += [<span class="string">"left_hip_x"</span>, <span class="string">"left_hip_z"</span>, <span class="string">"left_hip_y"</span>, <span class="string">"left_knee"</span>]</span><br><span class="line">self.motor_power += [<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>]</span><br><span class="line">self.motor_names += [<span class="string">"right_shoulder1"</span>, <span class="string">"right_shoulder2"</span>, <span class="string">"right_elbow"</span>]</span><br><span class="line">self.motor_power += [<span class="number">75</span>, <span class="number">75</span>, <span class="number">75</span>]</span><br><span class="line">self.motor_names += [<span class="string">"left_shoulder1"</span>, <span class="string">"left_shoulder2"</span>, <span class="string">"left_elbow"</span>]</span><br><span class="line">self.motor_power += [<span class="number">75</span>, <span class="number">75</span>, <span class="number">75</span>]</span><br></pre></td></tr></table></figure><p>执行 <code>step</code> 时，pybullet-gym 中使用力矩对机器人电机进行控制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_torque</span><span class="params">(self, torque)</span>:</span></span><br><span class="line">    self._p.setJointMotorControl2(bodyIndex=self.bodies[self.bodyIndex], jointIndex=self.jointIndex,controlMode=pybullet.TORQUE_CONTROL, force=torque)  <span class="comment"># positionGain=0.1, velocityGain=0.1)</span></span><br></pre></td></tr></table></figure><p>接下来查看观测空间定义，状态观测是由 <code>observation, reward, done, info = env.step(action)</code> 获得，因此查看源码 <code>walker_base_env.py</code> 可知状态计算方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.clip(np.concatenate([more] + [j] + [self.feet_contact]), <span class="number">-5</span>, +<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>大致包含机器人的离地面高度、机器人欧拉角、各个关节相对位置、足底是否触地等状态。状态维度为一共为 46，详细的定义，以及为什么这么定义的原因未知，参见这条 issue 的讨论 <a href="https://github.com/openai/gym/issues/585" target="_blank" rel="noopener">openai/gym/issues/585</a>，看来 OpenAI 被戏称为 CloseAI 是有原因的。</p><p><code>done</code> 根据机器人的高度和偏航角来判断机器人是否摔倒，回合是否结束</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alive = float(self.robot.alive_bonus(state[<span class="number">0</span>] + self.robot.initial_z, self.robot.body_rpy[<span class="number">1</span>]))   <span class="comment"># state[0] is body height above ground, body_rpy[1] is pitch</span></span><br></pre></td></tr></table></figure><h2 id="奖励函数">奖励函数</h2><p>对于强化学习问题，最为重要的就是奖励函数的设计，直接关乎训练后 Agent 的行为是否符合预期。<code>HumanoidPyBulletEnv-v0</code> 的奖励由下面几部分构成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.rewards = [</span><br><span class="line">    alive,</span><br><span class="line">    progress,</span><br><span class="line">    electricity_cost,</span><br><span class="line">    joints_at_limit_cost,</span><br><span class="line">    feet_collision_cost</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>alive</code>: 判断机器人是否摔倒</li><li><code>progress</code>: 速度的差值</li><li><code>electricity_cost</code>: 控制的能量损耗，由扭矩和电机速度计算</li><li><code>joints_at_limit_cost</code>: 关节是否卡住</li><li><code>feet_collision_cost</code>：足底碰撞检测</li></ul><p>Pybullet-Gym 代码逻辑是很清晰，但是由于是移植的 roboschool 的 <code>Humanoid</code> 环境，很多 Agent 代码细节没有文档可以参考，官方的态度是我们只需要关心采用哪些强化学习算法去训练 Agent 就可以了，不需要关注 Agent 的实现细节。</p><p>但是如果要训练自定义的 Biped Robot Walk 的话就必须深入看 Gym 的底层代码实现，研究状态、运动、以及奖励函数的具体细节。</p><h2 id="补充">补充</h2><ul><li><a href="https://github.com/openai/gym/wiki/Humanoid-V1#observation" target="_blank" rel="noopener">Humanoid V1 Wiki 介绍</a></li></ul><h2 id="参考链接">参考链接</h2><ul><li><a href="https://github.com/openai/gym" target="_blank" rel="noopener">https://github.com/openai/gym</a></li><li><a href="https://github.com/benelot/pybullet-gym" target="_blank" rel="noopener">https://github.com/benelot/pybullet-gym</a></li><li><a href="https://thinkhard.tech/2019/08/21/OpenAI-Gym-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/">OpenAI Gym 源码阅读:创建自定义强化学习环境</a></li><li><a href="https://blog.csdn.net/guyubit/article/details/52995676" target="_blank" rel="noopener">欧拉中的俯仰、横滚、偏航角</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenAI gym 是当前使用最为广泛的用于研究强化学习的工具箱，但 Gym 的物理仿真环境使用的是 Mujoco，不开源且收费，这一点一直被人诟病。而 Pybullet-gym 是对 Openai Gym Mujoco 环境的开源实现，用于替代 Mujoco 做为强化学
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Reinforcement Learning" scheme="http://thinkhard.tech/tags/Reinforcement-Learning/"/>
    
      <category term="Simulation" scheme="http://thinkhard.tech/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI Gym 源码阅读:创建自定义强化学习环境</title>
    <link href="http://thinkhard.tech/2019/08/21/OpenAI-Gym-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
    <id>http://thinkhard.tech/2019/08/21/OpenAI-Gym-创建自定义强化学习环境/</id>
    <published>2019-08-21T08:24:35.000Z</published>
    <updated>2019-08-21T08:27:00.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="openai-gym-源码阅读创建自定义强化学习环境">OpenAI Gym 源码阅读：创建自定义强化学习环境</h1><h2 id="gym-介绍">Gym 介绍</h2><p><a href="https://gym.openai.com/" target="_blank" rel="noopener">Gym</a> 是一套开发强化学习算法的工具箱，包含了一系列<a href="https://gym.openai.com/docs/#environments" target="_blank" rel="noopener">内置的环境</a>，结合强化学习算法就可以对内置的环境进行求解。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190821145807.png" width="60%"></div><p>例如，调用 <code>CartPole-v0</code> 环境的示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">'CartPole-v0'</span>)</span><br><span class="line"><span class="keyword">for</span> i_episode <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    observation = env.reset()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        env.render()</span><br><span class="line">        print(observation)</span><br><span class="line">        action = env.action_space.sample()</span><br><span class="line">        observation, reward, done, info = env.step(action)</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            print(<span class="string">"Episode finished after &#123;&#125; timesteps"</span>.format(t+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">env.close()</span><br></pre></td></tr></table></figure><p>Gym 仿真主要包括</p><ul><li>导入环境 <code>gym.make('CartPole-v0')</code></li><li>初始化环境 <code>env.reset()</code>，将强化学习环境设置为初始状态</li><li>一步仿真 <code>env.step(action)</code>，输入动作，获得环境反馈</li><li>渲染可视化当前状态 <code>env.render()</code></li></ul><p>虽然 Gym 内置了大量强化学习环境，如果想训练自定义的强化学习问题，就必须要创建自定义的强化学习环境。</p><h2 id="源码解析">源码解析</h2><p>根据上一节的 Gym 主要函数调用接口，<a href="https://github.com/openai/gym/blob/master/gym/envs/classic_control/cartpole.py" target="_blank" rel="noopener">CartPoleEnv</a> 继承了基类 <a href="https://github.com/openai/gym/blob/master/gym/core.py" target="_blank" rel="noopener">gym.Env</a>，里面定义了主要的 API 方法</p><ul><li>step</li><li>reset</li><li>render</li><li>close</li><li>seed</li></ul><p>创建了自定义的环境，需要由 <a href="https://github.com/openai/gym/blob/master/gym/envs/__init__.py" target="_blank" rel="noopener">gym/envs/<strong>init</strong>.py</a> 进行注册，注册 <code>id</code> 名，指定路径 <code>gym.envs.classic_control:CartPoleEnv</code> 和其他参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym.envs.registration <span class="keyword">import</span> registry, register, make, spec</span><br><span class="line"></span><br><span class="line">register(</span><br><span class="line">    id=<span class="string">'CartPole-v0'</span>,</span><br><span class="line">    entry_point=<span class="string">'gym.envs.classic_control:CartPoleEnv'</span>,</span><br><span class="line">    max_episode_steps=<span class="number">200</span>,</span><br><span class="line">    reward_threshold=<span class="number">195.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/openai/gym/blob/master/gym/envs/registration.py#L150" target="_blank" rel="noopener">gym/envs/registration.py</a> 实例化了 1 个全局的 <code>registry = EnvRegistry()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Have a global registry</span></span><br><span class="line">registry = EnvRegistry()</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/openai/gym/blob/master/gym/envs/registration.py" target="_blank" rel="noopener">gym/envs/registration.py</a> 中根据 <code>entry_point</code> 实例化环境 <code>env</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Instantiates an instance of the environment with appropriate kwargs"""</span></span><br><span class="line">    <span class="keyword">if</span> self.entry_point <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> error.Error(<span class="string">'Attempting to make deprecated env &#123;&#125;. (HINT: is there a newer registered version of this env?)'</span>.format(self.id))</span><br><span class="line">    _kwargs = self._kwargs.copy()</span><br><span class="line">    _kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">if</span> callable(self.entry_point):</span><br><span class="line">        env = self.entry_point(**_kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cls = load(self.entry_point)</span><br><span class="line">        env = cls(**_kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make the enviroment aware of which spec it came from.</span></span><br><span class="line">    env.unwrapped.spec = self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env</span><br></pre></td></tr></table></figure><p>所以，总结一下，如果希望导入自定义环境的话，只需要在自定义的 <code>package</code> 中注册 id，并指定自定义 Env 类的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym.envs.registration <span class="keyword">import</span> register</span><br><span class="line"></span><br><span class="line">register(</span><br><span class="line">    id=<span class="string">'custom-env-name'</span>,</span><br><span class="line">    entry_point=<span class="string">'path.to:CusEnvClassName'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后调用 <code>gym.make('custom-env-name')</code> 就能导入自定义的环境</p><h2 id="创建自定义环境">创建自定义环境</h2><p>根据上面注册环境的流程分析，可知，要引入自定义环境，不必改动 Gym 的源码，只需创建一个 Python 模块 即可。目录结构解释如下</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190821161511.png" width="80%"></div><p>为了方便调试调用，以 <code>pip install -e .</code> 安装自定义模块。测试代码中，引入模块时，即可将自定义环境注册到 Gym 环境中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_foo</span><br><span class="line">env = gym.make(<span class="string">'foo-v0'</span>)</span><br></pre></td></tr></table></figure><h2 id="自定义环境模块参考代码">自定义环境模块参考代码</h2><ul><li><a href="https://github.com/wangshub/Tic-Tac-Toe-Gym_Environment" target="_blank" rel="noopener">apoddar573/Tic-Tac-Toe-Gym_Environment</a></li><li><a href="https://github.com/benelot/pybullet-gym" target="_blank" rel="noopener">PyBullet Gymperium</a></li></ul><h2 id="参考">参考</h2><ul><li><a href="https://github.com/apoddar573/Tic-Tac-Toe-Gym_Environment" target="_blank" rel="noopener">Tic-Tac-Toe-Gym_Environment</a></li><li><a href="https://towardsdatascience.com/creating-a-custom-openai-gym-environment-for-stock-trading-be532be3910e" target="_blank" rel="noopener">Create custom gym environments from scratch — A stock market example</a></li><li><a href="https://github.com/benelot/pybullet-gym" target="_blank" rel="noopener">pybullet-gym</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;openai-gym-源码阅读创建自定义强化学习环境&quot;&gt;OpenAI Gym 源码阅读：创建自定义强化学习环境&lt;/h1&gt;
&lt;h2 id=&quot;gym-介绍&quot;&gt;Gym 介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gym.openai.com/&quot; target
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Reinforcement Learning" scheme="http://thinkhard.tech/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>《我的团长我的团》书摘</title>
    <link href="http://thinkhard.tech/2019/08/09/%E3%80%8A%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%8B%E4%B9%A6%E6%91%98/"/>
    <id>http://thinkhard.tech/2019/08/09/《我的团长我的团》书摘/</id>
    <published>2019-08-09T01:27:33.000Z</published>
    <updated>2019-08-09T01:34:30.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我的团长我的团书摘">《我的团长我的团》书摘</h1><p>兰晓龙</p><p>◆ 第二章</p><blockquote><p>对我们之中很多人来说，他是神仙，有把一摊烂泥变成标枪的魔力。我看着他，看着凤凰，凤凰飞临鸡群之上，让鸡们不再安于现实，但鸡最后还得在泥里啄食。他让我发抖了，但抖过之后，我并不觉得我有了魂魄。</p></blockquote><p>◆ 第三章</p><blockquote><p>卢沟桥响枪时我弃学，徐州会战时我从军，四年来败战无数却屡屡逃生，逃到后来我很愤怒，飞机坦克没有咱不说它，对方步兵战术的僵化死板像是得了阿译的亲传。一万年不变的三角队形在丛林和大雾中居然照用，火力兵力都被分散，打过半年仗的中国兵都会说找死了。但败的仍然是我们。我只好想，是我们自己出了问题。</p></blockquote><p>◆ 第四章</p><blockquote><p>我想做第四个，但蛇屁股做了第四个。第五个则是一群——中国人办事，就是得有个起头的，而现在有四个。</p></blockquote><blockquote><p>可世界上骗不来的有几件事情：心安理得、诚实、天真、睡着。</p></blockquote><p>◆ 第五章</p><blockquote><p>死啦死啦不理会康丫的嘀咕：“英国鬼说他们死于狭隘和傲慢，中国鬼说他们死于听天由命和漫不经心。所有的鬼都说他们是笨死的。”我们听天由命地看着他，漫不经心地看着他。听懂了和没听懂的人都是一样的。</p></blockquote><p>◆ 第九章</p><blockquote><p>战场是仁慈的，非生即死，人世间则是残酷的，它为你准备的东西叫作没数。</p></blockquote><blockquote><p>“要麻，你不叫四川兵，不叫排头兵，我当然记得你叫要麻。没什么脑花子，你只是着了一枪就安静地躺下，我们以为你会爬起来就说先人板板，可你再没起来。”我在心里看见了要麻，他仍趴在缅甸丛林里那个不知名的角落里，藤蔓和野花爬在他的身上，让他看上去比他生前远为美丽。</p></blockquote><blockquote><p>我从死人堆里爬出来过很多次，今天却想起来我原来才二十四岁。等在小醉家的门外，我发现我还活着，痛苦而甜蜜，头发根子都在战栗，一个初恋的傻瓜。</p></blockquote><p>◆ 第十一章</p><blockquote><p>尽其道而死也，正命也。桎梏死者，非正命也。</p></blockquote><blockquote><p>我们没法不想起要麻，他的身上应该已经生花长草；想起康丫，我们埋他的地方现在是日军脚下，我们祈望他不要问我们有良心的没；想起从来没关心过的豆饼，希望他现在已经被冲刷到海里，这趟门他出得比我们谁都要远。</p></blockquote><blockquote><p>我沉默。我恨这样，但从小就这样——我夸我强，便有人找来比我强的；我怨我惨，便有人数落比我惨的。我活我的，像死啦死啦一样活着，用一把叫自己的尺子量这个世界。</p></blockquote><blockquote><p>我挣了一下，我愤怒，但是无力。“可是我想说的话很多！”</p></blockquote><blockquote><p>我像个从不练功又起高了音的戏子，想蒙混过最苛刻的看客。</p></blockquote><blockquote><p>阿译就接着说：“可是，如果我三生有幸……”虞啸卿追问：“什么？”“如果我三生有幸，能犯下他犯的那些罪行，我宁愿去死。”</p></blockquote><p>◆ 第十二章</p><blockquote><p>我在进屋前最后回了一次头，看了眼这个不会带给我任何希望的人群。打架的两位成了滚在地上的两个人形，其他人都是夜色下漠不关心的剪影。</p></blockquote><blockquote><p>认得这张脸而已，连这个人都不认得。”</p></blockquote><p>◆ 第十三章</p><blockquote><p>老鼠，我们早习以为常。它大概最擅闻出人类潦倒的气味，它也知道潦倒的人类对它不再形成威胁，从此便大摇大摆在各屋出入。</p></blockquote><p>◆ 第十四章</p><blockquote><p>“进来有路，出去没门”，横批：“你也来啦”。</p></blockquote><blockquote><p>幸福的人，坚强的人，自由的人，宽广的人，活着的活人，为了不看见你们，我宁可挖掉自己的眼睛。</p></blockquote><p>◆ 第十六章</p><blockquote><p>死都不怕，就怕不安逸，命都不要，就要安逸，就这毛病。多少年来这是个被人钉死了的死穴，一打一个准儿。</p></blockquote><p>◆ 第十八章</p><blockquote><p>他后座上有个我们并不认识，但外形熟悉得很的人物——这些把整座学校、整座工厂搬过整个中国的蚂蚁们长得都一个样，破衣烂衫，奄奄待毙，却一脸阳光和希望。</p></blockquote><p>◆ 第二十章</p><blockquote><p>我们现在到另一个世界了，在中国的大地上却有在异域一样的惶恐。我们天天喊着光复，却没想过是这样一种小偷式的光复。</p></blockquote><p>◆ 第二十二章</p><blockquote><p>世航和尚向我们稽首：“阿弥陀佛，施主要快，革命不等人的。”日军重整旗鼓，掷弹筒已经开始在修正弹着点。放爆竹的已经被炸死了，我转头不看，搀住了我的母亲——和尚说得对，不等人的，他们守不了多久。</p></blockquote><p>◆ 第二十三章</p><blockquote><p>我扔下扎了堆看着美国人卖呆的人渣们，悻悻地跟在他身后：“传令官、副官、参谋、翻译官、勤杂兵，我到底是什么？”“哪一件你做好了呢？鼫鼠五能，无一而精。”“你还真有学问。”</p></blockquote><p>◆ 第二十四章</p><blockquote><p>他不肯放过我：“其情可谅。可你做过的最大的错事是你什么也没有做过。”</p></blockquote><blockquote><p>再无生命的烦恼，只剩下思念，思念我从前视为地狱的一切——苦难、欢乐、酸楚、沉闷、狂喜、绝望、安逸、悲伤、愤怒。恐惧的不是死亡本身，是以后要永远隔着一条冥河与希望对视——那东西只属于活着的人。</p></blockquote><p>◆ 第二十五章</p><blockquote><p>虞啸卿，闻鸡起舞卧薪尝胆，以他的高傲甚至学会了隐忍和求全。现在他等来了物资，等来了武器，等来了加强的炮兵和强渡器材，等来了美国人的激赏和合作，谙熟了怒江的水文，竹内连山闹过的笑话再也不会在他身上出现。现在这辆战车再也刹不住了，这里所有的人将会陪他粉身碎骨。</p></blockquote><p>◆ 第二十六章</p><blockquote><p>“蠢话！从东北到西南！从民国二十年到三十三年！居然还在这里痴心妄想？——自己掌嘴！”</p></blockquote><blockquote><p>你现在还在想，说还是不说！我们都想胜利，谁他妈不想？！可怎么又是我们？——别走啦！你看着我！我像不像个活鬼？我们每个人都像。你现在不是看着我，是看着炮灰团的所有弟兄，你告诉我，告诉所有弟兄，我们还有什么没做？”</p></blockquote><blockquote><p>上天宠爱骄傲的人，给他们一颗永远孩童般的心。我说的不是天真淳良，而是他们永远只顾自己的喜好厌憎。</p></blockquote><p>◆ 第二十七章</p><blockquote><p>初从文，三年不中；后习武，校场发一矢，中鼓吏，逐之出；遂学医，有所成。自撰一良方，服之，卒。</p></blockquote><p>◆ 第二十八章</p><blockquote><p>时间就是吞噬自己尾巴的一条蛇，我们身在其中，永不知何谓始，何谓终。</p></blockquote><p>◆ 第二十九章</p><blockquote><p>我们不仅失去了一只在死时可以握住的手，还丧失了我们中间唯一的老人。我们只剩下二三十岁人的冲动和疯狂，因为我们丧失了一个五十七岁人的沉稳和经验。我们失去了软弱，可并没变得坚强，我们发疯似的想念兽医式的软弱。</p></blockquote><blockquote><p>虞啸卿问：“你什么意思？”死啦死啦说：“有件不怕死的事情，要找不怕死的人一起做。”虞啸卿嘴角都没动，可给人的感觉是他好像有半个笑容：“你何不再来一次？”</p></blockquote><p>◆ 第三十章</p><blockquote><p>一群只知哭泣和伤痛的人，如果有一个能坚持他的欢笑，那么所有没瞎的就能看见星星。一千年的晚上，如果只有一个晚上出现星星，那么所有人就会相信天堂。</p></blockquote><blockquote><p>“要什么？你们要什么？要什么都听不懂吗？这么群孬兵，难怪我要被人叫百败将军！你们要什么？肚子饿了要吃，困了要睡，小日本要咱死，咱就得挣着命活！太娘娘腔了就得去做男人玩儿玩儿命！太不懂事就得去经经事儿！太极阴阳，八卦乾坤，你缺什么得自己要，开了这口就得自己去挣！要什么听不懂吗？要什么？要什么？! ”</p></blockquote><blockquote><p>不辣叫道：“我们没医生！”“现在有啦！好几个！”“我们要兽医！”不辣又叫道。死啦死啦干脆地说：“死啦！”</p></blockquote><p>◆ 第四十一章</p><blockquote><p>袍泽，老友，我的兄长，这酒我好不容易找得来的，跟咱俩是一个年头的。酒陈下来还有人找，人再放可就没人光顾了。</p></blockquote><blockquote><p>做不到你们要我做的，把陋习说成美德，把假话变成了规矩，把抹杀良心说成明智，把自私说成了爱国，把无耻变成了表演，把阳痿说成守身如玉，把欺凌弱小说成正义，把人变成炮灰，把炮灰变成荣誉……</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我的团长我的团书摘&quot;&gt;《我的团长我的团》书摘&lt;/h1&gt;
&lt;p&gt;兰晓龙&lt;/p&gt;
&lt;p&gt;◆ 第二章&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对我们之中很多人来说，他是神仙，有把一摊烂泥变成标枪的魔力。我看着他，看着凤凰，凤凰飞临鸡群之上，让鸡们不再安于现实，但鸡最后还
      
    
    </summary>
    
    
      <category term="Book" scheme="http://thinkhard.tech/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>监视我的手机：数据都去哪儿了？</title>
    <link href="http://thinkhard.tech/2019/07/15/tracking-my-phone/"/>
    <id>http://thinkhard.tech/2019/07/15/tracking-my-phone/</id>
    <published>2019-07-15T10:32:54.000Z</published>
    <updated>2019-07-17T08:59:09.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监视我的手机数据都去哪儿了">监视我的手机：数据都去哪儿了？</h1><blockquote><p><em><strong>警告</strong>: 请勿用于非法目的，非法获取他人隐私属于犯罪!</em></p></blockquote><blockquote><p><em>“现在的人几乎是全部透明的。我心里就想，马化腾肯定天天在看我们的微信，因为他都可以看的，随便看，这些问题非常大。” —— 李书福</em></p></blockquote><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716170641.png" width="80%"></div><p><strong>日常使用的手机可能比想象的更加活跃</strong>，当微信聊天、淘宝购物、抖音看视频甚至是喵的手机待机啥也不干，某些 App 都会悄悄地与服务器交换着数据。这些数据包括微信聊天记录、地理位置、通讯录、通话记录、QQ消息，甚至短信 内容...</p><p>我一直想知道<strong>我的数据都去了哪里</strong>？<strong>哪些 App 在源源不断上传数据</strong>？<strong>数据被哪些公司搜集了</strong>？</p><p>前一段时间，浏览过一篇国外的博客《<a href="https://kushaldas.in/posts/tracking-my-phone-s-silent-connections.html" target="_blank" rel="noopener">Tracking my phone's silent connections</a>》，文中作者 Kushal 使用 WireGuard 代理的方式，监控自己的手机 1 个星期，截获手机与服务器之间的所有请求，最后统计了手机到底悄悄地在和哪些公司的服务器进行连接。</p><p>受到 Kushal 的启发，我决定使用部署 ss 的方式截获我个人的手机数据。</p><h2 id="监控方案">监控方案</h2><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190715193635.png" width="80%"></div><h3 id="实验设备">实验设备</h3><ul><li>日常使用的安卓手机 <code>x1</code></li><li>国内某云服务器 <code>x1</code></li></ul><h3 id="代理方案">代理方案</h3><p>手机的数据都是与不同的服务器进行着连接，如何获取所有的连接？首先我想到的是手机要通过 Wi-Fi 路由器上网，那么如果在路由器端截取数据包，会比较容易。但是无法获取手机的移动基站流量。</p><p>于是在 1 台云服务器上搭建了个代理服务，手机客户端设置为全局代理连接 VPN 服务器，就可以在服务器端获取所有的数据请求。</p><h3 id="部署服务">部署服务</h3><p>为了保证上网访问速度，提升网络体验，推荐选择国内的服务器，代理服务器首先安装 Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get -y install docker.io</span></span><br></pre></td></tr></table></figure><p><strong>启动 ss Docker 容器</strong></p><p>通过阅读 ss 的文档，可知在启动 ss 时只需要加上 <code>-v</code> 参数(Verbose mode)即可输出详细 Log。同时使用 <code>tmux</code> 让服务在后台运行，将输出以追加的方式(<code>&gt;&gt;</code>)重定向到 <code>logs.txt</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tmux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker run -t --name ss -p 9000:9000 mritd/shadowsocks -s <span class="string">"-s 0.0.0.0 -p 9000 -m aes-256-cfb -k yourpassword --fast-open -v"</span> &gt;&gt; logs.txt</span></span><br></pre></td></tr></table></figure><p><strong>手机客户端</strong></p><p>在手机端安装 ss 或者酸酸乳客户端，配置代理服务器地址、端口、密码与加密方式，代理模式设置为全局代理。</p><p>然后在服务器端，使用 <code>tail</code> 命令从指定点开始将从文件写到标准输出，显示实时 Log，服务搭建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -f logs.txt</span></span><br></pre></td></tr></table></figure><p>当手机使用微信时，记录的 Log 日志如下</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716105753.png" width="80%"></div><h3 id="数据处理">数据处理</h3><p><strong>DNS 域名解析</strong></p><p>DNS(Domain Name System)，翻译过来就是域名系统，是互联网上作为域名和 IP 地址相互映射的一个分布式数据库。获取到的记录大多数是域名，需要先解析成 IP 地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">domain_to_ip</span><span class="params">(domain)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> socket.gethostbyname(domain)</span><br></pre></td></tr></table></figure><p>例如，解析 <code>www.baidu.com</code> 的 IP 地址 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">domain_to_ip(<span class="string">'www.baidu.com'</span>)</span><br><span class="line"><span class="string">'14.215.177.38'</span></span><br></pre></td></tr></table></figure></p><p><strong>IP 地理数据库</strong></p><p>推荐使用 <a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">ip2region</a>，一个开源的 IP 到地区的映射库，具有 99.9% 准确率，提供 Binary,B 树和纯内存三种查询快速搜索算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; result = ipgeo.find(<span class="string">'www.baidu.com'</span>)</span><br><span class="line">&gt;&gt; print(result)</span><br><span class="line">&#123;<span class="string">'ip'</span>: <span class="string">'14.215.177.38'</span>, <span class="string">'city_id'</span>: <span class="number">2140</span>, <span class="string">'country'</span>: <span class="string">'中国'</span>, <span class="string">'province'</span>: <span class="string">'广东省'</span>, <span class="string">'city'</span>: <span class="string">'广州市'</span>, <span class="string">'operator'</span>: <span class="string">'电信'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>保存数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(out_csv, index=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">'saved to &#123;&#125;'</span>.format(out_csv))</span><br></pre></td></tr></table></figure><h3 id="数据可视化">数据可视化</h3><p>经过十多天的记录，俺一共记录了 <code>280059</code> 条记录</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716182131.png" width="50%"></div><p>接下来使用 Pyecharts 对数据进行可视化。Echarts 是百度开源的一个数据可视化 JS 库，而 Pyecharts 是一个用于生成 Echarts 图表 Python 库。</p><h4 id="主要的互联网公司">主要的互联网公司</h4><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716091323.png" width="80%"></div><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716163609.png" width="80%"></div><p>从上图可以看出，俺的安卓手机(安装了谷歌服务)，在国内的网络环境，请求次数最多还是 Google。</p><p>然后就是日常使用的微信和 QQ 了。由于平时会看 B 站视频，所以 Bilibili 排名第三 orz...</p><p>我手机安装的是 QQ 输入法，但是去往 <code>sougou.com</code> 的请求居然有 <code>1952</code> 条，查看了用户协议才发现 <code>“QQ输入法”是经腾讯公司认可，由搜狗公司发布的客户端软件。</code></p><p>还有像美团、高德地图这样的软件，平时并不怎么频繁使用，网络请求却异常地活跃，不知道偷偷摸摸干着啥。</p><h4 id="夜间活动排行">夜间活动排行</h4><p>过滤出凌晨 00:00 ~ 06:00 时间段的活动，可以发现去往 <code>*.qq.com</code> 的连接始终是最多的。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716164538.png" width="80%"></div><h4 id="全球分布">全球分布</h4><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716091052.png" width="80%"></div><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716091018.png" width="80%"></div><h4 id="国内各省份分布">国内各省份分布</h4><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716091206.png" width="80%"></div><p>可以看到俺的流量大多去往了广东、上海和北京这样的地方，台湾这么高的原因是谷歌的服务器在那边，DNS 解析谷歌的域名都指向了台湾。</p><h4 id="电信运营商">电信运营商</h4><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716095130.png" width="80%"></div><h4 id="服务器端口统计">服务器端口统计</h4><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190716091544.png" width="80%"></div><h4 id="其他">其他</h4><p>在一加手机的网络请求中，发现了一些发往 oppo 服务器的请求，看来不光硬件由 oppo 代工，连软件也是。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'epoch.cdo.oppomobile.com'</span>, <span class="number">208</span>),</span><br><span class="line"> (<span class="string">'gslb.cdo.oppomobile.com'</span>, <span class="number">38</span>),</span><br><span class="line"> (<span class="string">'istore.oppomobile.com'</span>, <span class="number">38</span>),</span><br><span class="line"> (<span class="string">'opsapi.store.oppomobile.com'</span>, <span class="number">34</span>),</span><br><span class="line"> (<span class="string">'api.cdo.oppomobile.com'</span>, <span class="number">22</span>),</span><br><span class="line"> (<span class="string">'message.pull.oppomobile.com'</span>, <span class="number">21</span>),</span><br><span class="line"> (<span class="string">'st.pull.oppomobile.com'</span>, <span class="number">13</span>),</span><br><span class="line"> (<span class="string">'cdopic0.oppomobile.com'</span>, <span class="number">9</span>),</span><br><span class="line"> (<span class="string">'newds01.myoppo.com'</span>, <span class="number">9</span>),</span><br><span class="line"> (<span class="string">'httpdns.push.oppomobile.com'</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="string">'conn1.oppomobile.com'</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="string">'iopen.cdo.oppomobile.com'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="最后">最后</h3><blockquote><p>吉利控股集团创始人、董事长李书福曾说 “现在的人几乎是全部透明的。我心里就想，马化腾肯定天天在看我们的微信，因为他都可以看的，随便看，这些问题非常大。”</p></blockquote><h3 id="完整代码">完整代码</h3><p><a href="https://github.com/wangshub/tracking-my-phone" target="_blank" rel="noopener">https://github.com/wangshub/tracking-my-phone</a></p><ul><li>如果需要更为详细的数据，可以考虑使用 <a href="https://mitmproxy.org/" target="_blank" rel="noopener">mitmproxy</a> 代理，能够抓取 HTTPS 数据，并提供 Python API。</li></ul><h3 id="参考链接">参考链接</h3><ul><li><a href="https://kushaldas.in/posts/tracking-my-phone-s-silent-connections.html" target="_blank" rel="noopener">Tracking my phone's silent connections</a></li><li><a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">ip2region: Ip2region is a offline IP location library</a></li><li><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Python Data Analysis Library</a></li><li><a href="https://pyecharts.org" target="_blank" rel="noopener">Pyecharts: A Python Echarts Plotting Library.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监视我的手机数据都去哪儿了&quot;&gt;监视我的手机：数据都去哪儿了？&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;警告&lt;/strong&gt;: 请勿用于非法目的，非法获取他人隐私属于犯罪!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquo
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="VPN" scheme="http://thinkhard.tech/tags/VPN/"/>
    
      <category term="Tacking" scheme="http://thinkhard.tech/tags/Tacking/"/>
    
  </entry>
  
  <entry>
    <title>现实世界中的机器人强化学习</title>
    <link href="http://thinkhard.tech/2019/06/19/Reinforcement-Learning-for-Real-World-Robotics/"/>
    <id>http://thinkhard.tech/2019/06/19/Reinforcement-Learning-for-Real-World-Robotics/</id>
    <published>2019-06-19T09:12:18.000Z</published>
    <updated>2019-06-25T11:27:02.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现实世界中的机器人强化学习">现实世界中的机器人强化学习</h1><blockquote><p>原载：<a href="https://towardsdatascience.com/reinforcement-learning-for-real-world-robotics-148c81dbdcff" target="_blank" rel="noopener">Reinforcement Learning for Real-World Robotics</a></p><p>译者：神奇的战士</p></blockquote><h2 id="机器人---愿景">机器人 - 愿景</h2><p>机器人在现代工业中无处不在。与上个世纪大多数科幻作品中的机器人不同，现如今的机器人仍没有为人类洗盘子和倒垃圾，在战场上也没有出现像施瓦辛格那样的机器人终结者。但是，在所有的工厂车间内都能发现机器人的身影，机器人正在做人类工人几十年前做的那种单调而繁重的工作。任何具有重复性和精细的工作，如果可以被精确控制和监控的话，那么机器就能很好替代人工。目前的前沿的一些研究将以前我们认为非常难以机器实现且乏味的工作用机器自动化了（如自动驾驶）。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190619212510.png" width="40%"></div><p>我们对机器人的痴迷的原因是显而易见的；对于许多人来说，一个人类摆脱繁重乏味的体力劳动的未来似乎是非常值得憧憬的。另外，机器特有的精确性和一致性可以减少因为认为错误而引发的灾难，例如车祸和手术时的医疗事故。我们可以在工厂的生产线上看到这场革命的一点前兆：在一些像亚马逊的大型仓库中，机器人被用来代替人工运输板箱。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190619214718.png" width="40%"></div><p>虽然我们在战场上还没有杀人的仿人机器人，但我们确实有半自主无人机在世界各地运行，执行军事侦察和作战任务。军队的研究机构正在做大量的工作减少对人类士兵的伤害，将机器人投入战斗，我预计未来的几十年内我们将看到这样的进展。</p><h2 id="机器人强化学习">机器人强化学习</h2><p>为什么几十年前的科幻作品总是认为在不久的将来智能机器人可以做任何事，但是站在今天的角度我们认为这是一件遥远的事情？为什么现在工厂车间里到处都是机器人，但是我们的大街上却没有机器人的身影？在特定环境中运作的机器人，必须以某种方式理解自身的行为，规划动作和利用某种执行器执行动作，同时使用反馈来确保控制的准确性。</p><p>事实证明，上面的每一个部分都是难点，对人类来说再简单不过的事（如视觉场景下识别物体和某种程度上预测人的意图）对电脑来说却充满了挑战。近些年来，深度学习使得计算机视觉有了较大的突破，但是要理解普通街道的场景需要大量的相关技术，以现在的水平还远远做不到。</p><p>事实证明，在工厂装配线上的机器人与能走在大街上的机器人之间有着天壤之别。在装配线上，环境中的所有情况都可被精确控制，机器人需要完成的任务也相对具体和单一。尽管有这些优点，但是设计工业机器人的运动规划和控制算法仍然是一个枯燥且漫长的过程，这需要集成多个领域的专家的成果。这使得研发机器人昂贵和耗时，这进一步突出了我们当前的技术与让机器人在一般性的环境中执行一系列任务所需能力之间的巨大差距。在特性场景下开发专用机器人的算法都这么费劲，那么如何能让机器人再进入家庭呢？与洗碗机器人和喷漆机器人相比，这些机器人不得不在复杂的城市空间内导航和确保安全条件下与人交流。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190621211516.png" width="40%"></div><p>近些年随着深度学习和强化的发展，许多研究人员开始研究使用强化学习方法控制机器人。这样做的动机显而易见，我们可以让让机器人自主学习而不是专门为机器人开发感知、规划和控制算法吗？如果我们能做到的话，那么就能立马解决两个问题：节省花在开发设计机器人算法上的时间、为当前我们无法解决的难题提供解决方案。</p><p>深度强化学习在各种电子游戏、棋盘类游戏和相对简单仿真控制问题上取得了巨大的成功，并走进公众的视野。在这些任务当中，智体学习的环境和实际运行的环境是相同的，并且我们可以有效地利用仿真让智体学会解决问题之前进行多次尝试。众所周知，深度强化学习算法对数据的利用率很低，在学会玩雅达利游戏之前必须要经过数百万次的尝试。如果我们以同样的方法在实际环境中训练机器人，那将花费大量的时间并且对机器人硬件造成极大地磨损。或者，我们可以尝试在仿真环境中训练智体然后把训练好的策略部署在实体机器人上。但是要去模拟错综复杂的现实世界是异常困难的，这种预训练好的策略在实体机器人上常常表现糟糕。</p><p>将强化学习应用在机器人上仍然困难重重，在我看来，这些问题可以分为 4 类：</p><p><strong>采样效率</strong>：如果我们希望使用实体机器人训练策略，那么我们必须开发出使用很少试验就可以学习的算法，训练过程才是可行的。</p><p><strong>仿真到实际</strong>：如果我们希望在仿真环境中训练策略并且部署在机器人上</p><p><strong>奖励规则</strong>：当我们在玩《星际争霸2》时，游戏的目标清晰明了：获胜或失败。然而我们如何量化像洗盘子或者叠衣服这样的行为的成功度？</p><p><strong>安全性</strong>：无论是仿真还是部署在真实环境中，我们的机器人策略要是安全的，必须确保机器人自身的完整性和环境中人身和财产的安全。</p><p>我将着重强调机器人前两个问题，简要描述第三个问题，最后个问题暂且不讨论。</p><h2 id="采样效率">采样效率</h2><p>通常在低采样复杂度情况下首选的方法是基于模型的强化学习方法。在基于模型的强化学习中，与基于和环境交互获得的奖励来学习一个策略的方法不同，智体会尝试学习环境的模型并且使用它来规划和提升策略，因此可以大幅减少所需的与环境交互的次数。然而，这种方法与基于模型方法相比有较低的渐进性能，有时会因为所学模型中的错误而遭受灾难性的失败。</p><p>基于模型的强化学习在可以简单表示的动力学模型上取得了巨大的成功，例如线性模型，但是在更为复杂的环境中就需要非线性的模型了（如深度神经网络）。在 2018 年，来着伯克利的学者就这个问题发表了一篇<a href="https://arxiv.org/pdf/1802.10592.pdf" target="_blank" rel="noopener">论文</a>[1]，在其中他们找到不稳定问题的一个可疑的原因，并提出了解决办法。</p><p>在论文中，作者表示在学习和规划的过程中，策略倾向利用状态空间区域，在这些区域学习到的策略表现不佳，这使得智体偏离了“航线”，无法在这个区域内使用学习好的策略提前规划导致了智体策略失效。他们的解决办法相对简单：学习环境的多种模型，在规划过程中，从这些不同的模型中均匀抽取样本，有效地规范了学习过程。这种方式就更容易将基于模型的强化学习应用到复杂任务中，实现了使用较少的试验而达到无模型方法那样的渐进性。</p><p>有趣的是，最近的无模型算法在采样的复杂性上有较大突破，以至于可以短时间内在实体机器人上训练策略。在 2019 年，来自伯克利和谷歌大脑团队的学者发表了一篇<a href="https://arxiv.org/pdf/1812.05905.pdf" target="_blank" rel="noopener">论文</a>[2]，提出称为 Soft Actor Critic (SAC) 的异步策略 Actor Critic 算法。论文证明了该算法在几个传统的强化学习控制测试结果中具有很好的低样本复杂度性能，然后让机器人在 4 个小时的训练后就学会了走路。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190624143743.png" width="40%"></div><p>在平面上训练机器人，然后在有障碍物的表面测试机器人，展示了学习的策略的鲁棒性。</p><p>另一篇很棒的<a href="https://arxiv.org/pdf/1812.03201.pdf" target="_blank" rel="noopener">论文</a>[3]以另一种不同的方式看待采样效率：通过摈弃策略必须从零开始学习的概念，利用现有的不完善的控制算法来提供一个“框架”，在此基础上训练策略。通过利用现有的控制算法可以很好地对该问题进行表征的优点，策略能够学习有效地调节控制系统而不是像大多数强化学习算法那样采取随机动作。文章中使用了这种方法训练机器人完成了在动力学上极其复杂的装配任务。</p><h2 id="从仿真到现实">从仿真到现实</h2><p>在过去的几年里，许多论文展示了训练好的强化学习策略运用在实体机器人平台上的能力，但是常常局限于一些特定的任务，通常需要大量的手动调整才能完成。特别是对于使用视觉来感知的机器人来说，要真实地模拟机器人所感知到的所有视觉图像是异常困难的，这就产生了著名的仿真和现实差异性问题。</p><p>在那些仿真里可以充分描述动力学的问题中，强化学习也可以很好地工作，正如这篇<a href="https://arxiv.org/pdf/1901.07517.pdf?fbclid=IwAR21IneQ5Lusw62bCyh0oDzRJYh2nKercXP53vp35dIGtT-edIcITZBeetc" target="_blank" rel="noopener">文章</a>[4]，使用仿真训练策略让四足机器人恢复动作，训练好的策略在实体机器人上效果也很不错，拥有 97% 的成功率。然而，不像视觉问题，在这篇论文中的状态的维度相对较低。</p><p>为了解决视觉输入的问题，OpenAI 和伯克利团队在 2017 年的论文中提出了一个非常完美的解决方案：随机化环境提供的视觉输入，然后训练策略对这些随机的鲁棒性，现实世界可能是另一种仿真的随机变化。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190624152851.png" width="40%"></div><p>这种方法效果不错，他们能够在一个真正的机器人抓取系统中使用一个只接受过模拟仿真训练的目标检测器。</p><p>在 2019 年又发表了后续的另一篇很棒的<a href="https://arxiv.org/pdf/1812.07252.pdf" target="_blank" rel="noopener">论文</a>[5]。在这片论文中，作者使用一个类似的随机仿真来帮助训练鲁棒的策略，但是同时训练了一个条件生成对抗网络 (cGAN) 来将随机图像转换回原始模拟仿真的标准形式。在测试时，条件生成对抗网络将真实图像转换为策略所熟悉的规范图像形式，这样可以有效地减小仿真到现实之间的差别。使用这种方法，论文中仿真训练好的智体应用在实体机器人上有 70% 的成功率。在实体机器人进行一些微调，他们能够达到 91% 甚至是 99% 的成功率。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190624153832.png" width="80%"></div><h2 id="奖励规则">奖励规则</h2><p>假设你希望你的机器人学会把书放在书架上，并且你有一个非常低样本复杂度的算法。如何设计奖励函数呢？在 2019 年一篇<a href="https://arxiv.org/pdf/1904.07854.pdf" target="_blank" rel="noopener">论文</a>[6]中，来自伯克利的作者做到了。他们没有指定奖励函数，而是为算法提供了几张目标图像（排列好的书架），允许训练过程中询问（很少几次）用户当前状态是否是目标状态。通过令奖励 r = 前面提到的 Soft Actor Critic 算法，作者在实体机器人上训练了几个小时的策略。他们为不同的任务训练了不同的策略，例如把书放到书架上和把一块布搭在盒子上。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190624154635.png" width="40%"></div><h2 id="结论">结论</h2><p>要解决将强化学习应用于现实世界中的机器人问题还有很长的路要走，但是，我们正在取得很多的进展，希望我们在这个激动人心的领域看到进一步的突破。</p><h2 id="文献链接">文献链接</h2><ul><li>[1] https://arxiv.org/pdf/1802.10592.pdf</li><li>[2] https://arxiv.org/pdf/1812.05905.pdf</li><li>[3] https://arxiv.org/pdf/1812.03201.pdf</li><li>[4] https://arxiv.org/pdf/1901.07517.pdf</li><li>[5] https://arxiv.org/pdf/1812.07252.pdf</li><li>[6] https://arxiv.org/pdf/1904.07854.pdf</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现实世界中的机器人强化学习&quot;&gt;现实世界中的机器人强化学习&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;原载：&lt;a href=&quot;https://towardsdatascience.com/reinforcement-learning-for-real-world-r
      
    
    </summary>
    
    
      <category term="Robot" scheme="http://thinkhard.tech/tags/Robot/"/>
    
      <category term="ReinfocementLearning" scheme="http://thinkhard.tech/tags/ReinfocementLearning/"/>
    
      <category term="DeepLearning" scheme="http://thinkhard.tech/tags/DeepLearning/"/>
    
      <category term="AI" scheme="http://thinkhard.tech/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>两种硬件编程的风格：离线下载和在线交互</title>
    <link href="http://thinkhard.tech/2019/06/13/about-interpreter/"/>
    <id>http://thinkhard.tech/2019/06/13/about-interpreter/</id>
    <published>2019-06-13T07:22:40.000Z</published>
    <updated>2019-06-14T08:33:36.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种硬件编程的风格离线下载和在线交互">两种硬件编程的风格：离线下载和在线交互</h1><p><code>少儿编程教育</code>+<code>智能硬件</code>似乎是天生的一对，二者的结合很容易产生 <code>1 + 1 &gt; 2</code> 的双赢局面。不管是在线编程教育企业，还是智能硬件企业，在接下来的发展中，都纷纷把目光聚焦在教育领域。</p><p>针对硬件编程的模式，在文杰的这篇 <a href="https://blog.just4fun.site/Hardware-Programming-style.html" target="_blank" rel="noopener">《两种硬件编程的风格》</a> 中提到了 <code>交互式</code>与<code>灌入式</code>两种硬件编程风格，并且详细分析了二者之间的优劣。</p><h2 id="离线下载运行">离线下载运行</h2><p><strong>离线下载运行，使用一个 IDE 或者代码生成器生成一份代码(可能需要编译器编译)，然后烧写到硬件设备上运行这一段生成的代码。</strong></p><p>生成代码的方式多种多样，这其中有文本编辑器编辑，或者少儿编程以积木块形式“拼搭”出一份代码。再通过拷贝、烧录等方式把代码下载到硬件 ROM、SD 卡或者其他存储介质中。硬件中的解释器根据下载的代码进行地址跳转，转译一行程序就立刻运行，然后再转译下一行，如此不停地进行下去。</p><div style="text-align:center"><img src="20190614151809.png" width="60%"></div><p>目前图形化项目生成代码的项目比较多，大多数采用了 Google 的 Blockly 方案，这里列举部分</p><ul><li><a href="https://microbit.org/code/" target="_blank" rel="noopener">micro:bit MakeCode Editor</a></li><li><a href="https://www.pibakery.org/" target="_blank" rel="noopener">PiBakery: The easiest way to setup a Raspberry Pi</a></li><li><a href="https://github.com/BlocklyDuino/BlocklyDuino" target="_blank" rel="noopener">BlocklyDuino is a web-based visual programming editor for arduino.</a></li><li>还有市面上大多数的带教育属性的编程硬件产品；</li></ul><p>如果使用过上面这些工具的话，会发现有一个共同点，那就是 UI 界面上一定会有个大大醒目的 <code>下载(上传)</code> 按钮，时刻提醒用户程序必须下载到硬件中，才能成功运行。</p><p>这种离线下载再运行的硬件编程风格也许是微控制器时代的产物，出于成本和功耗的考虑，从最经典的 C51 单片机到 ARM Cortex-M 系列的芯片的智能硬件产品，如果一个嵌入式工程师看到这套可能再熟悉不过了。在如 Keil、IAR、Arudino IDE 中编辑程序，语法检查和编译没有问题之后，烧录到单片机 ROM 当中。</p><p>那么基于微控制器开发出的可编程硬件产品自然而然就会遵循这样的<code>传统</code>。</p><h2 id="在线交互运行">在线交互运行</h2><p>在线运行式的硬件编程，代码解释器运行在单独的环境中，硬件提供 API 接口供解释器运行代码时调用。没有代码下载这个过程。<strong>代码运行在 PC、Pad 或者手机上，程序运行过程中硬件始终需要与解释器保持连接(蓝牙、Wi-Fi 等)，随时准备响应解释器的请求。</strong></p><div style="text-align:center"><img src="20190614151836.png" width="60%"></div><p>在线运行图形化的项目有许多</p><ul><li><a href="http://www.squeakland.org/" target="_blank" rel="noopener">Etoys</a></li><li><a href="https://scratch.mit.edu/" target="_blank" rel="noopener">Scratch3</a></li><li><a href="https://scratch3.codelab.club/" target="_blank" rel="noopener">codelab-scratch3</a></li><li><a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">codelab-adapter</a></li></ul><p>在交互式环境中，每个设备都是一个独立的插件，彼此之间互不干扰，需要设计好每个插件的消息格式。在类似 Scratch 的环境中彼此相遇组合，程序在 Scratch 里运行时动态获取或者控制每个插件设备的状态。以一种比较有趣且优雅的方式实现万物互联。</p><div style="text-align:center"><img src="20190614161017.png" width="80%"></div><h2 id="二者对比">二者对比</h2><p>关于二者的对比，在<a href="https://blog.just4fun.site/Hardware-Programming-style.html" target="_blank" rel="noopener">两种硬件编程风格的比较</a>中已经有非常详细的对比。引用如下</p><blockquote><ol type="1"><li>灌入式可以离线运行，只需要将代码烧入进去，即可脱离编程工具</li><li>灌入式将带来优于交互式的实时性</li><li>灌入式因为需要 Generate 代码，学生可以查看代码</li></ol></blockquote><p>作者站在<code>编程教育是否真的需要离线运行？</code>角度来看待离线<code>离线烧录</code>，同时交互式也可以做好实时性与代码生成。</p><p>离线下载编程与在线交互运行相比，代码运行在 MCU 上，这是优点也是缺点。首先这带来的好处就是<code>轻量</code>，程序运行时没有额外的依赖。但是缺点也很明显，那就是功能很单一，做不了复杂的运算。</p><p>举个例子， 现在有一个 Robot，程序脱机离线运行，它可以唱、跳、RAP和<del>篮球</del>，那如果想为机器人增加视觉能力怎么办？在 ARM Cortex-M 系列芯片上做图像处理目前实在是太勉强，因为<code>它光是跑起来一个代码解释器都已经捉襟见肘</code>。为了弥补这种缺憾，那就是再外接一块类似 Raspberry Pi 的板子或者 ESP8266 Wi-Fi 板用于简单的图像处理或请求云端 API。对价格敏感的硬件产品来说，这无疑又增加了不少时间和物料成本。</p><p>如果换一种思路，程序如果运行在 PC 上，所有与待编程设备之间的通信都是消息 (Message)，PC 的性能相较于 MCU，可以做任何复杂的任务和逻辑。这样其实让 MCU 的肩上的担子轻了很多，MCU 只需要做好外围控制，暴露接口即可。以 Scratch3 为例，如果 Robot 想获得视觉能力怎么办呢？非常简单，只需要提交一个视觉积木插件即可，代码检查，不同程序块之间的兼容性统统不需要考虑。在这样的交互式环境中，硬件设备可以轻松获取各种扩展能力。</p><h2 id="兼顾">兼顾？</h2><p>那么有没有可以同时兼顾在线交互和离线下载的解决方案呢？似乎是可以做到的。</p><p>程序仍然是离线运行在 Robot 上，参考交互式的消息机制，只不过消息的发起方由 PC 转至 Robot，当 Robot 程序运行时，如果需要做图像识别，Robot 向 PC 发送请求，PC 将识别结果再返回给 Robot。这种方式看起来能够解决离线下载运行的痛点，将 PC 看做 Robot 的<code>扩展外设</code>。</p><div style="text-align:center"><img src="20190614161656.png" width="80%"></div><p>但是如果 PC 上的消息接收进程被关闭，Robot 里的程序就无法正常运行。就会对用户出现一个困扰，<code>PC 开启与否，会让同样的 Robot 程序呈现了不同的运行结果</code>。当然作为弥补，可以跟用户解释这背后的逻辑...</p><h2 id="结语">结语</h2><p>离线式受限于性能和成本，没有办法像在线式这么灵活和扩展，如果为了同时满足<code>程序可以脱机运行</code>又要扩展丰富，又要做不少的妥协。但是</p><ul><li><code>编程教育是否真的需要离线运行？</code></li><li><code>就算脱机运行，真的就离得开 PC 吗？</code></li></ul><h2 id="参考链接">参考链接</h2><ul><li><a href="https://blog.just4fun.site/Hardware-Programming-style.html" target="_blank" rel="noopener">两种硬件编程风格的比较</a>.</li><li><a href="https://developers.google.com/blockly/" target="_blank" rel="noopener">A JavaScript library for building visual programming editors: Try Blockly</a></li><li><a href="https://www.arduino.cc/en/Main/Software" target="_blank" rel="noopener">Arduino IDE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;两种硬件编程的风格离线下载和在线交互&quot;&gt;两种硬件编程的风格：离线下载和在线交互&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;少儿编程教育&lt;/code&gt;+&lt;code&gt;智能硬件&lt;/code&gt;似乎是天生的一对，二者的结合很容易产生 &lt;code&gt;1 + 1 &amp;gt; 2&lt;/code&gt; 的
      
    
    </summary>
    
    
      <category term="Code" scheme="http://thinkhard.tech/tags/Code/"/>
    
      <category term="Compiler" scheme="http://thinkhard.tech/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Dynamicland, 可视空间和设计工坊</title>
    <link href="http://thinkhard.tech/2019/06/13/on-dynamicland/"/>
    <id>http://thinkhard.tech/2019/06/13/on-dynamicland/</id>
    <published>2019-06-13T06:51:57.000Z</published>
    <updated>2019-06-13T06:59:47.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dynamicland-可视空间和设计工坊">Dynamicland, 可视空间和设计工坊</h1><blockquote><p>Vitorio Miliano</p></blockquote><p>从 2017 年 9 月 11 日星期一开始 <a href="https://twitter.com/dynamicland1" target="_blank" rel="noopener">Dynamicland</a> 发布的一系列照片和视频剪辑让我意识到，我可能错过了一个有意思的东西 -- 并且是最佳实践 -- 那就是 Bret Victor 在 2014 年分享的 “可视空间”</p><p>下面是一些我尝试总结的片段。（如果你已经熟悉 Dynamicland，这将会有所帮助）</p><h2 id="一个共享的知识空间">一个共享的知识空间</h2><p>在 2013 年，Bret Victor 在<a href="http://worrydream.com/Engelbart/" target="_blank" rel="noopener">《关于道格拉斯·恩格尔巴特的一些话》</a>中批评了那些忽略格拉斯·恩格尔巴特<a href="http://www.dougengelbart.org/firsts/1968-demo-interactive.html" target="_blank" rel="noopener">《所有演示之母》</a>真正意图的回顾。</p><div style="text-align:center"><img src="./nls1.jpg" width="60%"></div><p>从当今计算机系统的角度来看 1968 年的演示，容易忽略恩格尔巴特对 NSL(oN-Line System) 的定位，即从计算机程序员身上开始，作为增强人类智慧的工具。</p><h2 id="最佳的可视化工具是房间">最佳的可视化工具是房间</h2><p>在 2014 年，Bret Victor 发表了<a href="http://worrydream.com/SeeingSpaces/" target="_blank" rel="noopener">《可视空间》</a>，以对话和漫画的形式阐述了“可视空间”的创意，它就像一个工坊或者创客空间，目的是为了帮助人理解而不是建造。</p><div style="text-align:center"><img src="./478481867.jpg" width="80%"></div><p>视频中的对话和漫画的结尾都描述了一个未来实验室样子，在这个实验室中到处都是巨大的显示屏，摄像头和分析仪器，帮助创造者们理解他们正在制作的机器人。</p><h2 id="文字描述已经过时">文字描述已经过时</h2><p>也是在 2014 年，Bret Victor 发表了 <a href="https://vimeo.com/114252897" target="_blank" rel="noopener">《 文字描述已经过时: 通过动态模型阐释和理解》</a>，汇总了一系列包括他自己和别人的例子，这其中包括可探索性解释、可交互文档和软件工具，使系统更加直观和易于理解。</p><h2 id="关于工具">关于工具</h2><p>Bret Victor 在 2014 年有一个的谈话分享，我从中理解到：他说到的是工具，当我们都认真地制造出最符合这种工作方式的工具时，一场革命就将到来。</p><p>在我上一个主要的个人项目中，我就是这样做的：我首先开发出工具，让我首先可以全面、深入地理解所做的工作。</p><h2 id="dynamicland">Dynamicland</h2><p>几年之后，我的推特时间线被 Dynamicland 的参与者搞得有些混乱。我花了一分钟才明白我所看到的 Dynamicland，但如果你点击这条推特，就可以很好地理解 Dynamicland：</p><p><a href="https://twitter.com/redblobgames/status/907253802931126272/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E907253802931126272%7Ctwgr%5E393039363b636f6e74726f6c&ref_url=http%3A%2F%2Fvitor.io%2Fon-dynamicland" rel="noopener" target="_blank"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./20190612145820.png" alt title>                </div>                <div class="image-caption"></div>            </figure></a></p><p>这个项目起源于 Bret Victor 所在的 Y Combinator HARC 实验室。Dynamicland 是一个允许通过实体对象和交互方式编程的工坊，整个房间就是程序员的 IDE。</p><p>但是有另一条推特说道</p><p><a href="https://twitter.com/mandy3284/status/906764328279318528/photo/1?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E906764328279318528%7Ctwgr%5E393039363b636f6e74726f6c&ref_url=http%3A%2F%2Fvitor.io%2Fon-dynamicland" rel="noopener" target="_blank"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./20190612150906.png" alt title>                </div>                <div class="image-caption"></div>            </figure></a></p><p>我在这里引用一下这段话：</p><blockquote><p><em>“把程序从屏幕里搬出来放到桌子上帮助我们互相之间学习”</em>。</p></blockquote><p>那就不仅仅是把房间作为编程的工具。</p><p>房间还是一个促进互相之间相互理解的编程工具。</p><p>我认为我错过了一些东西。</p><h2 id="设计工坊和参与式设计">设计工坊和参与式设计</h2><p>在 2011 年，Will Evans 发表了一系列的文章，介绍了一个最初源于建筑领域的协作设计、工业设计、无关艺术评论的设计工坊。</p><ul><li><a href="https://web.archive.org/web/20111010221154/http://uxmag.com:80/articles/introduction-to-design-studio-methodology" target="_blank" rel="noopener">设计工坊方法简介</a></li><li><a href="https://web.archive.org/web/20111006040634/http://uxmag.com:80/articles/the-design-of-design-studio" target="_blank" rel="noopener">设计工坊的设计</a></li><li><a href="https://web.archive.org/web/20111111004917/http://uxmag.com:80/articles/design-studio-and-agile-ux-process-and-pitfalls" target="_blank" rel="noopener">设计工坊和敏捷用户体验：过程和陷阱</a></li><li><a href="https://www.flickr.com/photos/27764576@N06/sets/72157626509819731/" target="_blank" rel="noopener">自 2011 年 5 月 2 日以来，Will Evans 发布的相簿</a></li></ul><p>在像如<a href="http://jpattonassociates.com/design-studio-recipe/" target="_blank" rel="noopener">产品发掘</a>的过程中，设计工作室方法用于促进参与式设计。</p><p>在工坊的整个过程中，所有的参与者都在同一个实体空间中工作，他们使用相同的工具，彼此之间共享知识。使用的工具是标记纸和便笺，目的是为了促进彼此之间的理解。</p><h2 id="也许不是工具的问题">也许不是工具的问题</h2><p>道格拉斯·恩格尔巴特希望增强人类的智慧。他的论文<a href="http://www.dougengelbart.org/pubs/augment-3906.html" target="_blank" rel="noopener">《增强人类智慧：概念与框架》</a>没有探究通过其他人来增强智力，而是将 NSL 作为工具来增强，因为它支持广泛的协作。NSL 的参与者可以在相同的 <em>虚拟</em> 空间内同时工作，使用相同的工具和共享知识。</p><div style="text-align:center"><img src="./SeeingSpaces-crop.jpg" width="100%"></div><p><strong>文字描述已经过时</strong>是针对工具而言的，但是正如 Bret Victor 在<a href="http://worrydream.com/Engelbart/" target="_blank" rel="noopener">《关于道格拉斯·恩格尔巴特的一些话》</a> 中批判到，这是“当今计算机是针对单用户设计”的产物。在现有的条件约束下，这些是 Bret Victor 能展示给我们的唯一东西。</p><h2 id="也许是为了促进共同理解">也许是为了促进共同理解</h2><p>自从 2010 年以来，我一直在运营着设计工坊，我把上面这张图片和这个引述放到了一起。</p><blockquote><p><em>“把程序从屏幕里搬出来放到桌子上帮助我们互相学习”</em>。</p></blockquote><p>如果可视空间不仅仅是让一个<em>人</em>看到内部构造，看到时间，看到各种可能性的工具呢？</p><p>如果可视空间应该是让每一个人看到这些事物呢？如果你的所有同事，你的所有朋友，你所有相关人员，都处于同一个空间内，能够看到所有的数据和工具，获取共同的感悟呢？</p><p>这不是一个一群人在里面大房间吗？</p><p>如果我们可以看到未来的可视空间，一个小机器人和一两个创作者在一起，想象未来的工作坊是挤满了相关人员，或者全是学生，所有人都希望去理解、评价和贡献，或许你有一个理论来解释工坊的方法和参与式设计是如何扩展到工作的各个方面的。</p><p>设计工坊已经是一个用于描绘和迭代的可视空间：当你呈现和谈论设计时你可以看到内部；你可以看到随着时间的推移每个迭代都建立在前一个迭代之上；你可以看到各种不同的可能性；</p><p>如果可视空间仅仅只是一个工具的话，那么我们只能在原地等待这个世界提供这样的工具。</p><p>但是如果可视空间包含了其他人或者<em>引导性</em>的话，那么我们我们不仅可以从工作空间中实施流程和开发项目，还可以用仪器探索它，把它们从显示器和服务器中拿出来放到桌子上变成有形的艺术品，我们还能够让人们<em>参与</em>进来。</p><p>一个可视空间也可以是非技术层面的，就像一个设计工作室，只要它有 3 种可视化属性。采访和汇报可以可视化内部。可记录和重播的语音和图像、记笔记和分析用来可视化时间。场景规划用来可视化概率。</p><p>可视空间也可以是技术层面的。我们可以用投影仪和笔记本电脑拼凑出针对个别问题的解决方案，就像 Dynamicland 一样创造编程的共享感知。</p><p>Dynamicland 的哪些方面关于编程的，哪些方面是可归纳的具有普适性的？</p><p>从学习将东西从竖直的屏幕转到水平面（共享的工作台）是否已经足够？</p><p>是否满足前面 3 种可视化的属性，或者是否存在其它的核心属性来促进共享感知？</p><p>在你个人的工作中，从何开始做起？</p><p>现在是 2017 年 9 月 12 日。感谢您的关注。</p><h2 id="后续">后续</h2><blockquote><p><em>更新于 2017 年 10 月 1 日</em></p></blockquote><p>感谢所有的评论和转发。</p><p>同样感谢 Atlantic 文章 <a href="https://www.theatlantic.com/technology/archive/2017/09/saving-the-world-from-code/540393/" target="_blank" rel="noopener">《即将到来的软件天启日》</a>中的引用：</p><blockquote><p>但看到他的谈话最终产生的效果，Bret Victor 大失所望。他后来说道“很多人似乎误解了我所说的话”。当人们开始邀请他参加会议讨论编程工具时，他就知道人们误会了他的意思。他说道“每个人都认为我对编程环境感兴趣”。事实上他真正感兴趣的事让人们如何看见和理解系统，正如他提到“动态行为的视觉表示”。</p></blockquote><p>至少我并不孤单！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dynamicland-可视空间和设计工坊&quot;&gt;Dynamicland, 可视空间和设计工坊&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Vitorio Miliano&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 2017 年 9 月 11 日星期一开始 &lt;a hr
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://thinkhard.tech/tags/Blog/"/>
    
      <category term="Translation" scheme="http://thinkhard.tech/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>基于 face_recognition 和 PID 的人脸识别和跟踪</title>
    <link href="http://thinkhard.tech/2019/06/03/camera-pan-tlt-pid-face-tracking/"/>
    <id>http://thinkhard.tech/2019/06/03/camera-pan-tlt-pid-face-tracking/</id>
    <published>2019-06-03T07:42:59.000Z</published>
    <updated>2019-06-03T10:28:22.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-face_recognition-和-pid-的舵机云台人脸识别和跟踪">基于 face_recognition 和 PID 的舵机云台人脸识别和跟踪</h1><p>如何让机器人头部摄像头跟随识别到人脸位置变化而转动？一帧图像是 2 维的，人脸位置用坐标 (x,y) 表示，要实现跟踪人脸则需要两个轴 <strong>pan, tilt</strong></p><ul><li><strong>pan</strong>: 水平左右方向转头</li><li><strong>tilt</strong>: 竖直上下方向转头</li></ul><div style="text-align:center"><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190603155412.png" width="30%"></p><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190603164238.png" width="70%"></p></div><h2 id="人脸识别">人脸识别</h2><p>首先需要在每一帧图像中识别到人脸，<a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">face_recognition</a> 一个简单易用的人脸识别开源项目，并且配备了完整的开发文档和示例代码，还特别兼容了树莓派。face_recognition 基于 C++ 开源库 dlib 的深度学习模型，使用 <a href="http://vis-www.cs.umass.edu/lfw/" target="_blank" rel="noopener">Labeled Faces in the Wild</a> 人脸数据集进行测试，有高达99.38%的准确率。</p><h3 id="安装-face_recognition">安装 face_recognition</h3><p>安装步骤请参考: <a href="https://github.com/ageitgey/face_recognition#installation" target="_blank" rel="noopener">face_recognition#installation</a></p><h3 id="识别人脸-python-代码">识别人脸 Python 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_location</span><span class="params">(frame, frame_center)</span>:</span></span><br><span class="line">    face_locations = face_recognition.face_locations(frame)</span><br><span class="line">    <span class="keyword">if</span> len(face_locations) &gt; <span class="number">0</span>:</span><br><span class="line">        y0, x0, y1, x1 = face_locations[<span class="number">0</span>]</span><br><span class="line">        face_x = int((x0 + x1) / <span class="number">2</span>)</span><br><span class="line">        face_y = int((y0 + y1) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> face_x, face_y</span><br><span class="line">    <span class="keyword">return</span> frame_center</span><br></pre></td></tr></table></figure><h2 id="pid-控制">PID 控制</h2><p>使用 face_recognition 可以很容易地用 Python 代码实现人脸识别，计算出人脸在一帧图像中的像素坐标 <code>(x, y)</code>，接下来就是需要控制舵机对人脸进行跟踪。</p><p><strong>控制目标</strong>：<strong>调整横向和纵向两个自由度的舵机，使得摄像头中的人脸中心与图像的中心重合。</strong></p><p>这就需要引入 PID 控制了，先直接放公式</p><p><span class="math display">\[u(t)=K_{\mathrm{p}} e(t)+K_{\mathrm{i}} \int_{0}^{t} e\left(t^{\prime}\right) d t^{\prime}+K_{\mathrm{d}} \frac{d e(t)}{d t}\]</span></p><ul><li><strong>时间</strong> <span class="math inline">\(t\)</span>，在这里时间是离散的；</li><li><strong>偏差</strong> <span class="math inline">\(e(t)\)</span>，在人脸跟踪中指的是图像中心与人脸中心之间的距离（x 方向，y 方向）；</li><li><strong>系统输出</strong> <span class="math inline">\(u(t)\)</span>，即输出的舵机角度(分水平和垂直方向两个舵机的角度)；</li></ul><p>接下来需要理解，<span class="math inline">\(K_p\)</span>，<span class="math inline">\(K_i\)</span>，<span class="math inline">\(K_d\)</span> 三个参数的作用</p><h3 id="比例p">比例(P)</h3><p>比例控制的输出信号与输入偏差成比例关系。偏差一旦产生，控制器立即产生控制作用以减小偏差，是最基本的控制规律。当仅有比例控制时系统输出存在稳态误差。</p><ul><li>当人脸与图像中心相距<strong>较远</strong>时，需要舵机<strong>大幅度</strong>运动对准人脸</li><li>当人脸与图像中心相距<strong>较近</strong>时，需要舵机<strong>小幅度</strong>靠近对准人脸</li></ul><p>根据 <code>kp</code> 取值不同，摄像头都会去对准人脸，只是 <code>kp</code> 大了到达的快，<code>kp</code> 小了到达的慢一些。</p><h3 id="积分i">积分(I)</h3><p>防止系统进入稳定后存在的稳定误差，即有可能摄像头稳定后停下来了，但是没有对准人脸的中心。为了消除稳态误差，必须引入积分控制。积分作用是对历史的偏差进行积分，随着时间的增加，积分输出会增大，使稳态误差进一步减小，直到偏差为零，才不再继续增加，最后系统稳定下来，才可能正好中心对准人脸。</p><h3 id="微分d">微分(D)</h3><p>在微分控制中，控制器的输出与输入偏差信号的微分(即偏差的变化率)成正比关系。微分控制反映偏差的变化率，只有当偏差随时间变化时，微分控制才会对系统起作用，而对无变化或缓慢变化的对象不起作用。通俗来说，是为了在人脸追踪时，防止<strong>追过劲了</strong>，在中心对准人脸后可以及时地停止，防止震荡。</p><h3 id="pid-代码实现">PID 代码实现</h3><p>在理解概念和公式后，就不难代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.pyimagesearch.com/2019/04/01/pan-tilt-face-tracking-with-a-raspberry-pi-and-opencv/</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PID</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kP=<span class="number">1</span>, kI=<span class="number">0</span>, kD=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="comment"># initialize gains</span></span><br><span class="line">        self.kP = kP</span><br><span class="line">        self.kI = kI</span><br><span class="line">        self.kD = kD</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># intialize the current and previous time</span></span><br><span class="line">        self.currTime = time.time()</span><br><span class="line">        self.prevTime = self.currTime</span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize the previous error</span></span><br><span class="line">        self.prevError = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># initialize the term result variables</span></span><br><span class="line">        self.cP = <span class="number">0</span></span><br><span class="line">        self.cI = <span class="number">0</span></span><br><span class="line">        self.cD = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, error, sleep=<span class="number">0.2</span>)</span>:</span></span><br><span class="line">        <span class="comment"># pause for a bit</span></span><br><span class="line">        time.sleep(sleep)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># grab the current time and calculate delta time</span></span><br><span class="line">        self.currTime = time.time()</span><br><span class="line">        deltaTime = self.currTime - self.prevTime</span><br><span class="line"></span><br><span class="line">        <span class="comment"># delta error</span></span><br><span class="line">        deltaError = error - self.prevError</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proportional term</span></span><br><span class="line">        self.cP = error</span><br><span class="line"></span><br><span class="line">        <span class="comment"># integral term</span></span><br><span class="line">        self.cI += error * deltaTime</span><br><span class="line"></span><br><span class="line">        <span class="comment"># derivative term and prevent divide by zero</span></span><br><span class="line">        self.cD = (deltaError / deltaTime) <span class="keyword">if</span> deltaTime &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># save previous time and error for the next update</span></span><br><span class="line">        self.prevTime = self.currTime</span><br><span class="line">        self.prevError = error</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sum the terms and return</span></span><br><span class="line">        <span class="keyword">return</span> sum([</span><br><span class="line">            self.kP * self.cP,</span><br><span class="line">            self.kI * self.cI,</span><br><span class="line">            self.kD * self.cD])</span><br></pre></td></tr></table></figure><h2 id="代码设计">代码设计</h2><p>由于云台有 2 个自由度（pan, tilt），所以需要用到 2 个 PID 控制器，来输出对应的角度</p><ul><li><span class="math inline">\(x\)</span> 轴偏差 对应 水平左右转动 <strong>pan</strong></li><li><span class="math inline">\(y\)</span> 轴偏差 对应 垂直上下转动 <strong>tilt</strong></li></ul><p>在代码设计时，需要考虑如下几点限制因素</p><ul><li>受限于设备的性能，使用 face_recognition 识别一帧图像里的人脸可能会非常耗时</li><li>舵机控制时，不同的舵机响应时间不同</li><li>PID 在代码中是通过循环累加来计算的；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_face_center</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'face_center ..'</span>)</span><br><span class="line">    process_this_frame = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> QUEUE_IMG.empty():</span><br><span class="line">            frame = QUEUE_IMG.get()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        (h, w) = frame.shape[:<span class="number">2</span>]</span><br><span class="line">        HEAD.center_x = w // <span class="number">2</span></span><br><span class="line">        HEAD.center_y = h // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> process_this_frame &gt; <span class="number">8</span>:</span><br><span class="line">            HEAD.obj_x, HEAD.obj_y = face_location(frame, (HEAD.center_x, HEAD.center_y))</span><br><span class="line">            print(HEAD.obj_x, HEAD.obj_y)</span><br><span class="line">            process_this_frame = <span class="number">0</span></span><br><span class="line">        process_this_frame += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_pid_pan</span><span class="params">()</span>:</span></span><br><span class="line">    p, i, d = <span class="number">0.09</span>, <span class="number">0.08</span>, <span class="number">0.002</span></span><br><span class="line"></span><br><span class="line">    pid = PID(p, i, d)</span><br><span class="line">    pid.initialize()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        error = HEAD.center_x - HEAD.obj_x</span><br><span class="line">        HEAD.pan = pid.update(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_pid_tlt</span><span class="params">()</span>:</span></span><br><span class="line">    p, i, d = <span class="number">0.11</span>, <span class="number">0.10</span>, <span class="number">0.002</span></span><br><span class="line"></span><br><span class="line">    pid = PID(p, i, d)</span><br><span class="line">    pid.initialize()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        error = HEAD.center_y - HEAD.obj_y</span><br><span class="line">        HEAD.tlt = pid.update(error)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_set_servos</span><span class="params">()</span>:</span></span><br><span class="line">    set_head_servo([<span class="number">0</span>, <span class="number">90</span>])</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        pan_angle = HEAD.pan + <span class="number">0</span></span><br><span class="line">        tlt_angle = <span class="number">90</span> - HEAD.tlt</span><br><span class="line">        print(<span class="string">'[pan_angle, tlt_angle] = '</span>, pan_angle, tlt_angle)</span><br><span class="line">        set_head_servo([pan_angle, tlt_angle])</span><br></pre></td></tr></table></figure><p>需要将人脸识别、PID 过程、角度控制放到<strong>单独的线程</strong>处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async_do_job(thread_face_center)</span><br><span class="line">async_do_job(thread_pid_pan)</span><br><span class="line">async_do_job(thread_pid_tlt)</span><br><span class="line">async_do_job(thread_set_servos)</span><br></pre></td></tr></table></figure><h2 id="参考链接">参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8" target="_blank" rel="noopener">Wikipedia: PID 控制器</a></li><li><a href="https://github.com/ageitgey/face_recognition" target="_blank" rel="noopener">The world's simplest facial recognition api for Python and the command line</a></li><li><a href="https://www.pyimagesearch.com/2019/04/01/pan-tilt-face-tracking-with-a-raspberry-pi-and-opencv/" target="_blank" rel="noopener">Pan/tilt face tracking with a Raspberry Pi and OpenCV</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于-face_recognition-和-pid-的舵机云台人脸识别和跟踪&quot;&gt;基于 face_recognition 和 PID 的舵机云台人脸识别和跟踪&lt;/h1&gt;
&lt;p&gt;如何让机器人头部摄像头跟随识别到人脸位置变化而转动？一帧图像是 2 维的，人脸位置用坐标 
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="PID" scheme="http://thinkhard.tech/tags/PID/"/>
    
      <category term="Robot" scheme="http://thinkhard.tech/tags/Robot/"/>
    
  </entry>
  
  <entry>
    <title>用 Docker 部署 Sentry Bug 日志收集服务</title>
    <link href="http://thinkhard.tech/2019/05/25/docker-sentry-deploy/"/>
    <id>http://thinkhard.tech/2019/05/25/docker-sentry-deploy/</id>
    <published>2019-05-25T02:44:27.000Z</published>
    <updated>2019-05-25T10:27:24.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-docker-部署-sentry-bug-日志收集服务">用 Docker 部署 Sentry Bug 日志收集服务</h1><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190525172611.png" width="30%"></div><p>Sentry 是一个日志收集和统计平台, 由客户端和服务端组成，目前支持大部分主流的编程语言，并提供 SDK，当程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个 Web 端显示。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190525172257.png" width="80%"></div><p>下面演示如何使用 Docker 快速部署 Sentry 服务，并自定义一些配置。</p><h2 id="系统环境">系统环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; uname -a</span><br><span class="line">Linux sentry 4.18.0-1018-azure #18~18.04.1-Ubuntu SMP Tue May 7 18:09:35 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h2 id="安装-docker">安装 Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt; sudo apt install docker.io</span><br><span class="line"><span class="meta">&gt;</span>&gt; sudo apt  install docker-compose</span><br><span class="line"><span class="meta">&gt;</span>&gt; docker -v</span><br><span class="line"></span><br><span class="line">Docker version 18.09.2, build 6247962</span><br></pre></td></tr></table></figure><h2 id="部署-docker-服务">部署 Docker 服务</h2><h3 id="clone-代码">Clone 代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt; git clone https://github.com/getsentry/onpremise.git</span><br><span class="line"><span class="meta">&gt;</span>&gt; cd onpremise</span><br></pre></td></tr></table></figure><h3 id="挂载本地路径">挂载本地路径</h3><p>为了方便数据迁移，挂载本地路径到 Docker 镜像</p><ul><li><code>mkdir sentry-data</code>: 创建 Sentry 数据文件目录</li><li><code>mkdir sentry-postgres</code>: 创建 Sentry 数据库目录</li><li><code>config.yml</code>: Sentry 用户自定义配置文件</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190525170352.png" width="60%"></div><h3 id="配置邮箱与域名前缀">配置邮箱与域名前缀</h3><p>这里需要同时改动两个文件，<code>config.yml</code> 和 <code>docker-compose.yml</code></p><h5 id="配置-config.yml">配置 <code>config.yml</code></h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mail.backend:</span> <span class="string">'smtp'</span>  <span class="comment"># Use dummy if you want to disable email entirely</span></span><br><span class="line"><span class="string">mail.host:</span> <span class="string">'smtp.exmail.qq.com'</span></span><br><span class="line"><span class="string">mail.port:</span> <span class="number">587</span></span><br><span class="line"><span class="string">mail.username:</span> <span class="string">'name@email.com'</span></span><br><span class="line"><span class="string">mail.password:</span> <span class="string">'yourpassword'</span></span><br><span class="line"><span class="string">mail.use-tls:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">mail.from:</span> <span class="string">'name@email.com'</span></span><br><span class="line"><span class="string">system.url-prefix:</span> <span class="string">'http://your_domain.com'</span></span><br></pre></td></tr></table></figure><h5 id="配置-docker-compose.yml">配置 <code>docker-compose.yml</code></h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x-defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"><span class="attr">  build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">  depends_on:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">redis</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">postgres</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">memcached</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">smtp</span></span><br><span class="line"><span class="attr">  env_file:</span> <span class="string">.env</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    SENTRY_MEMCACHED_HOST:</span> <span class="string">memcached</span></span><br><span class="line"><span class="attr">    SENTRY_REDIS_HOST:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    SENTRY_POSTGRES_HOST:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">    SENTRY_SERVER_EMAIL:</span> <span class="string">'name@email.com'</span></span><br><span class="line"><span class="attr">    SENTRY_EMAIL_HOST:</span> <span class="string">'smtp.exmail.qq.com'</span></span><br><span class="line"><span class="attr">    SENTRY_EMAIL_PORT:</span> <span class="number">587</span></span><br><span class="line"><span class="attr">    SENTRY_EMAIL_USER:</span> <span class="string">'name@email.com'</span></span><br><span class="line"><span class="attr">    SENTRY_EMAIL_PASSWORD:</span> <span class="string">'yourpassword'</span></span><br><span class="line"><span class="attr">    SENTRY_EMAIL_USE_TLS:</span> <span class="string">'true'</span></span><br><span class="line"><span class="attr">    SENTRY_URL_PREFIX:</span> <span class="string">'http://your_domain.com'</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><p><strong>邮箱端口</strong>： 腾讯企业邮箱的设置 SMTP 的端口是 465，但 sentry 只支持 tls 而，所以使能 <code>tls</code> 并将端口改587。</p></li><li><p>腾讯企业邮箱 <code>mail.from</code> 必须要和 <code>mail.username</code> 一致。</p></li></ul><h3 id="启动-docker-服务">启动 Docker 服务</h3><blockquote><p>参考<a href="https://github.com/getsentry/onpremise/blob/master/README.md" target="_blank" rel="noopener">官方文档</a></p></blockquote><ul><li><code>cp -n .env.example .env</code> 创建环境配置文件</li><li><code>docker-compose build</code> 构建 Docker 服务</li><li><code>docker-compose run --rm web config generate-secret-key</code> 生成密钥，并将密钥添加至 <code>.env</code></li><li><code>docker-compose run --rm web upgrade</code>，构建数据库，过程中需要输入管理员信息</li><li><code>docker-compose up -d</code> 在后台启动，<code>docker-compose.yml</code> 默认端口为 9000</li><li>浏览器打开 <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a>，部署成功。</li></ul><h2 id="作者">作者</h2><ul><li><strong>神奇的战士</strong></li><li><strong>微信公众号</strong></li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190525173043.png" width="30%"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用-docker-部署-sentry-bug-日志收集服务&quot;&gt;用 Docker 部署 Sentry Bug 日志收集服务&lt;/h1&gt;
&lt;div style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;https://raw.githubuserco
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://thinkhard.tech/tags/Docker/"/>
    
      <category term="Sentry" scheme="http://thinkhard.tech/tags/Sentry/"/>
    
  </entry>
  
  <entry>
    <title>在 Scratch3 中玩转机器人:Python、Deep Learning、Posenet and Robot！</title>
    <link href="http://thinkhard.tech/2019/05/23/control-robot-in-scratch3/"/>
    <id>http://thinkhard.tech/2019/05/23/control-robot-in-scratch3/</id>
    <published>2019-05-23T13:21:12.000Z</published>
    <updated>2019-05-24T09:31:28.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-scratch-中玩转机器人pythondeep-learningposenet-and-robot">在 Scratch 中玩转机器人：Python、Deep Learning、Posenet and Robot！</h1><blockquote><p><strong>所有的边界都被打破了</strong> --《Mindstorms》第二版序言</p></blockquote><h2 id="开场视频先打个响指">开场视频：先打个响指</h2><blockquote><p><a href="https://v.qq.com/x/page/g0874rc7rwx.html" target="_blank" rel="noopener">打响指控制机器人</a></p></blockquote><iframe width="640" height="480" src="https://v.qq.com/x/page/g0874rc7rwx.html" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="codelab-scratch3-与-python">Codelab-Scratch3 与 Python</h2><p>Scratch 是一门编程语言，上榜过编程语言 Top 20，实际它是一门<strong>少儿编程语言</strong>(如果你成年了请先不要急着走)。Scratch 基于图形化的编程，通过拖拉搭积木的方式进行编程，整个过程就像是在玩乐高积木，其实 Scratch 项目受到乐高的赞助，乐高与 Scratch 之间可以说是互相影响。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524155347.png" width="15%"></div><p>一个正经的程序员，在看到 Scratch 的卡通界面和图形化编程风格时，可能会嗤之以鼻，认为它看上去<strong>不像是严肃的编程语言，低龄化或者太简单了</strong>。刚开始我对 Scratch 的认知亦是如此。</p><p><span class="citation" data-cites="wwj718">[@wwj718]</span>(https://github.com/wwj718) 在 Scratch3 上做了<a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">大量出色的工作</a>，Scratch3 原本不支持运行 Python，利用 Scratch3 原生的插件拓展机制，采用 Websocket 来传递消息，这就像一个间谍，负责 Scratch 内部与外部的通信。消息源源不断地以话题/订阅的方式在网络中传播，这就让 Scratch 不再受限于浏览器网页中。我终于意识到，Scratch 可以做任何事！</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524143948.png" width="100%"></div><p>从上图看出，整个系统可以看做是三个部分：</p><ul><li>Scratch3：负责 Block 代码生成与运行，通过 websocket 传输消息；</li><li><a href="https://codelab-adapter-docs.codelab.club/user_guide/install/" target="_blank" rel="noopener">Codelab-Adapter</a>：响应 Scratch 消息，Python 插件管理；</li><li>Python 插件集合：负责连接万物！</li></ul><p>按照这样的设计，Scratch 获得了 Python 的能力，可以将 Python 丰富的生态和库统统接入 Scratch，比如 TensorFlow、ML、DL，甚至可以是树莓派、灯泡、门锁、空调、机器人、游戏 ...</p><p>Bret Victor 在《Kill Math》中说道 &gt; 理解并预测量化世界的能力不应该只属于那些能够熟练运用抽象数学符号的人。</p><p><strong>而现在编程的能力也不应该只掌握在程序员的手上，在 Codelab-Scratch 中，用户可以快速和轻松地使用这些能力。</strong></p><p><em>为了向你证明这一切，下面是我在 Scratch3 中做的一个演示</em></p><h2 id="人体姿态估计posenet">人体姿态估计：Posenet</h2><p>Javascript 版 PoseNet 是 TensorFlow 与谷歌创意实验室合作一款机器学习模型，可以在浏览器中实时估计人体姿态。只要电脑或手机有摄像头，就可以直接在网页浏览器中体验这一有趣的技术。Scratch3 也是纯网页端的，所以将 PoseNet 做成插件的话，Scratch 积木块就具有视觉的能力！</p><div style="text-align:center"><img src="https://user-images.githubusercontent.com/20924010/58311109-d0ee6c80-7e3a-11e9-8796-ace3d79395ac.gif" width="60%"></div><p>针对 PoseNet，<span class="citation" data-cites="wwj718">@wwj718</span> 已经在 <a href="https://scratch3.codelab.club/" target="_blank" rel="noopener">Codelab-Scratch3</a> 中接入了，智能硬件接口开放的话，接入 Scratch 中，就可以让原本功能单一的产品很容易地获得视觉能力。我相信这就是为我今天的演示所准备的，做一个 Scratch 版本的机甲猎人!</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524110431.png" width="50%"></div><div style="text-align:center"><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524101506.png" width="30%"> <img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524101543.png" width="20%"></p></div><h2 id="如何接入机器人到-scratch3">如何接入机器人到 Scratch3</h2><p>首先硬件设备需要有开放的接口，比如开放的蓝牙协议、串口协议或者 Wi-Fi 协议等，Python 有非常成熟的库可以对这些接口进行调用(不开放也没关系，可以 Hack)。</p><p>我已提交相关机器人 Adapter 插件，感兴趣的可以参考我的 PR</p><ul><li><a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/pull/13" target="_blank" rel="noopener">codelab_adapter_extensions/pull/13</a></li><li><a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/pull/14" target="_blank" rel="noopener">codelab_adapter_extensions/pull/14</a></li></ul><h2 id="手势控制演示">手势控制演示</h2><p>手势控制机器人前后左右翻滚</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524160540.png" width="40%"></div><blockquote><p><a href="https://v.qq.com/x/page/q087453zq2i.html" target="_blank" rel="noopener">翻跟斗演示视频</a></p></blockquote><iframe width="640" height="480" src="https://v.qq.com/x/page/q087453zq2i.html" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="姿态模仿演示">姿态模仿演示</h2><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190524160656.png" width="50%"></div><p>下面是姿态模仿演示，请大家忽略我羞耻又沙雕的动作，和不协调的肢体。</p><blockquote><p><a href="https://v.qq.com/x/page/k0874r1m246.html" target="_blank" rel="noopener">姿态模仿演示视频</a></p></blockquote><iframe width="640" height="480" src="https://v.qq.com/x/page/k0874r1m246.html" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="最后">最后</h2><p>如果你也对这一块感兴趣，欢迎加入社区一起折腾。</p><h2 id="相关链接">相关链接</h2><ul><li><a href="https://thinkhard.tech/2019/05/16/Kill-Math/">Kill-Math</a></li><li><a href="http://www.lejurobot.com/aelos-edu/" target="_blank" rel="noopener">Aelos Edu</a></li><li><a href="https://scratch3.codelab.club/" target="_blank" rel="noopener">scratch3.codelab</a></li><li><a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">codelab-adapter-docs</a></li><li><a href="https://github.com/tensorflow/tfjs-models/tree/master/posenet" target="_blank" rel="noopener">Pose Detection in the Browser</a></li><li><a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/pull/13" target="_blank" rel="noopener">codelab_adapter_extensions/pull/13</a></li><li><a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/pull/14" target="_blank" rel="noopener">codelab_adapter_extensions/pull/14</a></li></ul><h2 id="鸣谢">鸣谢</h2><ul><li><span class="citation" data-cites="jinbo">@jinbo</span> 的 OSMO；</li><li><span class="citation" data-cites="yucong">@yucong</span> 的手抖式拍摄；</li><li><span class="citation" data-cites="jianhong">@jianhong</span> 的专业动作调试；</li><li><span class="citation" data-cites="dongming">@dongming</span> 的无线 Dongle；</li><li><span class="citation" data-cites="carlos">@carlos</span> 的响指；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在-scratch-中玩转机器人pythondeep-learningposenet-and-robot&quot;&gt;在 Scratch 中玩转机器人：Python、Deep Learning、Posenet and Robot！&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Scratch3" scheme="http://thinkhard.tech/tags/Scratch3/"/>
    
      <category term="Posenet" scheme="http://thinkhard.tech/tags/Posenet/"/>
    
  </entry>
  
  <entry>
    <title>【译】Kill Math(Bret Victor)：让数学不只是符号</title>
    <link href="http://thinkhard.tech/2019/05/16/Kill-Math/"/>
    <id>http://thinkhard.tech/2019/05/16/Kill-Math/</id>
    <published>2019-05-16T12:51:18.000Z</published>
    <updated>2019-05-16T13:11:24.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Author: Bret Victor / April 11, 2011</p></blockquote><blockquote><p>Translator: <a href="https://github.com/wangshub" target="_blank" rel="noopener">神奇的战士</a></p></blockquote><p>Bret Victor 是苹果公司的前 IPAD 的交互设计师, 大神级的人物。他的理想是：改造我们的低幼化社会。为人们提供工具，用以抵抗和摧毁消费主义文化以及大企业对工作、娱乐和创造力的寡头控制。将权力、尊严和责任感还给个人。Bret 有很多惊艳的作品，感兴趣的同学可以在 Youtube 上搜一下。这篇文章中 Bret 认为大多数人应该用直觉去感知和理解数学符号，而不是靠符号演算。下面是正文：</p><hr><div style="text-align:center"><img src="kill-math.png" width="80%"></div><p><strong>理解并预测量化世界的能力不应该只属于那些能够熟练运用抽象数学符号的人。</strong></p><p>当大多数人谈及数学的时候，脑袋里想的更多是数学的机理而不是思考数学的本质。赋予符号含义、按照神秘的法则的变换和根据变换来解释意义组成了这种所谓的“数学”。整个过程就像是在抓阄一样。</p><p>如此的数学机制发展起来是有原因的：这是在纸和笔的限制下构建的最有效的数学系统。但是很遗憾的是，大多数的人们并不习惯将含义和数学抽象符号联系到一起并且很熟练地使用它们。所以除了算术，数学的力量只是掌握在少数的科学家和工程师的手上（虽然嘴上不说，但是他们中的大多数也是饱受抽象符号的煎熬）。</p><p>现在我们将不再受限于纸和笔。抽象的符号变换不应该再是理解数学的唯一手段了。数学需要有新的形象。</p><h2 id="项目">项目</h2><p>Kill Math 是一个综合的工程项目，目标是帮助人们通过更具体的表现以及更符合直觉的形式来探索和解决一些有意义的量化问题。长远的目标则是希望能够建立一套不同于现有的符号数学体系的可广泛使用并自动呈现的可视化数学表示方法。</p><p>在未来的某一天，在这篇博客内可能会有一篇介绍的文章，让你感动到流泪。但是这篇文章还没写，因为它需要大量的思考和演示示例，在此之前我需要深刻地理解我正在努力做的工作。</p><p>下面是我目前已经完成的部分：</p><ul><li><p><a href="http://worrydream.com/MediaForThinkingTheUnthinkable" target="_blank" rel="noopener">通过媒介来思考原本不可思考的</a> 是一系列交互式的用于设计和理解系统的演示，并且整合了下面列出的很多工作。</p></li><li><p><a href="http://worrydream.com/ScrubbingCalculator" target="_blank" rel="noopener">擦写计算器</a> 演示了在不使用符号变量的情况下解决实际的代数问题。不是求解 x 和 y，而是通过交互的方式调整变量。</p></li><li><p><a href="http://vimeo.com/23839605/" target="_blank" rel="noopener">动态系统的互动探索</a> 演示了一个控制微分方程的工具，其中的每一个变量都用图表显示，每个参数都有一个旋钮，可以实时地进行调整。这套工具可以帮助用户了解参数是如何影响整个系统行为的。</p></li><li><p><a href="http://worrydream.com/LadderOfAbstraction" target="_blank" rel="noopener">如何运用抽象</a>是一篇可交互的博客，使用系统可视化来帮助设计和理解一个系统。</p></li><li><p><a href="http://worrydream.com/SimulationAsAPracticalTool/" target="_blank" rel="noopener">将模拟作为一种实用工具</a> 是这篇文章的早期形态，这个项目主要是为了验证想法。</p></li><li><p><strong>下面</strong>是一系列关于这个数学主题的博客漫谈，我希望吸引更多志同道合的人，而不是为了说服那些持怀疑态度的人。(在怀疑论者看到更多的例子之前，他们可能会拒绝被说服。)</p></li></ul><p>我计划在不同的应用领域和数学领域收集一些有意义的问题，按照这里的哲学针对每一个问题，设计出一种解决方案，将此解决方案与传统解决方案进行比较。我希望在这个过程中出现的一些技术和设计模式可以为将来一般性的的框架提供参考。</p><p>跟往常一样，如果你在用类似的方式思考和工作，我很想看看你想出了什么有意思的点。</p><p>一些附加的想法发表在 <a href="http://www.fastcodesign.com/1664508/could-this-ipad-interface-help-kill-math" target="_blank" rel="noopener">Fast Company 杂志的这篇文章里</a></p><h2 id="杂记">杂记</h2><h3 id="语言与内在解释-1">语言与内在解释 (1)</h3><p>理解和预测数是一种相当强大的力量。目前，这种能力掌握在极少数能够熟练运用数学抽象符号的人手中。</p><p>相比之下，考虑识字能力。从一个不在同一地点或时间的人那里接收思想的能力同样是一种巨大的力量。识字率上升带来的巨大社会影响也是众所周知的。</p><p>语言素养比数学素养更加普及。几乎所有“受过教育”的人都能阅读，大多数人甚至可以在某种程度上写作。但是大多数受过教育的人除了算术之外没有掌握什么有用的数学技能。</p><p>写作和数学都是基于符号表示的系统。但我认为语言更加自然，因为语言的符号直接映射到单词或音素上，这是人类与生俱来的能力。我想，阅读和听别人说话或看手语有着相同的心理机制。</p><p>我不认为每个人在处理数学符号上有着相同的天赋【注1】。相反，我们倾向于阐释隐含的物理含义，这两种隐喻都适用于使用抽象符号的机制（例如，“移动”一个因子到等式的另一边，“消除”两个因子，等等）和符号的语义解释（例如，指数“上升”，或者公式的可忽略项）。在一定程度上，一个人的数学能力和感受这些物理隐喻的符号紧密相连，从而使抽象的更具体。</p><blockquote><p>【注1】: 西蒙·佩伯特可能不会同意这样的观点，他认为对于在 “Mathland” (一个沉浸式的数学互动环境) 中长大的孩子看来，使用数学就像是在法国说法语一样，可以熟练地使用抽象的数学符号。我可能反驳说，在南极长大的孩子可能会更抗冻，或许人们并不需要这种抗冻能力。</p></blockquote><p>我相信这两种精神上的扭曲都是在纸笔技术下的产物。一个人不应该手动地去变换符号和数学推导。因为这些工作最好完全由软件自动完成，或者像玩滑动拼图游戏一样，有一个可交互的带引导的软件。可能更具争议的是，我认为<strong>一个人不必去理解抽象符号的含义</strong>。相反地，动态图、图表、可视化模型和视觉特效就可以阐释事物本质。比如数值之间的关系、指数上升和公式的可忽略项应该被直观地用眼睛看到，而不是单纯地靠脑海想象。</p><h3 id="语言与内在解释-2">语言与内在解释 (2)</h3><p>人类是为语言而生的 -- 我们是处理符号的机器 -- 所以我不能说“符号的坏话”。我感觉有一些东西需要亲眼所见或者亲身体会才能够真正的理解与融会贯通。并且一些东西是可以很容易地绘制或者制作，对于那些缺少使用晦涩难懂的专业语言的经验的人来说，这很难用符号表述。</p><p>我认为数量和度量就属于这个范畴。例如长度 <code>1m</code> 和 <code>1mm</code> 的符号表示与直接观察这两种长度相比 -- 前者只是一页纸上的数字，而后者可以让你直观地感受。你觉得大多数人能够从符号上，感受和理解 <code>$1B</code> 和 <code>$1T</code> 财政救助款之间的区别吗？事实上它俩之间差了整整 3 个数量级。</p><p>你需要使用本能的直觉去理解一个问题。一个优秀的电路设计师能够<strong>感知</strong>到一个电路是如何运作的。当他们看着电路原理图的时候，就能感受到电压的脉动，就好像看着跷跷板或者水泵运作一般。然而这需要多年的经验来形成这种当你看着符号的时候就能理解符号含义的直觉。</p><p>同样地，人们以前认为去阅读和理解巨大的数字表格是处理数据的基本技能。但是威廉·普莱费尔发明了线形图，突然间所有人都可以<strong>通过平凡的眼睛来直观地感受数据</strong>。</p><p>复数提供了一个很好的例子。在许多科学领域，理解抽象的复数是一项基本技能。然后 David Hestenes 站出来说：“嘿，你知道复数、四元数、泡利矩阵和其他抽象有趣的东西吗？如果你用过克利福德代数的话，所有的这些东西都有几何表示，并且你可以实际地体会和品味到它们。”用你愚笨的嘴去品味复数！事实上没有人相信他，但是我相信。</p><p>我们的工具的目的就是使那些无法企及的抽象事物让普通人也能理解，将它们转换成我们能够感受到的形态。显微镜能够让我们的眼睛看到微小的事物。镊子能够让我们笨拙的手指夹起细微的颗粒。计算器能够让我们愚笨的大脑完成复杂的计算。所以我想有那么一个工具可以让我们普通的大脑看见和体会复杂的情景。</p><h3 id="厨房里的数学">厨房里的数学</h3><p>在 <a href="https://www.amazon.com/dp/0465010636" target="_blank" rel="noopener">《儿童的机器》</a> 这本书中，西蒙·佩伯特介绍了“厨房里的数学”。一道菜需要给 3 个人吃，但是厨师只做了 2 份菜，所以她需要将原材料的均分 2/3。一道菜需要 3/4 杯面粉。厨师量出 3/4 杯面粉，在柜台上摊开成一个圈，从圈里拿出1/3块，放回袋子里。这就是 2/3 和 3/4。</p><p>有些人显得很慌张因为他不会使用分数，但是我发现了一个有趣的解决方案。因为分数<strong>是具体的、可见的、有形的和直接的</strong>。<em>传统的方法就是分子分母上下同时约掉 3，但是这没有任何的物理意义</em>。</p><p>我想要创造出一个环境来增强厨房里的数学。</p><h3 id="数学的艺术">数学的艺术</h3><p>这个项目没有处于自身观点考虑来攻击应用数学。我不介意数学娱乐化或者艺术化。我一直出于个人兴趣在学习数学；我始终在以数学为乐。我对<a href="http://worrydream.com/refs/Lockhart-MathematiciansLament.pdf" target="_blank" rel="noopener">洛克哈特的悲歌</a>产生了强烈的共鸣，并且我很喜欢 <a href="http://vihart.com/" target="_blank" rel="noopener">Vi Hart</a> 和 <a href="http://www.cadaeic.net/" target="_blank" rel="noopener">Mike Keith</a> 等人所做的工作。在模式和规则中隐藏着美感；但是发现这种美是有挑战的。我可能会因为盲目的传统和缺乏想象力的原因，迫使我使用古老的传统方式来完成这样的艺术形式。</p><p>以武术为例，这是另一种根据实际需要而发展出来的艺术形式。就像数学一样，人们练习武术可能是以为了身体或精神上的锻炼，为了挑战和掌握一项技能，为了它的优雅和美丽，或者作为一种社交活动为目的。与数学不同的是，我们意识到武术的精神已经发生了改变，因为随着技术的进步产生了更多教训人的方式。</p><p>（与数学不同的是，我们不会强迫地球上的每一个孩子上 12 年的课，那些在艺术方面不擅长的孩子也不会感到羞耻和低人一等。）</p><h3 id="可能令人尴尬的个人往事">可能令人尴尬的个人往事</h3><p>当我读高中的时候，我每周会去几次当地的大学学习微分方程。有一天，老师解完一个二阶方程式：</p><div style="text-align:center"><img src="2nd_order_eqution.png" width="40%"></div><p>他很随意地提出了一个问题：“你为什么认为这个解有两个任意常数？”</p><p>对这个问题我感到很疑惑，我认为答案本该如此呀。我能看出解有两个自由度，我能理解到这个程度，但是我从来没想到还有更深层次的原因。</p><p>老师然后说道，“因为你积分了两次”。然后他就开始继续讲其他的东西了，但是我小脑袋里已经满满都是问号。</p><p>我从来没有想过通过积分来求解微分方程。因为它看起来并不像积分。我知道积分是什么样的 -- 积分就是把东西都累加起来，就像往水槽里加水一样。</p><div style="text-align:center"><img src="integral_demonstration.gif" width="60%"></div><p>并且我知道方程直观感受起来是什么样的 -- 它就像天平，慢慢地摆动越来越小，最后停了下来。</p><div style="text-align:center"><img src="equation_demonstration.gif" width="60%"></div><p>后来我上了大学，从学校毕业后，开始了工程师的职业生涯，我没有被要求解上百上千个的微分方程。我理解了微分和积分在形式上的关联，但是我不知道我是否可以直觉感受到它。</p><p>后来有一天，我无意中读到斯托加茨的书 <a href="http://www.amazon.com/dp/0738204536" target="_blank" rel="noopener">《Nonlinear Dynamics and Chaos》</a>。在书中他问道，如何求解下列的微分方程：</p><div style="text-align:center"><img src="differential_equation.png" width="30%"></div><p>随后他说，你不要这么做。它是非线性的。我们单单变换公式的方法不管用了。你需要把二阶的方程分解成两个一阶微分的方程式。</p><div style="text-align:center"><img src="first_order_equations.png" width="30%"></div><p>画出相位空间的轨迹图，然后你就能直观地感受到整个系统的运作方式。</p><div style="text-align:center"><img src="phase_trajectory.gif" width="60%"></div><p>在轨迹的每一点上，鼠标在水平和垂直方向都被微分推进了一点点，整合起来就像 LOGO 语言的小海龟在相位空间运动一样。</p><p>为什么我整个职业生涯都在整合一个我们看不见的东西呢？对我而言，<strong>如果不在相位空间理解微分方程就像是没听过一首歌却要做音乐鉴赏一样</strong>。</p><p>回想多年前我的老师提出来的问题：“为什么解是两个任意常数？”答案就很显然了：你必须选择轨迹得起始点，两个常量就像是小海龟做积分时的坐标 x 和 y 一样。我很多年以前就解决了“初值问题”，我却从来没有切身体会过这个初值。</p><h3 id="教育和命令行">教育和命令行</h3><p>当这些笔记第一次发表的时候，我收到了很多读者的反馈。但是大多数的反馈都是以为为我想要变革 <em>数学教育</em>。有一个部分我简短切题地说道这个项目不是关于教育的，其他地方我没有提到过教育。</p><p>我发现这很令人费解。如果我提出一种新的驾驶汽车的方式（比如，我说方向盘这东西已经过时了，应该被替换为 Wii 游戏手柄），应该不会有人认为这是谈论 <em>汽车司机教育</em> 吧。甚至没有人会提到教育二字。他们可能会思考这是否是一种开车的好方法。</p><p>但是当说道一种新的理解数学的方式时，人们总是开始联想到教室和课程。</p><p>有一点尤其奇怪，当今解决实际生活中的数学问题总好的工具竟然是是电子表格。如果我需要一个新的形式的电子表格，同样，没有人会说这是关于教育的。</p><p>（这种对教育领域的重新定位也发生在对一个<a href="http://vimeo.com/23839605/" target="_blank" rel="noopener">动态系统的交互探索的演示</a>中。肯定我本可以做得更好的：“这是一个原型工具，工程师和科学家可以对他们正在进行工程和科学系统进行建模和探索”。但是我认为这更加贴切这个工具的本意而不是仅仅“可视化 Lotka-Volterra 方程”。大多数的读者都想要像 <a href="http://demonstrations.wolfram.com/" target="_blank" rel="noopener">Wolfram 那样的演示</a>，对某个具体的数学问题进行可视化。这种感觉就像，我展示了一个全新的漂亮的不粘锅，后来每个人都上来问我要一盘美味的炒蛋。）</p><p>如果让我猜测为什么“数学改革”被误解为“数学教育改革”？我推断大多数人可能只在学校里和数学打交道。就像校园物理或者校园化学一样，数学被视为一门课来教授，而不是强调它是一种工具。人们在算术之外并没有在实际生活中使用数学，就好像不使用平方反比定律或者周期表一样。</p><p>这就是这个项目出发的前提 -- 大多数人们没有使用数学。但是如果数学被以一种更好的方式教学的话，人们可能会把数学用得更好！我（包括整个项目）的立场是：<strong>不</strong>。教学目前你想要的数学抽象符号和方法 -- 他们将仍然没有作用。使用糟糕的用户界面的教学方式仍然是没有用 -- 因为没有展示出用户需要看到的东西，不符合用户大脑里所想的内容，没有呈现出用户可以采取的操作。</p><p>对于大多数人来说 UNIX 命令行仍然是没有用的。有很多方法可以让普通大众使用计算机的强大之处，而不必教会每个人都去使用命令行。有一个很好的方法就是 -- 设计更好的用户界面，更多易访问的应用程序，更高级的抽象。直接形象地和真实地表现事物。</p><p>所以<strong>当今的数学就像是命令行</strong>，我们需要更好的用户界面。</p><h3 id="别人说过的观点">别人说过的观点</h3><blockquote><p>奥利弗·斯蒂尔: 邮件</p></blockquote><p>所有的不具体的抽象事物都是很难去想象的...我认为数学家是那些可以成功地弄清楚如何具体地思考抽象事物的人，所以抽象就不再抽象。我相信数学思维包括学习具体地思考抽象事物的能力，通常使用多种表示法 -- 如何将更多的事情视为“事情”的一部分。所以与其说避免抽象，更重要的是接纳抽象并且将抽象具体化...具体化抽象事物的一种方法是在旁边放一个已经具体化的实例。</p><blockquote><p>大卫·赫斯顿斯和盖瑞特·索布奇克: <a href="http://www.amazon.com/dp/9027725616" target="_blank" rel="noopener">《克利福德代数到几何微积分：统一的数学语言》</a></p></blockquote><p>克莱恩对数学结构和历史的开创性研究揭示了数学发展和分支的两个主要过程...一种强调代数结构，另一种强调几何解释。克莱恩的分析表明，在数学的历史发展过程中，一个过程交替地支配着另一个过程。但这两个过程不应相互排斥。毫无疑问事实上每一个过程都是建立在人类思维的两大能力之一上的：<strong>语言能力和空间感知能力</strong>。从心理学的角度来看，代数与几何的融合是非常基本的所以我们可以说：<strong>没有代数的几何是愚蠢的！没有几何的代数是盲目的！</strong>，</p><blockquote><p>大卫·赫斯顿斯: <a href="http://geocalc.clas.asu.edu/pdf/OerstedMedalLecture.pdf" target="_blank" rel="noopener">《改变物理的数学语言》</a></p></blockquote><p>在物理课程中，数学被认为是理所当然的 -- 这是一成不变的真理。数学对我们的物理世界的深刻影响却从未被认真分析过。今天使用的数学工具是在过去被发明出来解决旧的问题，但是很有可能不太适合今天新的问题...</p><p>我们不必深入研究物理学的历史来证明数学对物理的深远影响。因为有两个著名的例子足以说明这一点：解析几何和微积分的发明是牛顿创立经典力学的基础，张量分析的发明对爱因斯坦创立广义相对论至关重要...</p><p>我想通过引用这两个例子来说明的一点是，如果没有基本的数学概念，这两个物理理论实际上是不可想象的。我们使用的数学建模工具曾经扩展但也限制了我们认知世界的能力。数学的局限性在于，那些为经典力学和解析几何学提供的数学支撑的理论方法已经不适用于广义的相对理论了。当今在物理学使用的数学工具可能在概念上就存在局限性。</p><blockquote><p>艾伦·凯：<a href="http://www.archive.org/details/AlanKeyD1987" target="_blank" rel="noopener">《用图像制造符号》</a></p></blockquote><p>法国著名数学家雅克·阿达玛在他晚年时决定投票选出他的 99 个同伴，作为地球上 100 位最伟大的数学家和物理学家，雅克问他们：“你们的工作怎么样？”。他们都是私交，所以纷纷回信。只有一百人中的几个人声称他们使用数学符号。这着实令人惊讶。他们中的大多数人以意象或比喻的方式来理解数学。有 30% 的人包括爱因斯坦都是这样。爱因斯坦说道，“我对数学有肢体一般的感受。”爱因斯坦就像感知自己的手臂和手指一样去感受抽象的空间。</p><p>[做某事 &gt; 图像 &gt; 符号]中令人难过的部分就是，美国的所有孩子都在以符号的方式去学习数学和物理。但没有一个有创造性的数学家或者物理学家在以这种方式学习...他们使用符号的方式交流，但是实际研究的时候就不是这样。太多的教育是建立在这种规则之上了，仅仅是因为我们以谈话的方式来交流，但是这并不意味着只靠说和听去教学。</p><blockquote><p>威廉·瑟斯顿：<a href="http://arxiv.org/pdf/math/9404236v1" target="_blank" rel="noopener">《论数学的证明和发展》</a></p></blockquote><p>当有一个重要的理论被证明的时候，通常该解法可以很快地在相关子领域内传播。这个证明如果是通过沟通交流的话可以在一小时之内就被该子领域的其他研究人员理解。但是如果写成 15 或 20 多页的论文，人们可能需要好几个小时甚至好几天才能够理解掌握。</p><p>为什么非正式的讨论和直接磕论文之间有这么大的区别呢？当一对一沟通的时候，人们除了数学语言还可以用很多其他的方式来交流。他们可以用手势、画图表、用肢体语言发出声响这些方式交流。沟通在这里就是双向的，人们可以专注于他们最关心的点上。以面对面的沟通方式，就可以更好地传达正在发生的事情，不仅在逻辑和语言方面，而且在其他心理层面。</p><p>在会谈中，人们变得更加拘谨和正式。数学的受众通常不善于提出大多数心中所关注的问题，而演讲汇报的人通常准备了一个不切实际的大纲，即使他们被问到问题，也会回避相关的回答。</p><p>在论文中，人们会仍然会比较正式。写作者将他们的想法翻译成符号和逻辑表达，读者努力地要将它们翻译回来。</p><blockquote><p>理查德·汉明：<a href="http://www.lecb.ncifcrf.gov/~toms/Hamming.unreasonable.html" target="_blank" rel="noopener">《数学的不合理有效性》</a></p></blockquote><p>有必要强调一点，数学的前提假设不是摩西从西奈山上取下来的石板。一开始我们头脑中有了一个模糊的概念，然后我们各种各样的假设集合，最终慢慢地收敛成一个特定的集合。在严格的假设方法中，原始模糊的的概念会被后来假设所定义的内容代替。这就使得很难有概念上的发展，进而减缓了数学的发展。并不是说假设的方法是错误的，只是应该清楚认识到它的任意性，注意当结论慢慢变得清晰时我们应该准备改变假设。</p><blockquote><p>理查德·汉明：<a href="http://www.amazon.com/dp/B000P2XFPA" target="_blank" rel="noopener">《科学与工程的艺术》</a></p></blockquote><p>当数字滤波器首次出现时，它们仅仅被视为经典模拟滤波器的一个变种；人们不认为它本质上有什么新意或者不同。这就和早期人们对计算机的认知错误一样。多次有人跟我说，计算机只是一个大型的计算的台式计算器，后来我都厌倦了这种说法。他们说，“任何机器能做的事，人工也能办到”。但是这种观点的人忽视了机器与人工相比，在速度、精度、可靠性和低成本上具有巨大的优势。一般来说，一个数量级的变化（10 倍）将会产生本质上的影响，更不用说计算机比人工计算快了许多许多倍了。那些声称没有本质区别的人从未对计算机的发展做出过任何重大贡献...</p><p>这是一个常见的、无休止的错误；人们总是想认为新事物就要像过去的东西一样 -- 他们习惯于处在大脑的舒适圈 -- 因此他们抗拒对眼下正在发生的新领域新事物做出任何大的贡献。</p><blockquote><p>史蒂文·斯托加茨: <a href="http://www.amazon.com/dp/0738204536" target="_blank" rel="noopener">《非线性动力学与混沌理论》</a></p></blockquote><div style="text-align:center"><img src="a_geometric_way_of_thinking.png" width="60%"></div><hr><p>感谢你能够看到这里，我们在此相遇。这篇文章是我在 codelab-mindstorms 项目里提交的一篇译文。如 @<a href="https://github.com/wwj718" target="_blank" rel="noopener">wwj718</a> 提到的，在编程教育领域有很多“编程提高逻辑思维的”陈词滥调，其实这个在这个领域有一群杰出的先驱做了大量的工作，但是这些却渐渐被世人遗忘。</p><p>如果你也感兴趣的话欢迎一起来 Github 社区翻译和解读编程教育领域优秀的先驱所做的工作。在这个过程中如果你不会操作 Github 或者提交代码，请让我来帮助你 rocksong.hit@gmail.com 。</p><p><strong>项目地址</strong>: <a href="https://github.com/Scratch3Lab/codelab-mindstorms" target="_blank" rel="noopener">Scratch3Lab/codelab-mindstorms</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Author: Bret Victor / April 11, 2011&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Translator: &lt;a href=&quot;https://github.com/wangshub&quot; tar
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://thinkhard.tech/tags/Blog/"/>
    
      <category term="Translation" scheme="http://thinkhard.tech/tags/Translation/"/>
    
      <category term="Math" scheme="http://thinkhard.tech/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>当遇到 Scratch3-Codelab，Pando 觉醒了！</title>
    <link href="http://thinkhard.tech/2019/04/17/codelab-pando-tutorial/"/>
    <id>http://thinkhard.tech/2019/04/17/codelab-pando-tutorial/</id>
    <published>2019-04-17T07:17:02.000Z</published>
    <updated>2019-04-17T13:42:59.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="当遇到-scratch3-codelabpando-觉醒了">当遇到 Scratch3-Codelab，Pando 觉醒了！</h1><blockquote><p>Explore Amazing Moment With Pando</p></blockquote><p><a href="http://www.lejurobot.com/pandocn/" target="_blank" rel="noopener">Pando</a> 是由<a href="http://www.lejurobot.com/" target="_blank" rel="noopener">乐聚机器人</a>研发，可以进行情感互动的益智编程机器人。<strong>主要功能包括</strong>情感交互、手势控制、自主避障、积木编程、动作编程、任务挑战、拟人步态等功能。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417164248.png" width="80%"></div><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417164221.png" width="80%"></div><blockquote><p>图片来源：<a href="http://www.lejurobot.com/" target="_blank" rel="noopener">lejurobot.com</a></p></blockquote><h2 id="scratch3-codelab"><a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">Scratch3-Codelab</a></h2><p>Scratch3-Codelab 是 <a href="https://github.com/wwj718" target="_blank" rel="noopener">wwj718</a> 在 Scratch3 的基础上，集成 EIM (Everything is Message)插件，配合 <a href="https://github.com/Scratch3Lab/codelab_adapter_extensions" target="_blank" rel="noopener">codelab_adapter</a>，就可以让 Scratch3 可以执行 Python 代码，这就赋予了 Scratch3 几乎无限的可能性。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417163658.png" width="80%"></div><h2 id="系统框图">系统框图</h2><p>如果可以运行 Python 代码，那么理论上就能把任何智能硬件都接入 Scratch3 当中，而且模块和插件越多，Scratch3 的玩法就越千变万化！</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417182113.png" width="60%"></div><blockquote><p>图片来源: <a href="https://techziffy.com/self-reconfiguring-modular-robot-market-set-explosive-growth-2026/2234/" target="_blank" rel="noopener">techziffy.com</a></p></blockquote><p>作为一个少儿编程产品，孩子们的想象力其实是远远超过成年的工程师的，如果做到尽可能的开放，让他们去创造和探索机器人的功能，这将是一件非常有意思的事情。</p><p>非常有幸邀请文杰来公司一起交流畅谈，被 CodeLab <strong>万物积木化</strong> 的想法深深吸引，第二天花了一些时间，参照 <a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">Codelab-adapter</a> 文档，为 <a href="http://www.lejurobot.com/pandocn/" target="_blank" rel="noopener">Pando</a> 写了 Codelab 插件 <a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/pull/8" target="_blank" rel="noopener">Pando Robot Extension</a> ，成功接入 Pando 到 Scratch3 当中。下面是系统框图：</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417172843.png" width="80%"></div><h2 id="视频演示">视频演示</h2><ul><li><strong>YouTube:</strong> <a href="https://www.youtube.com/watch?v=rwj1etkWIl0&amp;feature=youtu.be" target="_blank" rel="noopener">在 Codelab 中控制 Pando 机器人 By 神奇的战士</a></li></ul><iframe width="640" height="480" src="https://www.youtube.com/embed/rwj1etkWIl0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><ul><li><strong>Bilibili</strong>: <a href="https://www.bilibili.com/video/av49627582/" target="_blank" rel="noopener">在 Codelab 中控制 Pando 机器人 By 神奇的战士</a></li></ul><iframe width="640" height="480" src="//player.bilibili.com/player.html?aid=49627582&amp;cid=86893839&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><h2 id="软件使用">软件使用</h2><h3 id="macoslinux">MacOS/Linux</h3><ul><li><a href="https://codelab-adapter-docs.codelab.club/user_guide/install/" target="_blank" rel="noopener">安装 codelab-adapter 和使用说明</a></li><li>插件安装<ul><li>Pando 插件 <a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/blob/master/extension_leju_pando.py" target="_blank" rel="noopener">extension_leju_pando.py</a></li><li>蓝牙服务端 <a href="https://github.com/Scratch3Lab/codelab_adapter_extensions/blob/master/servers/pando_server.py" target="_blank" rel="noopener">pando_server.py</a></li></ul></li><li><code>pip3 install pyzmq --user</code></li><li>安装 <a href="https://github.com/adafruit/Adafruit_Python_BluefruitLE" target="_blank" rel="noopener">Adafruit_Python_BluefruitLE</a></li></ul><h3 id="按键控制-pando">按键控制 Pando</h3><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417161740.png" width="80%"></div><h3 id="微信遥控-pando">微信遥控 Pando</h3><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417161705.png" width="80%"></div><h3 id="语音控制-pando">语音控制 Pando</h3><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190417161932.png" width="40%"></div><h2 id="更多玩法">更多玩法</h2><p>将 Pando 的运动功能封装成 Block，在 Codelab 平台上就能赋予其更多的 AI 能力，例如</p><ul><li>人脸识别和手势识别控制 Pando</li><li>与 Pando 聊天对话</li><li>Pando 与任何智能硬件交互</li><li>更多有趣的玩法请参考<a href="https://codelab-adapter-docs.codelab.club/user_guide/gallery/" target="_blank" rel="noopener">演示视频</a></li></ul><p><strong>我们相信，孩子的想象力是天马星空的，如果把学习一门编程语言的门槛抹平，他们将能创造出更多令人惊叹的作品。</strong></p><h2 id="参考链接">参考链接</h2><ul><li><a href="https://codelab-adapter-docs.codelab.club/extension_guide/vector/" target="_blank" rel="noopener">Codelab Vector 插件</a></li><li><a href="https://codelab-adapter-docs.codelab.club/" target="_blank" rel="noopener">Welcome to codelab-adapter</a></li><li><a href="https://github.com/adafruit/Adafruit_Python_BluefruitLE" target="_blank" rel="noopener">Adafruit_Python_BluefruitLE</a></li></ul><h2 id="关于作者">关于作者</h2><blockquote><p><a href="https://github.com/wangshub" target="_blank" rel="noopener">神奇的战士</a> 公众号【神奇的战士】<br>来自乐聚的一个工程师 Github: <a href="https://github.com/wangshub" target="_blank" rel="noopener">wangshub</a><br>邮箱：<strong>rocksong.hit@gmail.com</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;当遇到-scratch3-codelabpando-觉醒了&quot;&gt;当遇到 Scratch3-Codelab，Pando 觉醒了！&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Explore Amazing Moment With Pando&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Scratch3" scheme="http://thinkhard.tech/tags/Scratch3/"/>
    
      <category term="Codelab" scheme="http://thinkhard.tech/tags/Codelab/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个 MacOS 上用了就无法自拔的神器 [Hammerspoon] 和我的配置方案</title>
    <link href="http://thinkhard.tech/2019/04/08/hammerspoon-introduce/"/>
    <id>http://thinkhard.tech/2019/04/08/hammerspoon-introduce/</id>
    <published>2019-04-08T14:26:58.000Z</published>
    <updated>2019-04-09T06:12:15.889Z</updated>
    
    <content type="html"><![CDATA[<p>推荐一个 MacOS 上用了就无法自拔的 App</p><p><strong>Hammerspoon</strong>！</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190409090520.png" width="10%"></div><p>Hammerspoon 是 MacOS 上的自动化工具，许多介绍 Hammerspoon 的文章都主要介绍了它是一个窗口管理工具，但是 Hammerspoon 能做到的远远不仅如此。</p><p>Hammerspoon 开源、免费和支持插件，将大多数系统层面的接口封装成了 Lua API，这就让<strong>这把小锤子在 MacOS 上近乎无所不能，可玩性极高</strong>。</p><h2 id="我都用-hammerspoon-做了些什么">我都用 Hammerspoon 做了些什么？</h2><ul><li><strong>菜单栏显示最近几天天气情况</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/blob/master/weather/weather.lua" target="_blank" rel="noopener">参考示例</a></li><li>请求免费的天气 API，在深圳这个多雨的城市里提醒我别忘记带伞。</li></ul></li></ul><div style="text-align:center"><img src="https://user-images.githubusercontent.com/20924010/55765634-26490700-5aa3-11e9-9d95-9cf9de6f8f17.gif" width="50%"></div><ul><li><strong>剪切板历史记录</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/clipboard" target="_blank" rel="noopener">参考示例</a></li><li>记录剪贴板历史，点击某一项再重新复制。<div style="text-align:center"><img src="https://user-images.githubusercontent.com/20924010/55765624-1b8e7200-5aa3-11e9-9f9a-ab271844c8d5.gif" width="53%"></div></li></ul></li><li><strong>音量调节快捷键</strong><ul><li><p><a href="https://github.com/wangshub/hammerspoon-config/tree/master/volume" target="_blank" rel="noopener">参考示例</a></p></li><li><p>当我使用外接键盘时，自定义快捷键 <code>cmd + up/down</code> 调节系统音量</p><div style="text-align:center"><img src="https://user-images.githubusercontent.com/20924010/55765751-c010b400-5aa3-11e9-8b78-e686b104c113.gif" width="54%"></div></li></ul></li><li><strong>窗口管理</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/window" target="_blank" rel="noopener">参考示例</a></li><li>快捷键实现二分屏、三分屏和全屏</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/hammerspoon.2019-04-08%2023_06_30.gif" width="80%"></div></li><li><strong>Wi-Fi 自动脚本</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/wifi" target="_blank" rel="noopener">参考示例</a></li><li>根据 Wi-Fi SSID 判断是否在公司还是在家，例如在家里自动挂载 NAS 服务器，如果在公司 sshfs 挂载服务器目录等。<div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190408231744.png" width="50%"></div></li></ul></li><li><strong>蓝牙耳机自动连接</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/headphone" target="_blank" rel="noopener">参考示例</a></li><li>电脑锁屏时，自动断开连接的蓝牙耳机，参考我的<a href="https://zhuanlan.zhihu.com/p/59737941" target="_blank" rel="noopener">另一篇介绍</a>。</li></ul></li><li><strong>输入法自动切换</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/ime" target="_blank" rel="noopener">参考示例</a></li><li>在每个 App 界面自动切换成搜狗输入法，配合搜狗输入法自动中英文切换，再也不用在系统默认的英文输入法和搜狗输入法之间来回切换了。</li></ul></li><li><strong>定时自动提交代码</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/autoscript" target="_blank" rel="noopener">参考示例</a></li><li>使用 <code>hs.timer</code> 定时器，定时自动推送我的笔记和下载的电子书到 Github 仓库。</li></ul></li><li><strong>USB 设备连接记录</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/usb" target="_blank" rel="noopener">参考示例</a></li><li>记录插上你电脑的每一个 USB 设备信息，凡插过必留记录。</li></ul></li><li><strong>消息推送</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/speaker" target="_blank" rel="noopener">参考示例</a></li><li>推送任意消息提醒</li></ul></li><li><strong>TTS 发声</strong><ul><li><a href="https://github.com/wangshub/hammerspoon-config/tree/master/speaker" target="_blank" rel="noopener">参考示例</a></li><li>调用 <code>say hello world</code> 合成 TTS，模拟真人发音，让 Mac 会说话。</li></ul></li><li><strong>更多... (完全停不下来啊)</strong></li></ul><h2 id="其他插件思路">其他插件思路</h2><ul><li><strong>番茄钟</strong></li><li><strong>应用搜索</strong></li><li><strong>桌面小部件</strong></li><li>...</li></ul><h2 id="使用入门">使用入门</h2><p>Hammerspoon 已经将与 MacOS 之间的系统交互封装成了 <strong>Lua 的 API</strong>，配置 <code>~/.hammerspoon/init.lua</code> 脚本可以与系统进行交互，只需要了解一些基本的 Lua 语法，就可以 <strong>Happy Hacking</strong> 了</p><ul><li><a href="https://learnxinyminutes.com/docs/lua/" target="_blank" rel="noopener">Lua 快速入门教程</a></li><li><a href="https://www.hammerspoon.org/go/" target="_blank" rel="noopener">Hammerspoon API 文档</a></li></ul><h2 id="我的参考配置">我的参考配置</h2><p>如果你懒得配置，可以参考我的配置，根据自身需求修改</p><p><a href="https://github.com/wangshub/hammerspoon-config" target="_blank" rel="noopener">wangshub/hammerspoon-config</a></p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190409090021.png" width="40%"></div><h2 id="最后">最后</h2><p>已经完全停不下来了，Hammerspoon 每天至少省下了 30 分钟的时间 😀⏱</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推荐一个 MacOS 上用了就无法自拔的 App&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hammerspoon&lt;/strong&gt;！&lt;/p&gt;
&lt;div style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent
      
    
    </summary>
    
    
      <category term="Lua" scheme="http://thinkhard.tech/tags/Lua/"/>
    
      <category term="Hammerspoon" scheme="http://thinkhard.tech/tags/Hammerspoon/"/>
    
  </entry>
  
  <entry>
    <title>升级 Macbook 2015 固态硬盘为  M.2 2280 PCIE NVME 接口 SSD</title>
    <link href="http://thinkhard.tech/2019/04/04/macbook2015upgradessd/"/>
    <id>http://thinkhard.tech/2019/04/04/macbook2015upgradessd/</id>
    <published>2019-04-04T11:18:36.000Z</published>
    <updated>2019-04-04T12:09:55.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="升级-macbook-2015-固态硬盘为-m.2-2280-pcie-nvme-接口-ssd">升级 Macbook 2015 固态硬盘为 M.2 2280 PCIE NVME 接口 SSD</h1><blockquote><p>东西没有坏掉，只有修不好的</p></blockquote><p>由于苹果原装接口 SSD 价格太高(512G ≈ 2000RMB)，采用 M2.0 接口转苹果 SSD 专用接口的转接卡，升级成本在 600RMB 左右。</p><h2 id="macbook-型号">Macbook 型号</h2><ul><li>MacBook Pro (Retina, 13-inch, Early 2015)</li><li>配置: 8G RAM, 128G SSD</li></ul><h2 id="所需材料">所需材料</h2><ul><li>NVMe PCIe M.2 转 2015 款 Macbook Pro SSD 转接卡 （￥17）</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190404192727.png" width="40%"></div><ul><li>INTEL 760p SSD M.2 2280 PCIE NVME 协议固态 （￥656）</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190404193211.png" width="30%"></div><ul><li>螺丝刀工具盒</li></ul><h2 id="更换步骤">更换步骤</h2><ul><li><p><a href="https://support.apple.com/zh-cn/HT201372" target="_blank" rel="noopener">制作 MacOS Mojave 启动 U 盘</a></p></li><li><p>自行备份旧 SSD 数据</p></li><li><p>拆解过程请参考 <a href="https://zh.ifixit.com/Guide/MacBook+Pro+%EF%BC%8813%E8%8B%B1%E5%AF%B8%EF%BC%8C%E9%85%8D%E5%A4%87Retina%E6%98%BE%E7%A4%BA%E5%B1%8F%EF%BC%8C2015%E5%88%9D%E6%9C%9F%EF%BC%89%E6%8B%86%E8%A7%A3/38300" target="_blank" rel="noopener">MacBook Pro （13英寸，配备Retina显示屏，2015初期）拆解</a></p></li><li><p>五角螺丝刀拆下 SSD，并更换转接卡</p></li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190404194132.png" width="50%"></div><ul><li>安装后盖，插上启动 U 盘，开机按照提示安装 MacOS 系统。</li></ul><h2 id="硬盘测速">硬盘测速</h2><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190404194648.png" width="60%"></div><p><strong>OK, 安装完毕，再战 5 年。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;升级-macbook-2015-固态硬盘为-m.2-2280-pcie-nvme-接口-ssd&quot;&gt;升级 Macbook 2015 固态硬盘为 M.2 2280 PCIE NVME 接口 SSD&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;东西没有坏掉，只有修不好的&lt;
      
    
    </summary>
    
    
      <category term="MacOS" scheme="http://thinkhard.tech/tags/MacOS/"/>
    
      <category term="Macbook" scheme="http://thinkhard.tech/tags/Macbook/"/>
    
  </entry>
  
  <entry>
    <title>『Hamerspoon』蓝牙自动开关</title>
    <link href="http://thinkhard.tech/2019/03/19/Mac-Bluetooth-Auto-Toggle-when-lock-unlock-screen/"/>
    <id>http://thinkhard.tech/2019/03/19/Mac-Bluetooth-Auto-Toggle-when-lock-unlock-screen/</id>
    <published>2019-03-19T06:08:10.000Z</published>
    <updated>2019-04-04T10:10:23.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hamerspoonmac-蓝牙自动开关">『Hamerspoon』Mac 蓝牙自动开关</h1><h2 id="前言">前言</h2><p><strong>如果你也像我一样使用 Mac 连接蓝牙耳机，下班后总是忘记关耳机，第二天耳机没电的话，那么这篇文章也许有用。</strong></p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190319165809.png" width="70%"></div><p>当我尝试解决上面这个问题时，写了一个 Python 脚本，但是这并不优雅，直到我找到了 <a href="https://www.hammerspoon.org/" target="_blank" rel="noopener">Hammerspoon</a>，从此打开了新世界大门。</p><h2 id="首先-hammerspoon-是什么">首先 Hammerspoon 是什么？</h2><p>Hammerspoon 是 MacOS 平台上的自动化工具，它<strong>不仅仅是应用窗口管理工具</strong>，配置 <code>~/.hammerspoon/init.lua</code> 脚本可以与系统进行交互，这就让这把小锤子的可玩性极高。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190319170342.png" width="80%"></div><p>在 <code>init.lua</code> 中，注册一系列的回调函数，当监测到事件发生，就能触发对应的回调，例如</p><ul><li>按下快捷键事件，快速切换应用；</li><li>Wi-Fi 连接事件，判断是否到家了；</li><li>USB 设备连接事件，对插上的设备进行扫描；</li><li>电脑休眠和解锁事件;</li><li>...</li></ul><p><strong>如果使用小锤子，检测到锁屏事件，那么在脚本里就可以自动地对蓝牙进行开关。</strong></p><h2 id="在-mac-上用脚本控制蓝牙开关">在 Mac 上用脚本控制蓝牙开关？</h2><p>在 OSX 上，使用 <a href="https://github.com/toy/blueutil" target="_blank" rel="noopener">blueutil</a> 可以对蓝牙进行操作</p><ul><li>安装方式: <code>brew install blueutil</code></li><li>开启蓝牙: <code>blueutil --power 1</code></li><li>关闭蓝牙: <code>blueutil --power 0</code></li></ul><h2 id="put-them-together">Put Them Together！</h2><ul><li>蓝牙切换函数，这里使用 Hammerspoon 运行 Applescript 脚本，然后再在 Applescript 里运行 shell 指令</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluetoothSwitch</span><span class="params">(state)</span></span></span><br><span class="line">  <span class="comment">-- state: 0(off), 1(on)</span></span><br><span class="line">  cmd = <span class="string">"/usr/local/bin/blueutil --power "</span>..(state)</span><br><span class="line">  result = hs.osascript.applescript(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">'do shell script "%s"'</span>, cmd))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>回调函数</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caffeinateCallback</span><span class="params">(eventType)</span></span></span><br><span class="line">    <span class="keyword">if</span> (eventType == hs.caffeinate.watcher.screensDidSleep) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"screensDidSleep"</span>)</span><br><span class="line">    <span class="keyword">elseif</span> (eventType == hs.caffeinate.watcher.screensDidWake) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"screensDidWake"</span>)</span><br><span class="line">    <span class="keyword">elseif</span> (eventType == hs.caffeinate.watcher.screensDidLock) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"screensDidLock"</span>)</span><br><span class="line">      bluetoothSwitch(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elseif</span> (eventType == hs.caffeinate.watcher.screensDidUnlock) <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"screensDidUnlock"</span>)</span><br><span class="line">      bluetoothSwitch(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>监测 Mac 系统<code>睡眠</code>、<code>锁屏</code>等事件</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caffeinateWatcher = hs.caffeinate.watcher.new(caffeinateCallback)</span><br><span class="line">caffeinateWatcher:start()</span><br></pre></td></tr></table></figure><h2 id="安装-hammerspoon-配置">安装 Hammerspoon 配置</h2><ul><li>首先需要安装 <a href="https://github.com/Hammerspoon/hammerspoon/releases/" target="_blank" rel="noopener">Hammerspoon</a></li><li><code>brew install blueutil</code></li><li><code>git clone https://github.com/wangshub/hammerspoon-config.git ~/.hammerspoon</code></li></ul><h2 id="参考链接">参考链接</h2><ul><li><a href="https://www.hammerspoon.org/docs/" target="_blank" rel="noopener">Hammerspoon 文档</a></li><li><a href="https://www.macosxautomation.com/applescript/firsttutorial/index.html" target="_blank" rel="noopener">What is AppleScript?</a></li><li><a href="https://www.lua.org/start.html" target="_blank" rel="noopener">Lua: Getting started</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hamerspoonmac-蓝牙自动开关&quot;&gt;『Hamerspoon』Mac 蓝牙自动开关&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你也像我一样使用 Mac 连接蓝牙耳机，下班后总是忘记关耳机，第二天耳机没电的话，那么这篇文章也许
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://thinkhard.tech/tags/Mac/"/>
    
      <category term="Lua" scheme="http://thinkhard.tech/tags/Lua/"/>
    
      <category term="Hammerspoon" scheme="http://thinkhard.tech/tags/Hammerspoon/"/>
    
  </entry>
  
  <entry>
    <title>强化学习之 Deep Q­-Learning</title>
    <link href="http://thinkhard.tech/2019/03/11/RLDeepQlearning/"/>
    <id>http://thinkhard.tech/2019/03/11/RLDeepQlearning/</id>
    <published>2019-03-11T12:27:30.000Z</published>
    <updated>2019-04-04T10:10:23.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deep-q-learning">Deep Q­-Learning</h1><h2 id="q-learning">Q-Learning</h2><p>在 Q-Learning 中定义函数 <span class="math inline">\(Q(s, a)\)</span> 表示在当前状态 <span class="math inline">\(s\)</span> 下采取动作 <span class="math inline">\(a\)</span> 获得的最大有损奖励</p><p><span class="math display">\[Q\left(s_{t}, a_{t}\right)=\max R_{t+1}\]</span></p><p>可以将 <span class="math inline">\(Q(s, a)\)</span> 理解为在一局游戏中，如果在状态 <span class="math inline">\(s\)</span> 下采取动作 <span class="math inline">\(a\)</span> 后，在游戏结束所能获得的最高分。即 <strong>Q-函数</strong> 表示在某一个状态下采取相应动作的<strong>质量</strong>。</p><p>那么策略 <span class="math inline">\(\pi(s)\)</span> 就可以表示成在每个状态 <span class="math inline">\(s\)</span> 下选择动作 <span class="math inline">\(a\)</span> 的函数</p><p><span class="math display">\[\pi(s)=\operatorname{argmax}_{a} Q(s, a)\]</span></p><p>许多强化学习算法的基本思想都是通过迭代更新 Bellman 方程来对<strong>动作-值</strong>进行估计，最佳的得分奖励是由当前环境的即使奖励 <span class="math inline">\(r\)</span> 和下一个状态 <span class="math inline">\(s^{\prime}\)</span> 的最大奖励的加和。</p><p><span class="math display">\[Q_{i+1}(s, a)=r+\gamma \max _{a^{\prime}} Q_{i}\left(s^{\prime}, a^{\prime}\right)\]</span></p><p>Q-Learning 的核心思想：<strong>用 Bellman 方程迭代近似估计 Q-函数</strong>。一种最简单的方式实现 Q-函数 的方式就是建立一个行为状态，列为动作的表格。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190312210159.png" width="50%"></div><p>Q-learning 伪代码表示如下</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190312092656.png" width="70%"></div><p>其中 <span class="math inline">\(\alpha\)</span> 成为学习率，用于控制上一时刻的 Q-值 与下一时刻 Q-值 的差值对更新过程的影响，当 <span class="math inline">\(\alpha=1\)</span> 时，上式即为 Bellman 方程。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190312210239.png" width="80%"></div><p>假设在上图中令机器人从起始位置往右移动 1 步，然后计算并更新 Q-值。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190313082800.png" width="70%"></div><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190313084707.png" width="70%"></div><p>当 <span class="math inline">\(i \rightarrow \infty\)</span> 时，即可找到<strong>最佳动作值函数</strong> <span class="math inline">\(Q_{i+t} \rightarrow Q^{*}\)</span>。但是在实际当中，每个轨迹序列当中，动作值函数都是被单独估计，不具有任何的泛化的能力。比较常见的方式就是使用(如神经网络)线性或者非线性的估计函数来对动作值函数进行近似估计。</p><h2 id="深度-q-网络deep-q-network">深度 Q 网络(Deep Q Network)</h2><p>假设状态是一张 64*64 分辨率的图像，那么每个像素点用 8bit 的灰度值表示，那么状态 <span class="math inline">\(s\)</span> 就可能有 <span class="math inline">\(256^{64 \times 64}\)</span> 种可能，如果构造这么一张巨大无比的 Q-Table，那将是不现实的。</p><p>对于高度结构化的数据，正好适合用深度神经网络来对 Q 函数进行近似估计。输入状态 <span class="math inline">\(s\)</span> 和动作，通过网络，输出对应的 Q-值。另一种方式是在 DeepMind 文章中，只是输入当前的状态 <span class="math inline">\(s\)</span>, 输出各个 Action 对应的 Q-值。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190311204446.png" width="80%"></div><p>在 Google DeepMind 的 Paper 中使用了如下的网络结构来对 <span class="math inline">\(\max _{a} \cdot Q\left(s^{\prime}, a^{\prime}\right)\)</span> 进行近似估计</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190311204645.png" width="90%"></div><p>DeepMind 在文章中使用的网络模型如下。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190313091430.png" width="80%"></div><p>Q 值可能是任意的实数，把对 Q 值的估计看作是机器学习中的<strong>回归问题</strong>，所以使用 <strong>平方误差损失(squared error loss)</strong> 作为优化的目标函数。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190313195452.png" width="40%"></div><p><span class="math display">\[L_{i}\left(\theta_{i}\right)=\mathbb{E}_{\left(s, a, r, s^{\prime}\right) \sim \mathrm{U}(D)}\left[\left(r+\gamma \max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime} ; \theta_{i}^{-}\right)-Q\left(s, a ; \theta_{i}\right)\right)^{2}\right]\]</span></p><p>给定轨迹 <span class="math inline">\(&lt;s, a, r, s^{\prime}&gt;\)</span> ，使用神经网络替换 Q-Table 过程如下</p><ol type="1"><li>输入当前状态 <span class="math inline">\(s\)</span>，预测所有动作 <span class="math inline">\(a\)</span> 的 Q-值；</li><li>输入下一状态 <span class="math inline">\(s\)</span>，计算最大 <span class="math inline">\(\max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime}\right)\)</span></li><li>设置 Q 值优化目标为 <span class="math inline">\(r+ \gamma \max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime}\right)\)</span></li><li>反向传播更新网络 weights；</li></ol><p>目标 <span class="math inline">\(\max _{a^{\prime}} Q\)</span> 取决于神经网络中神经元的权重。监督学习在学习之前，待估计的目标是确定的。 在优化 <span class="math inline">\(L_{i}\left(\theta_{i}\right)\)</span> 时保持上一次迭代参数 <span class="math inline">\(\theta_{i}^{-}\)</span> 固定不变。</p><p>利用随机梯度下降优化损失函数</p><p><span class="math display">\[\nabla_{\theta_{i}} L\left(\theta_{i}\right)=\mathbb{E}_{s, a, r, s^{\prime}}\left[\left(r+\gamma \max _{a^{\prime}} Q\left(s^{\prime}, a^{\prime} ; \theta_{i}^{-}\right)-Q\left(s, a ; \theta_{i}\right)\right) \nabla_{\theta_{i}} Q\left(s, a ; \theta_{i}\right)\right]\]</span></p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190312083834.png" width="80%"></div><h2 id="经验回放exploration-exploitation">经验回放(Exploration-Exploitation)</h2><p><strong>为什么要经验回放？</strong></p><ul><li>网络是健忘的</li></ul><h2 id="参考文献">参考文献</h2><ul><li><p>https://medium.freecodecamp.org/an-introduction-to-q-learning-reinforcement-learning-14ac0b4493cc</p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deep-q-learning&quot;&gt;Deep Q­-Learning&lt;/h1&gt;
&lt;h2 id=&quot;q-learning&quot;&gt;Q-Learning&lt;/h2&gt;
&lt;p&gt;在 Q-Learning 中定义函数 &lt;span class=&quot;math inline&quot;&gt;\(Q(s, a)
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="RL" scheme="http://thinkhard.tech/tags/RL/"/>
    
  </entry>
  
  <entry>
    <title>树莓派FM小电台背后的原理解析</title>
    <link href="http://thinkhard.tech/2019/02/26/%E6%A0%91%E8%8E%93%E6%B4%BEFM%E5%B0%8F%E7%94%B5%E5%8F%B0%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://thinkhard.tech/2019/02/26/树莓派FM小电台背后的原理解析/</id>
    <published>2019-02-26T12:53:30.000Z</published>
    <updated>2019-04-04T10:10:23.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树莓派-fm-发送机小电台背后的原理解析">树莓派 FM 发送机小电台背后的原理解析</h1><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190302161549.png" width="60%"></div><h2 id="介绍">介绍</h2><p>在知乎上有个问题 <a href="https://www.zhihu.com/question/23498424/answer/601685254" target="_blank" rel="noopener">你在 GitHub 上看到过的最有意思的项目是什么？</a> 我介绍了个很有意思的无线 FM 电台的项目，可以在不借用其他外部设备的情况下，通过代码实现将树莓派变为 FM 小电台。</p><p>但是作者只是在<a href="http://www.icrobotics.co.uk/wiki/index.php/Turning" target="_blank" rel="noopener">博客中</a>介绍了大致的原理。于是我搜遍整个网络，发现大多数的相关文章只是教你如何去编译运行代码，对背后的原理却是只言片语，含糊不清。</p><p>作为好奇宝宝，我查阅了许多芯片手册和论坛文章，又翻了翻以前学过的《天线原理》对背后的原理做了一下归纳和总结。</p><h2 id="概念名词解释">概念名词解释</h2><p>首先是一些基本的概念</p><ul><li><strong>FM</strong>: 调频(Frequency Modulation) 是一种以载波的瞬时频率变化来表示信息的调制方式，载波的频率跟随输入信号的幅度直接成等比例变化。FM Radio  就是我们熟悉的调频收音机。</li></ul><div style="text-align:center"><img src="https://i.gifer.com/Gq2S.gif" width="50%"></div><ul><li><strong>PWM</strong>: 脉冲宽度调制(Pulse Width Modulation) 是使用数字源生成模拟信号的方法。主要由 2 个参数来定义：<strong>占空比</strong>和<strong>频率</strong>。如果以保持一定的速率开关数字信号并且保持一定的占空比，那么输出看起来就像恒定电压模拟信号。</li></ul><div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/1/1f/PWM_3L.gif" width="60%"></div><ul><li><strong>GPIO</strong>: 通用型输入输出(General-purpose input/output)，引脚可以由程序控制作为通用输入(GPI)或者通用输出(GPO)。</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190227084604.png" width="70%"></div><ul><li><strong>CPU</strong>: 中央处理器(Central Processing Unit)，相当于树莓派的大脑，功能主要是解释计算机指令以及处理计算机软件中的数据，负责与外围设备通信。树莓派使用的是博通 BCM28XX 系列的 CPU。</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190227085239.png" width="50%"></div><ul><li><strong>DMA</strong>: 直接内存访问(Direct Memory Access)这些设备可以执行涉及主内存和其他设备的数据传送。由于设备执行这些操作的过程中无需借助于 CPU，因此该类型的数据传送称为直接内存访问。简单说就是不用  跟 CPU 打招呼就可以直接访问内存。</li></ul><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190227085818.png" width="70%"></div><h2 id="how">HOW?</h2><p>根据<a href="https://zh.wikipedia.org/wiki/%E9%A6%AC%E5%85%8B%E5%A3%AB%E5%A8%81%E6%96%B9%E7%A8%8B%E7%B5%84" target="_blank" rel="noopener"><strong>麦克斯韦的电磁场理论</strong></a></p><blockquote><ol type="1"><li>变化的磁场能够在周围空间产生电场，变化的电场能够在周围空间产生磁场。</li><li>随时间均匀变化的磁场(电场)产生稳定电场(磁场)。随时间不均匀变化的磁场(电场)产生变化的电场(磁场)。</li><li>变化的电场和变化的磁场总是相互关系着，形成一个不可分割的统一体，这就是电磁场。</li></ol></blockquote><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190302181015.png" width="50%"></div><p><strong>随时间变化的电场产生磁场，而随时间变化的磁场又产生电场，两者互为因果。这种不断转化的场统称为电磁场。这种相互的转化形成电磁振荡。</strong></p><p>所以如果在树莓派的 GPIO 上，通过软件控制以一定频率输出高低电平(0/1)，再加上适当长度的天线(一根杜邦线即可)就可以将能量以电磁波的形式发射出去。</p><h3 id="fm-结构图">FM 结构图</h3><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190302170533.png" width="80%"></div><p>由图可知，组成一个 FM 发射机系统，树莓派需要</p><ul><li>信号采样和 FM 调制所需的时钟</li><li>可以通过编程控制电平变化的 GPIO</li><li>一段可以将电磁波发射出去的天线</li></ul><h3 id="时钟">时钟</h3><p>目前绝大多数的的微处理器都有扩频时钟(Spread-spectrum clock)，目的是为了降低<strong>电磁干扰(EMI)</strong>，在树莓派 BCM28XX 系列芯片上，扩频时钟的范围为 1MHz 到 250MHz，这正好用作 FM 的载波信号。</p><p>为了减少 CPU 占用，作者对程序进行了改进，使用树莓派 DMA 产生基础时钟。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190227212628.png" width="50%"></div><h3 id="信号采样">信号采样</h3><p>由于 FM 广播发送的是音频信号，所以先使用 228 kHz 的采样频率对信号进行采样(满足奈奎斯特采样定理)，带宽为 15 kHz。</p><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190302173206.png" width="80%"></div><h3 id="调频">调频</h3><p>基带信号 <span class="math inline">\(x_{m}(t)\)</span>，载波频率 <span class="math inline">\(f_{c}\)</span>，正弦载波为<span class="math inline">\(x_{c}(t)=A_{c} \cos \left(2 \pi f_{c} t\right)\)</span> 将基带数据信号与载波结合起来得到了传输信号</p><p><span class="math display">\[\begin{aligned} y(t) &amp;=A_{c} \cos \left(2 \pi \int_{0}^{t} f(\tau) d \tau\right) \\ &amp;=A_{c} \cos \left(2 \pi \int_{0}^{t}\left[f_{c}+f_{\Delta} x_{m}(\tau)\right] d \tau\right) \\ &amp;=A_{c} \cos \left(2 \pi f_{c} t+2 \pi f_{\Delta} \int_{0}^{t} x_{m}(\tau) d \tau\right) \end{aligned}\]</span></p><p>其中 <span class="math inline">\(f(\tau)\)</span> 为传输信号的瞬时频率，<span class="math inline">\(f_{\Delta}\)</span> 为频偏表示相对载波频率 <span class="math inline">\(f_{c}\)</span> 的最大频率偏移。</p><p>调频输出的是模拟信号，利用时钟产生 PWM 调整占空比和频率，就可以利用数字信号生成模拟信号。</p><h3 id="树莓派天线长度">树莓派天线长度</h3><ul><li><strong>波长</strong>： <span class="math inline">\(\lambda=c/f\)</span></li><li><strong>偶极子天线</strong>：制作偶极子天线时，会通过工作波长来确定天线的长度。最常见的偶极子天线是半波天线，它的总长度近似为工作波长的一半，即 <span class="math inline">\(L=\lambda / 2\)</span></li></ul><div style="text-align:center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Dipole_xmting_antenna_animation_4_408x318x150ms.gif/250px-Dipole_xmting_antenna_animation_4_408x318x150ms.gif" width="50%"></div><p>如果需要发射 100MHz 的 FM 信号，根据上面的公式来计算，就需要 1.5m 长的天线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>*<span class="number">10</span>**<span class="number">8</span> / (<span class="number">2</span> * <span class="number">100</span> * <span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure><p>所以理论上如果给树莓派 GPIO(PIN4) 加上了一根 1.5M 的天线，那么就可以输出最大功率的 FM 信号。</p><p><strong>不要这么做，会干扰正常频段！</strong></p><h4 id="传播距离估计">传播距离估计</h4><p>首先需要计算有效全向辐射功率(EIRP)</p><p><span class="math display">\[EIRP = P - Loss +G\]</span></p><p>其中 <span class="math inline">\(P\)</span> 为发射机的输出功率(<span class="math inline">\(dBm\)</span>)，<span class="math inline">\(Loss\)</span> 为发射机输出端与天线馈源之间的馈线损耗(<span class="math inline">\(dB\)</span>)，<span class="math inline">\(G\)</span> 为天线的发送增益(<span class="math inline">\(dBi\)</span>)。求出 EIRP 后可以进而获得自由空间路径损失（Free Space Path Loss，FSPL）。</p><p>但是使用这个公式估算，意义不是太大。实际测量，如果使用一根 10cm 的杜邦线作为天线，一个楼梯拐角信号就已经非常弱了。</p><h2 id="总结">总结</h2><ul><li>深深佩服第一个作者的 Geek 范和莫大的脑洞;</li><li>不要干扰正常频段，属于违法行为！</li></ul><h2 id="参考">参考</h2><blockquote><p>代码请见参考链接</p></blockquote><ul><li>[1] Eben Upton and Gareth Halfacree. Raspberry Pi user guide. John Wiley &amp; Sons, 2014.</li><li>[2] Oliver Mattos and Oskar Weigl. Turning the Raspberry Pi Into an FM Transmitter. http://www.icrobotics.co.uk/wiki/index.php/Turning the Raspberry Pi Into an FM Transmitter, 2015.</li><li>[3] Christophe Jacquet. FM-RDS transmitter using the Raspberry Pi’s PWM . https://github.com/ChristopheJacquet/PiFmRds, 2014.</li><li>[4] Richardson. Turning the Raspberry Pi Into an FM Transmitter. http://www.icrobotics.co.uk/wiki/index.php/Turning_the_Raspberry_Pi_Into_an_FM_Transmitter, 2015.</li></ul><blockquote><p>欢迎关注我的个人公众号</p></blockquote><div style="text-align:center"><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img/20190302174637.png" width="20%"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;树莓派-fm-发送机小电台背后的原理解析&quot;&gt;树莓派 FM 发送机小电台背后的原理解析&lt;/h1&gt;
&lt;div style=&quot;text-align:center&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/wangshub
      
    
    </summary>
    
    
      <category term="RaspberryPi" scheme="http://thinkhard.tech/tags/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title>用Python给抖音小姐姐打声招呼</title>
    <link href="http://thinkhard.tech/2019/02/20/%E7%94%A8Python%E7%BB%99%E6%8A%96%E9%9F%B3%E5%B0%8F%E5%A7%90%E5%A7%90%E6%89%93%E5%A3%B0%E6%8B%9B%E5%91%BC/"/>
    <id>http://thinkhard.tech/2019/02/20/用Python给抖音小姐姐打声招呼/</id>
    <published>2019-02-20T09:04:28.000Z</published>
    <updated>2019-04-04T10:10:23.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-python-自动给抖音小姐姐评论一个-666">用 Python 自动给抖音小姐姐评论一个 666</h1><p>前一段时间写了一篇 <a href="https://zhuanlan.zhihu.com/p/37365182" target="_blank" rel="noopener">《抖音 Python 机器人，论如何在抖音上找到漂亮小姐姐？》</a>，没想到有相当多的同学有着相同的需求！</p><p>大家皆为</p><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img20190220191539.png"></p><p>程序的基本思路请见 <a href="https://github.com/wangshub/Douyin-Bot#%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">原理与使用教程</a></p><p>当程序在抖音上刷到一个漂亮小姐姐的时候就会自动点赞加关注</p><p><img src="https://github.com/wangshub/Douyin-Bot/raw/master/screenshot/auto_reply.gif" width="280/"></p><p>作为一个闷骚程序员，见到漂亮小姐姐总是在<strong>背后默默点赞加关注</strong>。</p><p>但是鲁迅曾经说过 <code>喜欢就要大声说出来！</code></p><p>于是我又给脚本加上了这么一个<strong>自动评论</strong>的功能</p><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img20190220191645.png" width="280/"></p><h2 id="自动评论实现步骤">自动评论实现步骤</h2><p>查阅 ADB 文档， <code>adb shell input text "hello,world"</code> 命令可直接将字符串输入到 Android App 的输入框中，但是仅支持 ASICC 字符，也就是不能够输入中文字符。好在 <a href="https://github.com/senzhk/ADBKeyBoard" target="_blank" rel="noopener">senzhk</a> 写了一个 ADB 虚拟键盘输入法，通过监听 ADB 广播事件接收 ADB 发送的 Unicode 编码字符串，然后输入到文本框中，可以绕过这个限制。</p><p><strong>操作步骤</strong></p><ul><li><p>安卓手机安装 <a href="https://github.com/wangshub/Douyin-Bot/blob/master/apk/ADBKeyBoard.apk" target="_blank" rel="noopener">ADBKeyBoard.apk</a></p></li><li><p>将手机默认输入法切换为 <code>ADB KeyBoard</code></p><p><img src="https://raw.githubusercontent.com/wangshub/image-hosting/master/img20190220195516.png" width="240"></p></li><li><p>手机连上电脑，在输入框输入 <code>adb shell am broadcast -a ADB_INPUT_TEXT --es msg '可爱小姐姐你好呀'</code> 即可输入中文字符；</p></li></ul><h2 id="代码实现">代码实现</h2><p>完整代码请参考 <a href="https://github.com/wangshub/Douyin-Bot" target="_blank" rel="noopener">wangshub/Douyin-Bot</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_reply</span><span class="params">()</span>:</span></span><br><span class="line">    msg = <span class="string">"垆边人似月，皓腕凝霜雪。就在刚刚，我的心动了一下，小姐姐你好可爱呀_Powered_By_Python"</span></span><br><span class="line">    tap(config[<span class="string">'comment_bottom'</span>][<span class="string">'x'</span>], config[<span class="string">'comment_bottom'</span>][<span class="string">'y'</span>])</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    tap(config[<span class="string">'comment_text'</span>][<span class="string">'x'</span>], config[<span class="string">'comment_text'</span>][<span class="string">'y'</span>])</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    cmd = <span class="string">'shell am broadcast -a ADB_INPUT_TEXT --es msg &#123;text&#125;'</span>.format(text=msg)</span><br><span class="line">    adb.run(cmd)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    tap(config[<span class="string">'comment_send'</span>][<span class="string">'x'</span>], config[<span class="string">'comment_send'</span>][<span class="string">'y'</span>])</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    cmd = <span class="string">'shell input keyevent 4'</span></span><br><span class="line">    adb.run(cmd)</span><br></pre></td></tr></table></figure><h2 id="存在的问题">存在的问题</h2><ul><li><input type="checkbox" disabled>ADB 不支持 Unicode 编码，所以需要用 ADB KeyBoard 操作比较繁琐；</li><li><input type="checkbox" disabled>再者 ADB 是对屏幕坐标点击，存在屏幕分辨率适配的硬伤；</li><li><input type="checkbox" disabled>针对上面的两个问题，可以使用 App 自动化测试工具 <a href="http://appium.io/" target="_blank" rel="noopener">Appium</a> 解决，后面再找机会把坑填上；</li></ul><h2 id="总结">总结</h2><p>小孩子不要玩抖音 ！小孩子不要玩抖音！ 太耗时间了，每天在安装了又卸载，卸载了又安装的 Loop 中循环 O_O</p><blockquote><p>送人一赞，手留余香 🌹 作者：神奇的战士 <a href="https://github.com/wangshub" target="_blank" rel="noopener">https://github.com/wangshub</a> 欢迎关注我的公众号【神奇的战士】，期待跟你分享有趣的代码 ~</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs09ydtc98j20vd06p759.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用-python-自动给抖音小姐姐评论一个-666&quot;&gt;用 Python 自动给抖音小姐姐评论一个 666&lt;/h1&gt;
&lt;p&gt;前一段时间写了一篇 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/37365182&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="ADB" scheme="http://thinkhard.tech/tags/ADB/"/>
    
      <category term="Douyin" scheme="http://thinkhard.tech/tags/Douyin/"/>
    
  </entry>
  
  <entry>
    <title>在GitHub上看到过的最有意思的项目</title>
    <link href="http://thinkhard.tech/2019/02/18/%E5%9C%A8GitHub%E4%B8%8A%E7%9C%8B%E5%88%B0%E8%BF%87%E7%9A%84%E6%9C%80%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>http://thinkhard.tech/2019/02/18/在GitHub上看到过的最有意思的项目/</id>
    <published>2019-02-18T07:02:53.000Z</published>
    <updated>2019-05-27T00:41:39.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在github上看到过的最有意思的项目">在GitHub上看到过的最有意思的项目</h1><h3 id="键盘听声识键">键盘听声识键</h3><ul><li>地址：<a href="https://github.com/ggerganov/kbd-audio" target="_blank" rel="noopener">ggerganov/kbd-audio</a></li><li>通过麦克风录取键盘的敲击声，判断你按下的是哪个按键。kbd-audio 提供了一整套 GUI 工具，帮助你可视化分析输入的语音数据。从此在输入密码的时候得小心了 -_-</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.imgur.com/mnRvT1X.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="通过-wi-fi-信号估计附近有多少人">通过 Wi-Fi 信号估计附近有多少人</h3><ul><li>地址：<a href="https://github.com/schollz/howmanypeoplearearound" target="_blank" rel="noopener">schollz/howmanypeoplearearound</a></li><li>用一个支持<a href="https://github.com/wangshub/hmpa-pi#%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BD%91%E5%8D%A1" target="_blank" rel="noopener">监听模式</a>的 USB 网卡，就可以扫描出附近 Wi-Fi 的网络内的设备与信号强度。按照不同国家地区人群拥有手机比例，就可以大致估计附近人数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ howmanypeoplearearound -o test.json -a wlan1</span><br><span class="line">[==================================================] 100%         0s left</span><br><span class="line">There are about 4 people around.</span><br><span class="line">$ cat test.json | python3 -m json.tool</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;rssi&quot;: -86.0,</span><br><span class="line">    &quot;mac&quot;: &quot;90:e7:c4:xx:xx:xx&quot;,</span><br><span class="line">    &quot;company&quot;: &quot;HTC Corporation&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;rssi&quot;: -84.0,</span><br><span class="line">    &quot;mac&quot;: &quot;80:e6:50:xx:xx:xx&quot;,</span><br><span class="line">    &quot;company&quot;: &quot;Apple, Inc.&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;rssi&quot;: -49.0,</span><br><span class="line">    &quot;mac&quot;: &quot;ac:37:43:xx:xx:xx&quot;,</span><br><span class="line">    &quot;company&quot;: &quot;HTC Corporation&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="树莓派-fm-发送站">树莓派 FM 发送站</h3><ul><li>地址：<a href="https://github.com/Miegl/PiFmAdv" target="_blank" rel="noopener">Miegl/PiFmAdv</a></li><li>对音频信号进行 FM 调制，树莓派的 GPIO 口作为天线发射信号，一个小小的私人电台就搭建好了。</li><li>注意：私人架设电台是违法行为，不能发射大功率的信号干扰正常的FM频段!</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/miegl/PiFmAdv/raw/master/doc/galaxy_s2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="github-仓库代码隐私数据扫描">Github 仓库代码隐私数据扫描</h3><ul><li>地址: <a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="noopener">dxa4481/truffleHog</a></li><li>有相当多的人会在自己的 Github 开源项目中遗留一些账号密码，truffleHog 可以在对 Git 的所有分支和 Commit 记录中搜索密钥等敏感信息。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://camo.githubusercontent.com/3972f94b479bb40fb690e2cadcd3dd14ab3c3073/68747470733a2f2f692e696d6775722e636f6d2f5941586e644c442e706e67" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="wi-fi-破解">Wi-Fi 破解</h3><ul><li>地址：<a href="https://github.com/brannondorsey/wifi-cracking" target="_blank" rel="noopener">brannondorsey/wifi-cracking</a></li><li>该项目详细记录了用 Airodump-ng 和 Aircrack-ng/Hashcat 破解 WPA/WPA2 无线 Wi-Fi 路由器的过程和思路。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ultimatepeter.com/wp-content/uploads/2013/09/hack-wi-fi-cracking-wpa2-psk-passwords-with-cowpatty.w654.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>最后还有这个 ...</strong></p><p><del>已删除</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在github上看到过的最有意思的项目&quot;&gt;在GitHub上看到过的最有意思的项目&lt;/h1&gt;
&lt;h3 id=&quot;键盘听声识键&quot;&gt;键盘听声识键&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;地址：&lt;a href=&quot;https://github.com/ggerganov/kbd-audi
      
    
    </summary>
    
    
      <category term="Code" scheme="http://thinkhard.tech/tags/Code/"/>
    
      <category term="Github" scheme="http://thinkhard.tech/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Vanilla_Policy_Gradient</title>
    <link href="http://thinkhard.tech/2019/01/29/Vanilla-Policy-Gradient/"/>
    <id>http://thinkhard.tech/2019/01/29/Vanilla-Policy-Gradient/</id>
    <published>2019-01-29T08:48:53.000Z</published>
    <updated>2019-10-31T01:42:48.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习-vanilla-policy-gradient">强化学习 Vanilla Policy Gradient</h1><p>令 <span class="math inline">\(\pi _ { \theta }\)</span> 表示参数为 <span class="math inline">\(\theta\)</span> 的策略，<span class="math inline">\(J \left( \pi _ { \theta } \right)\)</span> 表示策略 <span class="math inline">\(\pi _ { \theta }\)</span> 的返回值，则优化函数梯度为</p><p><span class="math display">\[\nabla _ { \theta } J \left( \pi _ { \theta } \right) = \underset { \tau \sim \pi _ { \theta } } { E } \left[ \sum _ { t = 0 } ^ { T } \nabla _ { \theta } \log \pi _ { \theta } \left( a _ { t } | s _ { t } \right) A ^ { \pi _ { \theta } } \left( s _ { t } , a _ { t } \right) \right]\]</span></p><p>梯度上升</p><p><span class="math display">\[\theta _ { k + 1 } = \theta _ { k } + \alpha \nabla _ { \theta } J \left( \pi _ { \theta _ { k } } \right)\]</span></p><p>算法伪代码</p><p><img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190129183255.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强化学习-vanilla-policy-gradient&quot;&gt;强化学习 Vanilla Policy Gradient&lt;/h1&gt;
&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(\pi _ { \theta }\)&lt;/span&gt; 表示参数为 &lt;sp
      
    
    </summary>
    
    
      <category term="Reinforcement learning" scheme="http://thinkhard.tech/tags/Reinforcement-learning/"/>
    
      <category term="Algorithm" scheme="http://thinkhard.tech/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>用Python获取B站播放历史记录</title>
    <link href="http://thinkhard.tech/2019/01/22/%E7%94%A8Python%E8%8E%B7%E5%8F%96B%E7%AB%99%E6%92%AD%E6%94%BE%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
    <id>http://thinkhard.tech/2019/01/22/用Python获取B站播放历史记录/</id>
    <published>2019-01-22T10:40:22.000Z</published>
    <updated>2019-04-04T10:10:23.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-python-获取-b-站播放历史记录">用 Python 获取 B 站播放历史记录</h1><p>最近 B 站出了一个年度报告，统计用户一年当中在 B 站上观看视频的总时长和总个数。过去一年我居然在 B 站上看了 <code>2600+</code> 个视频，总计 <code>251</code> 个小时，居然花了这么多时间，吓得我差点把 Bilibili App 卸载了...</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fzfksqinlgj208i07475z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>然而我又很好奇，到底我在 B 站上都看了些什么类型 <del>小姐姐</del> 的视频，用几行 Python 代码实现了一下。</p><h2 id="获取请求-api-接口与-cookie">获取请求 Api 接口与 Cookie</h2><p>实现起来非常容易，获取 cookie 模拟请求即可</p><ol type="1"><li><p>使用 chrome 浏览器</p></li><li><p>登陆 <a href="https://www.bilibili.com" target="_blank" rel="noopener">B 站</a>，进入历史记录 <a href="https://www.bilibili.com/account/history" target="_blank" rel="noopener">https://www.bilibili.com/account/history</a></p></li><li><p>在网页任意位置，鼠标右键 <code>检查</code></p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fzfkf5qyuqj20c009g765.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="4" type="1"><li>按照下图所示，进入 <code>Network</code> 页面，筛选框输入 <code>history</code>，对结果进行筛选，页面滚轮往下即可看到浏览过程中的历史记录请求的 <code>Header</code></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fzfkc5s8scj21ga0nok4i.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="5" type="1"><li>将 Header 下， cookie 一行的字符串复制出来到一个 <code>cookie.txt</code> 文本里</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fzfkkj1adsj20ta07ita2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="python-代码实现">Python 代码实现</h2><ul><li>伪造浏览器请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_cookies_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""read cookie txt file</span></span><br><span class="line"><span class="string">    :param filename: (str) cookies file path</span></span><br><span class="line"><span class="string">    :return: (dict) cookies</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">'r'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        cookies = fp.read()</span><br><span class="line">        <span class="keyword">return</span> cookies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(filename)</span>:</span></span><br><span class="line">    cookie = read_cookies_file(filename)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7'</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'Cookie'</span>: cookie,</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'api.bilibili.com'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'https://www.bilibili.com/account/history'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 '</span></span><br><span class="line">                      <span class="string">'(KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">req_get</span><span class="params">(headers, url)</span>:</span></span><br><span class="line">    resp = requests.get(url, headers=headers)</span><br><span class="line">    <span class="keyword">return</span> json.loads(resp.text)</span><br></pre></td></tr></table></figure><ul><li>使用 cookie 模拟请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_bili_history</span><span class="params">(cookie_file)</span>:</span></span><br><span class="line">    headers = bilibili.get_header(cookie_file)</span><br><span class="line">    history = &#123;<span class="string">'all'</span>: []&#125;</span><br><span class="line">    <span class="keyword">for</span> page_num <span class="keyword">in</span> range(MAX_PAGE):</span><br><span class="line">        time.sleep(<span class="number">0.6</span>)</span><br><span class="line">        url = <span class="string">'https://api.bilibili.com/x/v2/history?pn=&#123;pn&#125;&amp;ps=&#123;ps&#125;&amp;jsonp=jsonp'</span>.format(pn=page_num, ps=PAGE_PER_NUM)</span><br><span class="line">        result = bilibili.req_get(headers, url)</span><br><span class="line">        print(<span class="string">'page = &#123;&#125; code = &#123;&#125; datalen = &#123;&#125;'</span>.format(page_num, result[<span class="string">'code'</span>], len(result[<span class="string">'data'</span>])))</span><br><span class="line">        <span class="keyword">if</span> len(result[<span class="string">'data'</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        history[<span class="string">'all'</span>].append(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> history</span><br></pre></td></tr></table></figure><ul><li>代码非常简单，完整代码在 <a href="https://github.com/wangshub/bilibili-history" target="_blank" rel="noopener">https://github.com/wangshub/bilibili-history</a></li></ul><h2 id="存在的问题">存在的问题</h2><ul><li><p>本来想拿到所有的播放记录，做一些统计和预测，但是经过实测，B 站只能获取到最近 <code>1000</code> 条或者最近 <code>3</code> 个月的播放记录</p></li><li><p>如果想获得更多，只能做一个监测程序，不停地从接口获取数据</p></li></ul><h2 id="安全问题">安全问题</h2><p>尽量不要使用不安全的 wifi 网络，有可能会被别有用心之人获取网络请求的 Package，易泄露个人隐私。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用-python-获取-b-站播放历史记录&quot;&gt;用 Python 获取 B 站播放历史记录&lt;/h1&gt;
&lt;p&gt;最近 B 站出了一个年度报告，统计用户一年当中在 B 站上观看视频的总时长和总个数。过去一年我居然在 B 站上看了 &lt;code&gt;2600+&lt;/code&gt; 个视
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>强化学习:策略梯度算法</title>
    <link href="http://thinkhard.tech/2019/01/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0:%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://thinkhard.tech/2019/01/15/强化学习:策略梯度算法/</id>
    <published>2019-01-15T11:46:17.000Z</published>
    <updated>2019-04-04T10:10:23.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习策略梯度算法">强化学习:策略梯度算法</h1><h2 id="策略梯度的公式推导">策略梯度的公式推导</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190115200214.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>​ 学习<strong>参数化表示的策略</strong> (Parameterized policy), 输入环境状态 $ S $ 来选择动作 <span class="math inline">\(a\)</span> ，这里使用 <span class="math inline">\(\theta \in \mathbb { R } ^ { d }\)</span> 来表示策略的参数向量，因此策略函数表示为</p><p><span class="math display">\[\pi ( a | s , \boldsymbol { \theta } ) = \operatorname { P_r } \left\{ A _ { t } = a | S _ { t } = s , \boldsymbol { \theta } _ { t } = \boldsymbol { \theta } \right\} \tag{1} \]</span></p><p>其中时刻 <span class="math inline">\(t\)</span> ，环境状态为 <span class="math inline">\(s\)</span> ，参数为 <span class="math inline">\(\theta\)</span> ，输出动作 <span class="math inline">\(a\)</span> 的概率为 <span class="math inline">\(P_r\)</span></p><p>因此生成马尔可夫决策过程的一个<em>轨迹</em>（trajectory）<span class="math inline">\(\tau = (\mathbf { s } _ { 1 } , \mathbf { a } _ { 1 } , \dots , \mathbf { s } _ { T } , \mathbf { a } _ { T })\)</span> 的概率为</p><p><span class="math display">\[\underbrace { p _ { \theta } \left( \mathbf { s } _ { 1 } , \mathbf { a } _ { 1 } , \ldots , \mathbf { s } _ { T } , \mathbf { a } _ { T } \right) } _ { \pi _ { \theta } ( \tau ) } = p \left( \mathbf { s } _ { 1 } \right) \prod _ { t = 1 } ^ { T } \pi _ { \theta } \left( \mathbf { a } _ { t } | \mathbf { s } _ { t } \right) p \left( \mathbf { s } _ { t + 1 } | \mathbf { s } _ { t } , \mathbf { a } _ { t } \right) \tag{2} \]</span></p><p>更一般地，将策略 <span class="math inline">\(\pi\)</span> 下生成轨迹 <span class="math inline">\(\tau\)</span> 的概率表示为</p><p><span class="math display">\[P ( \tau | \pi ) = \rho _ { 1 } \left( s _ { 1 } \right) \prod _ { t = 0 } ^ { T  } P \left( s _ { t + 1 } | s _ { t } , a _ { t } \right) \pi \left( a _ { t } | s _ { t } \right) \tag{3}\]</span></p><p>​ 策略梯度方法的目标就是找到一组最佳的参数 <span class="math inline">\(\theta ^ { \star }\)</span> 来表示策略函数使得累计奖励的期望最大，即</p><p><span class="math display">\[\theta ^ { \star } = \arg \max _ { \theta } E _ { \tau \sim p _ { \theta } ( \tau ) } \left[ \sum _ { t } r \left( \mathbf { s } _ { t } , \mathbf { a } _ { t } \right) \right] \tag{4}\]</span></p><p>​ 令累积奖励为 <span class="math inline">\(R ( \tau ) = \sum _ { t = 1 } ^ { T } r \left( s _ { t } , a _ { t } \right)\)</span> ，设定优化目标 <span class="math inline">\(J\left( \pi _ { \theta } \right)\)</span> 优化策略参数使得奖励的期望值最大</p><p><span class="math display">\[J\left( \pi _ { \theta } \right) = \underset { \tau \sim \pi _ { \theta } } { \mathrm { E } } [ R ( \tau ) ]\tag{5} \]</span></p><p>对 <span class="math inline">\(J\left( \pi _ { \theta } \right)\)</span> 求梯度可得策略梯度 $_ { } J ( ) $ ，公式 (6) 的推导过程请参见<a href="https://spinningup.openai.com/en/latest/spinningup/rl_intro3.html#deriving-the-simplest-policy-gradient" target="_blank" rel="noopener">链接</a></p><p><span class="math display">\[\begin{aligned} \nabla _ { \theta } J ( \theta ) &amp;= \int \nabla _ { \theta } \pi _ { \theta } ( \tau ) r ( \tau ) d \tau \\&amp;= \int \pi _ { \theta } ( \tau ) \nabla _ { \theta } \log \pi _ { \theta } ( \tau ) r ( \tau ) d \tau \\ &amp;= E _ { \tau \sim \pi _ { \theta } ( \tau ) } \left[ \nabla _ { \theta } \log \pi _ { \theta } ( \tau ) r ( \tau ) \right]\end{aligned} \tag{6}\]</span></p><p>将策略 (1) 两边取 log 对数，然后带入梯度表达式 (6) ，推导策略梯度的公式请参考下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117080942.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>根据策略 <span class="math inline">\(\pi _ { \theta }\)</span> 生成 <span class="math inline">\(N\)</span> 条轨迹如图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117084618.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>利用上图 <span class="math inline">\(N\)</span> 条轨迹的经验平均对策略梯度进行逼近，有公式 (7) (8)</p><p><span class="math display">\[J ( \theta ) = E _ { \tau \sim p _ { \theta } ( \tau ) } \left[ \sum _ { t } r \left( \mathbf { s } _ { t } , \mathbf { a } _ { t } \right) \right] \approx \frac { 1 } { N } \sum _ { i } \sum _ { t } r \left( \mathbf { s } _ { i , t } , \mathbf { a } _ { i , t } \right) \tag{7}\]</span></p><p><span class="math display">\[\nabla _ { \theta } J ( \theta ) \approx \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \left( \sum _ { t = 1 } ^ { T } \nabla _ { \theta } \log \pi _ { \theta } \left( \mathbf { a } _ { i , t } | \mathbf { s } _ { i , t } \right) \right) \left( \sum _ { t = 1 } ^ { T } r \left( \mathbf { s } _ { i , t } , \mathbf { a } _ { i , t } \right) \right) \tag{8}\]</span></p><p>其中 <span class="math inline">\(N\)</span> 为轨迹的数量，<span class="math inline">\(T\)</span> 为一条轨迹的长度，假设已知策略 <span class="math inline">\(\pi _ { \theta }\)</span> ，那么就可以计算出策略的梯度 <span class="math inline">\(\nabla _ { \theta } \log \pi _ { \theta } ( a | s )\)</span>。另一方面，根据策略 <span class="math inline">\(\pi _ { \theta }\)</span> ，在仿真环境 <span class="math inline">\(E\)</span> 中生成 <span class="math inline">\(N\)</span> 条轨迹的数据，即可计算出 (8)，根据梯度上升 对参数 <span class="math inline">\(\theta\)</span> 进行一步更新，如公式 (9)</p><p><span class="math display">\[\theta \leftarrow \theta + \alpha \nabla _ { \theta } J ( \theta ) \tag{9}\]</span></p><p>总结下来就是：</p><ul><li>增加带来正激励的概率</li><li>减少带来负激励的概率</li></ul><p><img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117203920.png" width="60%/"></p><h2 id="策略梯度蒙特卡罗-reinforce-算法">策略梯度蒙特卡罗 REINFORCE 算法</h2><p>根据公式 (7) (8) (9) 可得<strong>蒙特卡罗 REINFORCE 算法</strong>流程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117091205.png" alt="公式" title>                </div>                <div class="image-caption">公式</div>            </figure><p>写成伪代码形式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117091717.png" alt="伪代码" title>                </div>                <div class="image-caption">伪代码</div>            </figure><h2 id="example-高斯策略梯度算法">Example: 高斯策略梯度算法</h2><p>策略属于概率分布，可以用神经网络来表示这种概率分布，输入状态 <span class="math inline">\(s\)</span> ，神经网络将 <span class="math inline">\(s\)</span> 映射成向量 <span class="math inline">\(μ\)</span>，然后网络输出概率 <span class="math inline">\(p ( a | \mu )\)</span> 和动作采样值 <span class="math inline">\(a \sim p ( a | \mu )\)</span>，令 <span class="math inline">\(r\)</span> 为 log 标准差。</p><p><span class="math display">\[\mathcal { N } \left( \text { mean } = \text { NeuralNet } \left( s ; \left\{ W _ { i } , b _ { i } \right\} _ { i = 1 } ^ { L } \right) , stdev = exp(r) \right)\]</span></p><p>其中 <span class="math inline">\(\mu = [ \text { mean, stdev } ]\)</span></p><p><img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190117204712.png"></p><p>在连续的运动空间中，通常使用<strong>高斯策略</strong>，假设方差为 <span class="math inline">\(\sigma ^ { 2 }\)</span> ，策略是高斯的，输入状态 <span class="math inline">\(s\)</span> 输出动作 <span class="math inline">\(a\)</span> 服从 <span class="math inline">\(a \sim \mathcal { N } \left( \mu ( s ) , \sigma ^ { 2 } \right)\)</span>，那么 log 策略梯度为</p><p><span class="math display">\[\nabla _ { \theta } \log \pi _ { \theta } ( s , a ) = \frac { ( a - \mu ( s ) ) \phi ( s ) } { \sigma ^ { 2 } }\tag{10}\]</span></p><p>在实际使用高斯策略时，用神经网络来表示，即令 <span class="math inline">\(f _ { neural\ network } \left( \mathbf { s } _ { t } \right) = \mu ( s _ t )\)</span>，那么策略 <span class="math inline">\(\pi _ \theta\)</span></p><p><span class="math display">\[\log \pi _ { \theta } \left( \mathbf { a } _ { t } | \mathbf { s } _ { t } \right) = - \frac { 1 } { 2 } \left\| f \left( \mathbf { s } _ { t } \right) - \mathbf { a } _ { t } \right\| _ { \Sigma } ^ { 2 } + const \tag{11}\]</span></p><p>策略的梯度</p><p><span class="math display">\[\nabla _ { \theta } \log \pi _ { \theta } \left( \mathbf { a } _ { t } | \mathbf { s } _ { t } \right) = - \frac { 1 } { 2 } \Sigma ^ { - 1 } \left( f \left( \mathbf { s } _ { t } \right) - \mathbf { a } _ { t } \right) \frac { d f } { d \theta } \tag{12}\]</span></p><p>然后反向传播，更新网络参数</p><p><span class="math display">\[- \frac { 1 } { 2 } \Sigma ^ { - 1 } \left( f \left( \mathbf { s } _ { t } \right) - \mathbf { a } _ { t } \right) \left( \sum _ { t } r \left( \mathbf { s } _ { t } , \mathbf { a } _ { t } \right) \right) \tag{13}\]</span></p><h2 id="参考链接">参考链接</h2><ul><li><a href="https://hadovanhasselt.files.wordpress.com/2016/01/pg1.pdf" target="_blank" rel="noopener">Lecture 8: Policy Gradient</a></li><li><a href="https://lilianweng.github.io/lil-log/2018/04/08/policy-gradient-algorithms.html" target="_blank" rel="noopener">Policy Gradient Algorithms</a></li><li><a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement Learning: An Introduction</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强化学习策略梯度算法&quot;&gt;强化学习:策略梯度算法&lt;/h1&gt;
&lt;h2 id=&quot;策略梯度的公式推导&quot;&gt;策略梯度的公式推导&lt;/h2&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbo
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Algorithm" scheme="http://thinkhard.tech/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MLPGaussianPolicy</title>
    <link href="http://thinkhard.tech/2019/01/14/MLPGaussianPolicy/"/>
    <id>http://thinkhard.tech/2019/01/14/MLPGaussianPolicy/</id>
    <published>2019-01-14T11:42:41.000Z</published>
    <updated>2019-04-04T10:10:23.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mlp-gaussian-policy">MLP Gaussian policy</h1><p>Looks like a Gaussian policy whose mean and std are outputs of a neural network.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/tuibot/ImgBed/master/img/20190114195919.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="参考文献">参考文献</h2><ul><li><a href="https://arxiv.org/pdf/1502.05477.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.05477.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mlp-gaussian-policy&quot;&gt;MLP Gaussian policy&lt;/h1&gt;
&lt;p&gt;Looks like a Gaussian policy whose mean and std are outputs of a neural network.&lt;/p
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Reinforcement Learning" scheme="http://thinkhard.tech/tags/Reinforcement-Learning/"/>
    
      <category term="Tensorflow" scheme="http://thinkhard.tech/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>强化学习随机策略之高斯似然数原理与代码实现</title>
    <link href="http://thinkhard.tech/2019/01/12/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5%E4%B9%8B%E9%AB%98%E6%96%AF%E4%BC%BC%E7%84%B6%E6%95%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://thinkhard.tech/2019/01/12/强化学习随机策略之高斯似然数原理与代码实现/</id>
    <published>2019-01-12T06:47:50.000Z</published>
    <updated>2019-04-04T10:10:23.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习随机策略之高斯似然数原理与代码实现">强化学习随机策略之高斯似然数原理与代码实现</h1><h2 id="一原理介绍">一、原理介绍</h2><p>使用随机策略有两个关键点</p><ul><li>从策略当中进行采样，获得动作 <span class="math inline">\(a\)</span> (Action)</li><li>计算特定动作的似然数 <span class="math inline">\(\log \pi _ { \theta } ( a | s )\)</span></li></ul><h3 id="什么是多元高斯分布">什么是多元高斯分布？</h3><p>在多元高斯分布中，当协方差矩阵 <span class="math inline">\(\Sigma\)</span> 只有在对角元素非零，而其余元素为 0 时，成为对角高斯分布。 多元高斯分布（Multivariate Gaussian Distribution）是一元高斯分布的在向量形式上的推广，其中向量 <span class="math inline">\(X = \left[ X _ { 1 } , X _ { 2 } , \ldots , X _ { n } \right] ^ { T }\)</span> 的均值为 <span class="math inline">\(\mu \in \mathbf { R } ^ { n }\)</span> ，协方差矩阵为 <span class="math inline">\(\Sigma \in S ^ { n }\)</span> ，概率密度函数表示为</p><p><span class="math display">\[p ( x ; \mu , \Sigma ) = \frac { 1 } { ( 2 \pi ) ^ { n / 2 } | \Sigma | ^ { 1 / 2 } } \exp \left( - \frac { 1 } { 2 } ( x - \mu ) ^ { T } \Sigma ^ { - 1 } ( x - \mu ) \right)\]</span></p><p>例如二元高斯多元分布可以如图所示</p><p><img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fz3n193kb2j21390k2n6d.jpg" width="40%">.</p><p>对于一对随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> ，它们的协方差矩阵写作</p><p><span class="math display">\[\operatorname { Cov } [ X , Y ] = E [ ( X - E [ X ] ) ( Y - E [ Y ] ) ] = E [ X Y ] - E [ X ] E [ Y ]\]</span></p><p>对于多个变量的问题，用协方差矩阵 <span class="math inline">\(\Sigma \in S ^ { n }\)</span> 来表示各个变量之间的相关性，有</p><p><span class="math display">\[\Sigma = E \left[ ( X - \mu ) ( X - \mu ) ^ { T } \right] = E \left[ X X ^ { T } \right] - \mu \mu ^ { T }\]</span></p><h3 id="对角多元高斯分布">对角多元高斯分布</h3><p>特殊地，当 N 个随机变量 <span class="math inline">\(X = \left[ X _ { 1 } , X _ { 2 } , \ldots , X _ { n } \right] ^ { T }\)</span> 为各自独立的高斯随机变量时，协方差矩阵为对角阵，即</p><p><span class="math display">\[\Sigma = \operatorname { diag } \left( \sigma _ { 1 } ^ { 2 } , \sigma _ { 2 } ^ { 2 } , \ldots , \sigma _ { n } ^ { 2 } \right)\]</span></p><h3 id="对角高斯策略-diagonal-gaussian-policies">对角高斯策略 Diagonal Gaussian Policies</h3><p>由于标准差的公式 <span class="math inline">\(\sigma = \sqrt { \frac { 1 } { N } \sum _ { i = 1 } ^ { N } \left( x _ { i } - \mu \right) ^ { 2 } }\)</span> 可知 <span class="math inline">\(\sigma\)</span> 始终大于等于 0 ，对标准差取 <code>log</code> 对数，可以将标准差映射到 <span class="math inline">\(( - \infty , \infty )\)</span>，这样更有利于神经网络的训练。</p><ul><li><p><strong>采样</strong>：假设已知动作(Action) 的均值 <span class="math inline">\(\mu _ { \theta } ( s )\)</span> 和标准差 <span class="math inline">\(\sigma _ { \theta } ( s )\)</span> ，引入服从 <span class="math inline">\(( z \sim \mathcal { N } ( 0 , I ) )\)</span> 分布的噪声 <span class="math inline">\(z\)</span> ，下一步的动作采样表示为 <span class="math display">\[a = \mu _ { \theta } ( s ) + \sigma _ { \theta } ( s ) \odot z\]</span> 其中 <span class="math inline">\(\odot\)</span> 表示两个向量之间的内积。</p></li><li><p><strong>似然数</strong>：当均值为 <span class="math inline">\(\mu = \mu _ { \theta } ( s )\)</span> ，标准差为 <span class="math inline">\(\sigma = \sigma _ { \theta } ( s )\)</span> 的 <span class="math inline">\(k-\)</span>维的动作 <span class="math inline">\(a\)</span> 的似然数表示为 <span class="math display">\[\log \pi _ { \theta } ( a | s ) = - \frac { 1 } { 2 } \left( \sum _ { i = 1 } ^ { k } \left( \frac { \left( a _ { i } - \mu _ { i } \right) ^ { 2 } } { \sigma _ { i } ^ { 2 } } + 2 \log \sigma _ { i } \right) + k \log 2 \pi \right)\]</span></p></li></ul><h2 id="二代码实现">二、代码实现</h2><p><strong>要求</strong> - 输入: 样本 <code>x</code>，对角高斯分布的均值和标准差 - 输出：样本 <code>x</code> 的似然数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">EPS = <span class="number">1e-8</span></span><br></pre></td></tr></table></figure><p>根据上一节，似然数公式，理解公式后就很容易写出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my solution</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_gaussian_likelihood</span><span class="params">(x, mu, log_std)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: Tensor with shape [batch, dim]</span></span><br><span class="line"><span class="string">        mu: Tensor with shape [batch, dim]</span></span><br><span class="line"><span class="string">        log_std: Tensor with shape [batch, dim] or [dim]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        Tensor with shape [batch]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#######################</span></span><br><span class="line">    <span class="comment">#                     #</span></span><br><span class="line">    <span class="comment">#   YOUR CODE HERE    #</span></span><br><span class="line">    <span class="comment">#                     #</span></span><br><span class="line">    <span class="comment">#######################</span></span><br><span class="line">    std = tf.exp(log_std)</span><br><span class="line">    ans = ((x - mu) / std)**<span class="number">2</span> + <span class="number">2</span> * log_std + np.log(<span class="number">2</span> * np.pi)</span><br><span class="line">    ans = <span class="number">-0.5</span> * ans</span><br><span class="line">    <span class="comment"># https://www.tensorflow.org/api_docs/python/tf/math/reduce_sum</span></span><br><span class="line">    sum_ans = tf.reduce_sum(ans, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_ans</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># standard solution</span></span><br><span class="line"><span class="comment"># 代码来自 spinup/exercises/problem_set_1_solutions/exercise1_2_soln.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ans_gaussian_likelihood</span><span class="params">(x, mu, log_std)</span>:</span></span><br><span class="line">    pre_sum = <span class="number">-0.5</span> * (((x-mu)/(tf.exp(log_std)+EPS))**<span class="number">2</span> + <span class="number">2</span>*log_std + np.log(<span class="number">2</span>*np.pi))</span><br><span class="line">    <span class="keyword">return</span> tf.reduce_sum(pre_sum, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Run this file to verify your solution.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    sess = tf.Session()</span><br><span class="line"></span><br><span class="line">    dim = <span class="number">10</span></span><br><span class="line">    x = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, dim))</span><br><span class="line">    mu = tf.placeholder(tf.float32, shape=(<span class="literal">None</span>, dim))</span><br><span class="line">    log_std = tf.placeholder(tf.float32, shape=(dim,))</span><br><span class="line"></span><br><span class="line">    your_gaussian_likelihood = my_gaussian_likelihood(x, mu, log_std)</span><br><span class="line">    true_gaussian_likelihood = ans_gaussian_likelihood(x, mu, log_std)</span><br><span class="line"></span><br><span class="line">    batch_size = <span class="number">32</span></span><br><span class="line">    feed_dict = &#123;x: np.random.rand(batch_size, dim),</span><br><span class="line">                 mu: np.random.rand(batch_size, dim),</span><br><span class="line">                 log_std: np.random.rand(dim)&#125;</span><br><span class="line"></span><br><span class="line">    your_result, true_result = sess.run([your_gaussian_likelihood, true_gaussian_likelihood],</span><br><span class="line">                                        feed_dict=feed_dict)</span><br><span class="line"></span><br><span class="line">    correct = np.allclose(your_result, true_result)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Your answer is"</span>, correct)</span><br></pre></td></tr></table></figure><pre><code>Your answer is True</code></pre><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://spinningup.openai.com/en/latest/spinningup/rl_intro.html#stochastic-policies" target="_blank" rel="noopener">https://spinningup.openai.com/en/latest/spinningup/rl_intro.html#stochastic-policies</a></p></li><li><p><a href="https://www.tensorflow.org/api_docs/python/tf/math/reduce_sum" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf/math/reduce_sum</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强化学习随机策略之高斯似然数原理与代码实现&quot;&gt;强化学习随机策略之高斯似然数原理与代码实现&lt;/h1&gt;
&lt;h2 id=&quot;一原理介绍&quot;&gt;一、原理介绍&lt;/h2&gt;
&lt;p&gt;使用随机策略有两个关键点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从策略当中进行采样，获得动作 &lt;span class
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Reinforcement Learning" scheme="http://thinkhard.tech/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>每个会做饭的人都是人生赢家</title>
    <link href="http://thinkhard.tech/2019/01/11/%E6%AF%8F%E4%B8%AA%E4%BC%9A%E5%81%9A%E9%A5%AD%E7%9A%84%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%BA%E7%94%9F%E8%B5%A2%E5%AE%B6/"/>
    <id>http://thinkhard.tech/2019/01/11/每个会做饭的人都是人生赢家/</id>
    <published>2019-01-11T13:19:55.000Z</published>
    <updated>2019-04-04T10:10:23.774Z</updated>
    
    <content type="html"><![CDATA[<p>摘自 《会做饭的，都是人生赢家》</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不紧不慢地做一顿好吃的饭菜，</span><br><span class="line">是一场可以避世与收获宁静的禅修；</span><br><span class="line">而爱做饭、会做饭的人，</span><br><span class="line">也可以称作是有信仰的人。</span><br><span class="line">这样的人，生命中会少一些波折。</span><br><span class="line">单身的时候，没那么多顾影自怜，</span><br><span class="line">结婚以后，也能好好说话。</span><br><span class="line">毕竟，谁舍得在一锅香喷喷、热腾腾的萝卜牛腩面前大动干戈？</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘自 《会做饭的，都是人生赢家》&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Alfred-Gitlab-Workflow</title>
    <link href="http://thinkhard.tech/2018/10/12/Alfred-Gitlab-Workflow/"/>
    <id>http://thinkhard.tech/2018/10/12/Alfred-Gitlab-Workflow/</id>
    <published>2018-10-12T00:31:33.000Z</published>
    <updated>2019-10-31T01:54:01.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="alfred-gitlab-workflowgitlab-快速浏览工具">Alfred Gitlab Workflow：Gitlab 快速浏览工具</h1><ul><li><p><strong>GitLab</strong> 是一个类似于 GitHub 的开源源码托管服务，除了代码托管外，Gitlab 还具备了像 Issue、Merge Requests 等软件协作功能。Gitlab 有社区版和企业版，能够被部署到私有服务器上，经常在开发团队中被使用。</p></li><li><p><strong>Alfred</strong> 是 MacOS 下面相当知名的 App 快速启动工具，最迷人的地方在于通过关键词快速触发一系列操作，可以将大部分重复机械的操作写成 Workflow，极大地提升效率。</p></li></ul><p>在我日常使用 Gitlab 过程中，在网页中点击频率最高的莫过于<strong>搜索、Issue、Merge Requests、Todo</strong> 这几个控件了，它们长这样</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw5629eqelj20ca013q2s.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是不会“<strong>偷懒</strong>”的程序员都不是好程序员，有时候连 Chrome 都不愿意自己伸手点开，所以对着 Python Alfred Wokflow 库文档，写了一个小插件</p><h2 id="一安装">一、安装</h2><ul><li>依赖于 <a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred3</a></li><li>下载 <a href="https://github.com/wangshub/Alfred-Gitlab-Tool/releases" target="_blank" rel="noopener">Gitlab workflow release</a></li><li>点击安装</li></ul><h2 id="二配置-url-和-token">二、配置 url 和 Token</h2><ul><li><code>glurl</code>：设置 Gitlab 的 url</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw4431rk7cj20fl035dg6.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><code>gltoken</code>：设置 Gitlab 的 Token</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw443ny2tpj20fl03874g.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="三功能">三、功能</h2><ul><li><code>glp</code>：快速浏览和模糊搜索 Gitlab 项目</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw444d697jj20fn0dhq58.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><code>gli</code>：快速搜索 Gitlab issue</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw44g9k7ewj20fn09k761.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><code>glm</code>：快速打开分配给你的 Merge Requests</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw445iymvkj20fo05vaav.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><code>gltodo</code>：在默认浏览器中打开 Todo 页面</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fw44jtco12j20fk03baa6.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="四项目地址">四、项目地址</h2><ul><li>MIT @ <a href="https://github.com/wangshub" target="_blank" rel="noopener">神奇的战士</a></li><li><a href="https://github.com/wangshub/Alfred-Gitlab-Tool" target="_blank" rel="noopener">https://github.com/wangshub/Alfred-Gitlab-Tool</a></li></ul><h2 id="最后">最后</h2><p>希望这个工具可以为你剩下一点时间撸猫 ~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;alfred-gitlab-workflowgitlab-快速浏览工具&quot;&gt;Alfred Gitlab Workflow：Gitlab 快速浏览工具&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GitLab&lt;/strong&gt; 是一个类似于 GitHub 的开源
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用Python写Alfred3插件</title>
    <link href="http://thinkhard.tech/2018/09/30/%E7%94%A8Python%E5%86%99Alfred3%E6%8F%92%E4%BB%B6/"/>
    <id>http://thinkhard.tech/2018/09/30/用Python写Alfred3插件/</id>
    <published>2018-09-30T10:18:16.000Z</published>
    <updated>2019-10-31T02:06:34.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-python-写-alfred3-workflow-插件一个最小示例">用 Python 写 Alfred3 workflow 插件，一个最小示例</h1><p>以前一直在使用 Cerebro 作为效率工具(开源免费)，但是 Cerebro 原作者似乎很久没有更新，今天抱着试一试的心态用了一把 Alfred 才发现，<strong>哎哟握草</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fvrqrg2gbpj209q08h40i.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Alfred 优化了快速启动与搜索的功能，比 Cerebro 更加丝滑流畅，还引入了 Workflows 这个强大的扩展功能，用户可以用自己熟悉的语言比如 python、JavaScript 和 Php 等来写 Wokflow。因此赋予了 Alfred 无限的可能性。</p><p>我查阅了一下 <a href="https://www.alfredapp.com/help/workflows/" target="_blank" rel="noopener">Alfred 的文档</a>，发现添加一个 Workflow 插件竟是如此便捷。</p><h2 id="背景">背景</h2><p>自己平时喜欢浏览 HackerNews，所以希望在 Alfred 里面快速浏览今天的热门新闻，搜了一下现成的 Alfred 的 HackerNews 插件，都十分老旧，好像都不能正常工作。照着 Alfred 官方文档，用 Python 简单写了个 <a href="https://github.com/wangshub/Alfred-HackerNews" target="_blank" rel="noopener">Alfred-HackerNews</a>，通过请求 API 获取 HackerNews 新闻。</p><h2 id="使用截图">使用截图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/wangshub/Alfred-HackerNews/master/pic/hn_screen.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="步骤">步骤</h2><h3 id="创建一个新-workflow">创建一个新 Workflow</h3><ul><li>新建步骤推荐阅读: <a href="http://www.deanishe.net/alfred-workflow/tutorial_1.html#creating-a-new-workflow" target="_blank" rel="noopener">creating-a-new-workflow</a></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fvrr8c47v5j20uk0ia794.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>设置关键词触发 Python 脚本，如图所示，当输入 <code>hn</code> 时，就可以执行 <code>/usr/bin/python hn.py</code> 这条 shell 指令，<code>hn.py</code> 就是需要编辑的 Python 文件。在这个 Workflow 中由于没有输入参数，所以我设置了 <code>No Argument</code>。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fvrrlzz4n1j20lq0hs400.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="使用-alfred-workflow-库">使用 Alfred-Workflow 库</h3><p>流程创建完毕后，就需要对代码进行编辑</p><ul><li><p>找到 Workflow 源码路径: 鼠标右键 <code>Hacker-news</code>，选择 <strong>Show in Finder</strong>，找到源码</p></li><li><p>请求 <a href="https://api.hnpwa.com/v0" target="_blank" rel="noopener">api.hnpwa.com/v0</a> 获取 HackerNews 数据</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_top_news</span><span class="params">()</span>:</span></span><br><span class="line">    base_url = <span class="string">'https://api.hnpwa.com/v0/&#123;name&#125;/&#123;page&#125;.json'</span></span><br><span class="line">    max_pages = <span class="number">15</span></span><br><span class="line">    name = <span class="string">'news'</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, max_pages):</span><br><span class="line">        url = base_url.format(name=name, page=page)</span><br><span class="line">        req = web.get(url)</span><br><span class="line">        req.raise_for_status()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(req.json()) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        result = result + req.json()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p></li><li><p>将数据封装成 <code>xml</code> 格式返回给 Alfred <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    posts = wf.cached_data(<span class="string">'posts'</span>, get_top_news, max_age=<span class="number">60</span>*<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Loop through the returned posts and add an item for each to</span></span><br><span class="line">    <span class="comment"># the list of results for Alfred</span></span><br><span class="line">    <span class="keyword">for</span> post <span class="keyword">in</span> posts:</span><br><span class="line">        subtitle = <span class="string">"points: &#123;points&#125; | user: &#123;user&#125; | &#123;time_ago&#125; | comments:&#123;comments_count&#125; | &#123;url&#125;"</span>.format(</span><br><span class="line">            points=post[<span class="string">'points'</span>],</span><br><span class="line">            user=post[<span class="string">'user'</span>],</span><br><span class="line">            time_ago=post[<span class="string">'time_ago'</span>],</span><br><span class="line">            comments_count=post[<span class="string">'comments_count'</span>],</span><br><span class="line">            url=post[<span class="string">'url'</span>]</span><br><span class="line">        )</span><br><span class="line">        wf.add_item(title=post[<span class="string">'title'</span>],</span><br><span class="line">                    subtitle=subtitle,</span><br><span class="line">                    arg=post[<span class="string">'url'</span>],</span><br><span class="line">                    valid=<span class="literal">True</span>,</span><br><span class="line">                    icon=<span class="string">'./icon.png'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send the results to Alfred as XML</span></span><br><span class="line">    wf.send_feedback()</span><br></pre></td></tr></table></figure></p></li><li><p>为了防止大量请求 API 造成服务器压力，也为了更快地显示结果，将数据进行缓存 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">posts = wf.cached_data(<span class="string">'posts'</span>, get_top_news, max_age=<span class="number">60</span>*<span class="number">60</span>)</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="导出-.workflow">导出 *.workflow</h3><p>右键 <code>Hacker-news</code> 将 workflow 导出为 <code>hacker-news.alfredworkflow</code> 格式，就可以发布出去啦</p><h2 id="总结">总结</h2><ul><li>如果使用 Python 第三方库，需要 pip 安装到本地路径</li><li>出于兼容性的考虑，Alfred-Workflow 暂时只支持 Python 2，有些小小遗憾；</li></ul><h2 id="示例代码和-workflow-下载地址">示例代码和 Workflow 下载地址</h2><ul><li><a href="https://github.com/wangshub/Alfred-HackerNews" target="_blank" rel="noopener">https://github.com/wangshub/Alfred-HackerNews</a></li><li>MIT@<a href="https://github.com/wangshub/Alfred-HackerNews" target="_blank" rel="noopener">神奇的战士</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用-python-写-alfred3-workflow-插件一个最小示例&quot;&gt;用 Python 写 Alfred3 workflow 插件，一个最小示例&lt;/h1&gt;
&lt;p&gt;以前一直在使用 Cerebro 作为效率工具(开源免费)，但是 Cerebro 原作者似乎很久没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在roboschool中控制Atlas</title>
    <link href="http://thinkhard.tech/2018/09/20/%E5%9C%A8roboschool%E4%B8%AD%E6%8E%A7%E5%88%B6Atlas/"/>
    <id>http://thinkhard.tech/2018/09/20/在roboschool中控制Atlas/</id>
    <published>2018-09-20T09:28:18.000Z</published>
    <updated>2019-04-04T10:10:23.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-python-在-openai-的-roboschool-中控制-atlas-机器人">利用 Python 在 OpenAI 的 roboschool 中控制 Atlas 机器人</h1><blockquote><p>作者：神奇的战士 Blog: http://thinkhard.tech/</p></blockquote><h2 id="背景介绍">背景介绍</h2><ul><li><strong>Atlas</strong>: Atlas 机器人是一个双足人形机器人，由鼎鼎大名的美国波士顿动力公司为主开发，身高 1.75 米，体重 82kg，它的出现将人形机器人的发展带到了更高的高度。目前可以完成行走、跑步和翻跟头等一系列复杂的动作。作为机器人当中的贵族，价格自然不菲 T_T (更何况还买不到...)。所以只能通过<strong>仿真软件</strong>在里面过下干瘾。</li><li><strong>Roboschool</strong>: Roboschool 是基于 OpenAI Gym 强化学习仿真包的物理仿真引擎。由于 MuJuCo 不开源且收费，所以 OpenAI 的大佬们将 Roboschool 作为 MuJuCo 的替代品。可以在一个场景当中训练多个 Agent 并且完成一挑战任务。</li></ul><h2 id="软件环境安装">软件环境安装</h2><ul><li><a href="https://github.com/openai/roboschool" target="_blank" rel="noopener">Rooboschool</a></li><li><a href="https://github.com/openai/gym" target="_blank" rel="noopener">Gym</a></li></ul><h2 id="示例代码">示例代码</h2><p>在 2017 年 7 月 17 号，Roboschool 发布了 Version 1.1 版本，其中导入了 Atlat 机器人模型，相关新闻可见 <a href="https://github.com/openai/roboschool#news" target="_blank" rel="noopener">NEWS</a></p><p>所以在安装好环境后，可以从 <a href="https://github.com/openai/roboschool/blob/master/agent_zoo/RoboschoolAtlasForwardWalk_v1_2017jul.py" target="_blank" rel="noopener">RoboschoolAtlasForwardWalk_v1_2017jul.py</a> 中找到控制 Atlas 前进走路的源码。</p><ul><li><a href="https://github.com/openai/roboschool/blob/master/agent_zoo/RoboschoolAtlasForwardWalk_v1_2017jul.py" target="_blank" rel="noopener">RoboschoolAtlasForwardWalk_v1_2017jul.py</a></li></ul><h2 id="仿真">仿真</h2><p>Python 运行代码，由于在 Train 的时候，没有对机器人上肢运动进行约束和优化，只关注了下肢的移动，最终训练的结果有点辣眼睛，我们可以看到一段魔性嚣张的步伐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 RoboschoolAtlasForwardWalk_v1_2017jul.py</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./picture/atlas_run.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>鼠标左键 ： 旋转镜头</li><li>鼠标右键 ： 镜头平移</li><li>按键 <code>F1</code> : 开/关 慢动作</li><li>按键 <code>F2</code> : 隐藏/显示 仿真步数和累积 Rewards</li><li>按键 <code>F3</code> : 隐藏/显示 Action 和 Observation</li></ul><p>在 <a href="https://zhuanlan.zhihu.com/p/40673328" target="_blank" rel="noopener">机器人强化学习之使用 OpenAI Gym 教程与笔记</a> 中介绍过使用导入 Gym 模型和查看 Observation 和 Action 的相关参数，对于 Atlas 也同样适用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> roboschool</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">"RoboschoolAtlasForwardWalk-v1"</span>)</span><br><span class="line">print(<span class="string">'action_space = '</span>, env.action_space)</span><br><span class="line">print(<span class="string">'observation_space = '</span>, env.observation_space)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">action_space = Box(30,)</span><br><span class="line">observation_space = Box(70,)</span><br></pre></td></tr></table></figure><p>从 <code>env.action_space</code> 和 <code>env.observation_space</code> 可知 Action 维度为 30，Observation 维度为 70。</p><ul><li>Action 可以理解为机器人有 30 个自由度，可以通过 PD 控制器控制关节角度；</li><li>Observation 为当前环境的观测向量；</li></ul><p>至于Atlas 机器人 Action 和 Observation 详细解释，在 Roboschool 的 Wiki 中没有相关说明，OpenAI 的开发者建议用户靠<strong>猜</strong>的方式来确定 :)。 确定方式为</p><ol type="1"><li>修改 Roboschool 源码，将 <a href="https://github.com/openai/roboschool/blob/master/roboschool/gym_atlas.py#L21" target="_blank" rel="noopener">gym_atlas.py</a> 重力修改为 0</li><li>按照排除法，控制变量 Action，然后 <code>env.step(action)</code> ，分别记下向量每个元素对应的自由度关节。</li></ol><h2 id="代码说明">代码说明</h2><p>Roboschool 开发者解释到由于强化学习训练 Atlas 走路的代码太杂乱了，所以暂时没有 Train 的代码，所以求人不如求己，后面得自己撸代码 ~ 总体思路是获得 weight 矩阵，即最佳 Policy，输入当前观测向量 Observation 获得下一步的 Action 向量来控制 Atlas 行走。</p><h2 id="总结">总结</h2><ul><li>Roboschool 这个项目适合验证一些简单的强化学习任务，对于新引入的模型支持得还不太友好。</li><li>基本上没有什么成体系的说明文档，所以需要靠多阅读 Roboschool 和 Gym 的 Python 源码来使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用-python-在-openai-的-roboschool-中控制-atlas-机器人&quot;&gt;利用 Python 在 OpenAI 的 roboschool 中控制 Atlas 机器人&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：神奇的战士 Blog: htt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>将 Kindle 转换成文艺电子时钟</title>
    <link href="http://thinkhard.tech/2018/08/05/turn-kindle-to-electron-clock/"/>
    <id>http://thinkhard.tech/2018/08/05/turn-kindle-to-electron-clock/</id>
    <published>2018-08-05T02:30:01.000Z</published>
    <updated>2019-04-04T10:10:23.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="破解-kindle改造成文艺电子时钟">破解 Kindle，改造成文艺电子时钟</h1><h2 id="前言">前言</h2><h2 id="原材料准备">原材料准备</h2><h3 id="硬件">硬件</h3><ul><li>亚马逊 Kindle 6 inch</li><li>Micro USB 线</li></ul><h3 id="软件">软件</h3><ul><li>SSH 工具</li></ul><h2 id="破解-kindle">破解 Kindle</h2><p>为了让 Kindle 显示我们想要的内容，需要能够登录进 Kindle 系统并且修改系统文件与配置。所以需要将 Kindle 进行<code>越狱</code>操作。</p><ul><li><p>越狱说明请见 <a href="https://wiki.mobileread.com/wiki/Kindle_Screen_Saver_Hack_for_all_2.x,_3.x_%26_4.x_Kindles" target="_blank" rel="noopener">Kindle Screen Saver Hack</a></p></li><li><p>Kindle 上的软件安装包请见 <a href="https://www.mobileread.com/forums/showthread.php?t=88004" target="_blank" rel="noopener">software custom</a></p></li></ul><h2 id="参考链接">参考链接</h2><ul><li><a href="https://www.instructables.com/id/Literary-Clock-Made-From-E-reader/" target="_blank" rel="noopener">https://www.instructables.com/id/Literary-Clock-Made-From-E-reader/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;破解-kindle改造成文艺电子时钟&quot;&gt;破解 Kindle，改造成文艺电子时钟&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;h2 id=&quot;原材料准备&quot;&gt;原材料准备&lt;/h2&gt;
&lt;h3 id=&quot;硬件&quot;&gt;硬件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;亚马逊 Kindle 6
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器人强化学习之使用 OpenAI Gym 教程与笔记</title>
    <link href="http://thinkhard.tech/2018/07/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BD%BF%E7%94%A8%20OpenAI%20Gym%20%E6%95%99%E7%A8%8B%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
    <id>http://thinkhard.tech/2018/07/27/机器人强化学习之使用 OpenAI Gym 教程与笔记/</id>
    <published>2018-07-27T02:34:40.000Z</published>
    <updated>2019-04-04T10:10:23.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器人强化学习之使用-openai-gym-教程与笔记">机器人强化学习之使用 OpenAI Gym 教程与笔记</h1><blockquote><p>除了试图直接去建立一个可以模拟成人大脑的程序之外， 为什么不试图建立一个可以模拟小孩大脑的程序呢?如果它接 受适当的教育，就会获得成人的大脑。 — 阿兰·图灵</p></blockquote><h2 id="介绍">介绍</h2><p>强化学习 (Reinforcement learning) 是机器学习的一个子领域用于制定决策和运动自由度控制。强化学习主要研究在复杂未知的环境中，智体(agent)实现某个目标。强化学习最引人入胜的两个特点是</p><ul><li><p><strong>强化学习非常通用，可以用来解决需要作出一些列决策的所有问题：</strong>例如，训练机器人跑步和弹跳，制定商品价格和库存管理，玩 Atari 游戏和棋盘游戏等等。</p></li><li><p><strong>强化学习已经可以在许多复杂的环境中取得较好的实验结果：</strong>例如 Deep RL 的 Alpha Go等</p></li></ul><p><a href="https://gym.openai.com/docs/" target="_blank" rel="noopener">Gym</a> 是一个研究和开发强化学习相关算法的仿真平台。</p><ul><li>无需智体先验知识；</li><li>兼容常见的数值运算库如 TensorFlow、Theano 等</li></ul><h2 id="gym-的一个最小例子-cartpole-v0">Gym 的一个最小例子 <code>CartPole-v0</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">'CartPole-v0'</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    env.render()</span><br><span class="line">    env.step(env.action_space.sample()) <span class="comment"># take a random action</span></span><br></pre></td></tr></table></figure><p><strong>运行效果</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1ftmzl7ss9aj20a804a0sj.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>至此，第一个 Hello world 就算正式地跑起来了！</p><h2 id="观测observations">观测(Observations)</h2><p>在第一个小栗子中，使用了 <code>env.step()</code> 函数来对每一步进行仿真，在 Gym 中，<code>env.step()</code> 会返回 4 个参数：</p><ul><li><p><strong>观测</strong> Observation (Object)：当前 step 执行后，环境的观测(类型为对象)。例如，从相机获取的像素点，机器人各个关节的角度或棋盘游戏当前的状态等；</p></li><li><p><strong>奖励</strong> Reward (Float): 执行上一步动作(action)后，智体(agent)获得的奖励(浮点类型)，不同的环境中奖励值变化范围也不相同，但是强化学习的目标就是使得总奖励值最大；</p></li><li><p><strong>完成</strong> Done (Boolen): 表示是否需要将环境重置 <code>env.reset</code>。大多数情况下，当 <code>Done</code> 为 <code>True</code> 时，就表明当前回合(episode)或者试验(tial)结束。例如当机器人摔倒或者掉出台面，就应当终止当前回合进行重置(reset);</p></li><li><p><strong>信息</strong> Info (Dict): 针对调试过程的诊断信息。在标准的智体仿真评估当中不会使用到这个 info，具体用到的时候再说。</p></li></ul><p>总结来说，这就是一个强化学习的基本流程，在每个时间点上，智体执行 action，环境返回上一次 action 的观测和奖励，用图表示为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1ftn0jm54q0j20gm082t8y.jpg" alt="智体与环境交互" title>                </div>                <div class="image-caption">智体与环境交互</div>            </figure><p>在 Gym 仿真中，每一次回合开始，需要先执行 <code>reset()</code> 函数，返回初始观测信息，然后根据标志位 <code>done</code> 的状态，来决定是否进行下一次回合。代码表示为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">'CartPole-v0'</span>)</span><br><span class="line"><span class="keyword">for</span> i_episode <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    observation = env.reset()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        env.render()</span><br><span class="line">        print(observation)</span><br><span class="line">        action = env.action_space.sample()</span><br><span class="line">        observation, reward, done, info = env.step(action)</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            print(<span class="string">"Episode finished after &#123;&#125; timesteps"</span>.format(t+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>仿真截图如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fto3j0pf0yj20go0bqdfu.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每次 <code>action</code> 前，将上一次 <code>observation</code> 打印，可以得到打印日志如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[ 0.0349103   1.14771978 -0.03934506 -1.64631971]</span><br><span class="line">[ 0.0578647   1.34327926 -0.07227145 -1.95099638]</span><br><span class="line">[ 0.08473028  1.14899616 -0.11129138 -1.68156178]</span><br><span class="line">[ 0.1077102   0.95532555 -0.14492261 -1.42550525]</span><br><span class="line">[ 0.12681672  1.15191062 -0.17343272 -1.75974995]</span><br><span class="line">[ 0.14985493  0.95912509 -0.20862772 -1.52564382]</span><br><span class="line">Episode finished after 16 timesteps</span><br><span class="line">[ 0.03628829 -0.03189712 -0.01997778  0.02529094]</span><br><span class="line">[ 0.03565035 -0.22672696 -0.01947196  0.31160431]</span><br><span class="line">[ 0.03111581 -0.42156616 -0.01323988  0.59808332]</span><br><span class="line">[ 0.02268449 -0.61650037 -0.00127821  0.8865666 ]</span><br></pre></td></tr></table></figure><h2 id="空间spaces">空间（Spaces）</h2><p>在前面的两个小栗子中，每次执行的动作(action)都是从环境动作空间中随机进行选取的，但是这些动作 (action) 是什么?在 Gym 的仿真环境中，有运动空间 <code>action_space</code> 和观测空间 <code>observation_space</code> 两个指标，程序中被定义为 <code>Space</code> 类型，用于描述有效的运动和观测的格式和范围。下面是一个代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line">env = gym.make(<span class="string">'CartPole-v0'</span>)</span><br><span class="line">print(env.action_space)</span><br><span class="line"><span class="comment">#&gt; Discrete(2)</span></span><br><span class="line">print(env.observation_space)</span><br><span class="line"><span class="comment">#&gt; Box(4,)</span></span><br></pre></td></tr></table></figure><pre><code>[33mWARN: gym.spaces.Box autodetected dtype as &lt;class &#39;numpy.float32&#39;&gt;. Please provide explicit dtype.[0mDiscrete(2)Box(4,)</code></pre><p>从程序运行结果来看</p><ul><li><p><code>action_space</code> 是一个离散 <code>Discrete</code> 类型，从 <a href="https://github.com/openai/gym/blob/master/gym/spaces/discrete.py" target="_blank" rel="noopener">discrete.py</a> 源码可知，范围是一个 <code>{0,1,...,n-1}</code> 长度为 <code>n</code> 的非负整数集合，在 <code>CartPole-v0</code> 例子中，动作空间表示为 <code>{0,1}</code>。</p></li><li><p><code>observation_space</code> 是一个 <code>Box</code> 类型，从 <a href="https://github.com/openai/gym/blob/master/gym/spaces/box.py" target="_blank" rel="noopener">box.py</a> 源码可知，表示一个 <code>n</code> 维的盒子，所以在上一节打印出来的 <code>observation</code> 是一个长度为 4 的数组。数组中的每个元素都具有上下界。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(env.observation_space.high)</span><br><span class="line">print(env.observation_space.low)</span><br></pre></td></tr></table></figure><pre><code>[4.8000002e+00 3.4028235e+38 4.1887903e-01 3.4028235e+38][-4.8000002e+00 -3.4028235e+38 -4.1887903e-01 -3.4028235e+38]</code></pre><p>利用运动空间和观测空间的定义和范围，可以将代码写得更加通用。在许多仿真环境中，<code>Box</code> 和 <code>Discrete</code> 是最常见的空间描述，在智体每次执行动作时，都属于这些空间范围内，代码示例为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym <span class="keyword">import</span> spaces</span><br><span class="line">space = spaces.Discrete(<span class="number">8</span>) <span class="comment"># Set with 8 elements &#123;0, 1, 2, ..., 7&#125;</span></span><br><span class="line">x = space.sample()</span><br><span class="line">print(space.contains(x)) </span><br><span class="line">print(space.n == <span class="number">8</span>)</span><br></pre></td></tr></table></figure><pre><code>TrueTrue</code></pre><p>在 <code>CartPole-v0</code> 栗子中，运动只能选择左和右，分别用 <code>{0,1}</code> 表示</p><h2 id="gym-中可用的环境">Gym 中可用的环境</h2><p>Gym 中从简单到复杂，包含了许多经典的<a href="https://gym.openai.com/envs/#classic_control" target="_blank" rel="noopener">仿真环境</a>和各种数据，其中包括</p><ul><li><p>经典控制和文字游戏：经典的强化学习示例，方便入门；</p></li><li><p>算法：从例子中学习强化学习的相关算法，在 Gym 的仿真算法中，由易到难方便新手入坑；</p></li><li><p>雅达利游戏：利用强化学习来玩雅达利的游戏。Gym 中集成了对强化学习有着重要影响的 <a href="http://www.arcadelearningenvironment.org/" target="_blank" rel="noopener">Arcade Learning Environment</a>，并且方便用户安装；</p></li><li><p>2D 和 3D 的机器人：这个是我一直很感兴趣的一部分，在 Gym 中控制机器人进行仿真。需要利用第三方的物理引擎如 <code>MuJoCo</code> 。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fto4z7mno0j20oa0ikqbs.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="注册表">注册表</h2><p>Gym 是一个包含各种各样强化学习仿真环境的大集合，并且封装成通用的接口暴露给用户，查看所有环境的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gym <span class="keyword">import</span> envs</span><br><span class="line">print(envs.registry.all())</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_values([EnvSpec(Copy-v0), EnvSpec(RepeatCopy-v0), EnvSpec(ReversedAddition-v0), EnvSpec(ReversedAddition3-v0), EnvSpec(DuplicatedInput-v0), EnvSpec(Reverse-v0), EnvSpec(CartPole-v0), EnvSpec(CartPole-v1), EnvSpec(MountainCar-v0), EnvSpec(MountainCarContinuous-v0), EnvSpec(Pendulum-v0), EnvSpec(Acrobot-v1), EnvSpec(LunarLander-v2), EnvSpec(LunarLanderContinuous-v2), EnvSpec(BipedalWalker-v2),...</span><br></pre></td></tr></table></figure><p>Gym 支持将用户制作的环境写入到注册表中，需要执行 <code>gym.make()</code> 和在启动时注册 <code>register</code>，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">register(</span><br><span class="line">    id=<span class="string">'CartPole-v0'</span>,</span><br><span class="line">    entry_point=<span class="string">'gym.envs.classic_control:CartPoleEnv'</span>,</span><br><span class="line">    max_episode_steps=<span class="number">200</span>,</span><br><span class="line">    reward_threshold=<span class="number">195.0</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://gym.openai.com/docs/" target="_blank" rel="noopener">https://gym.openai.com/docs/</a></p></li><li><p><a href="https://nndl.github.io/" target="_blank" rel="noopener">https://nndl.github.io/</a></p></li></ul><h2 id="结语">结语</h2><p>emmmm ... 第一篇强化学习入坑笔记写完，大多是从官方文档看过来的加上了一点点自己的理解，建议文档这东西还是直接看官方的吧，原汁原味</p><h2 id="关于作者">关于作者</h2><ul><li>神奇的战士</li><li>博客：<a href="http://thinkhard.tech/">http://thinkhard.tech/</a></li><li>Github: <a href="https://github.com/wangshub" target="_blank" rel="noopener">https://github.com/wangshub</a></li><li>微信公众号：<strong>神奇的战士</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs09ydtc98j20vd06p759.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器人强化学习之使用-openai-gym-教程与笔记&quot;&gt;机器人强化学习之使用 OpenAI Gym 教程与笔记&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;除了试图直接去建立一个可以模拟成人大脑的程序之外， 为什么不试图建立一个可以模拟小孩大脑的程序呢?如果它接 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器人强化学习笔记（0）</title>
    <link href="http://thinkhard.tech/2018/07/03/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://thinkhard.tech/2018/07/03/强化学习笔记/</id>
    <published>2018-07-03T14:34:36.000Z</published>
    <updated>2019-04-04T10:10:23.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器人强化学习笔记0">机器人强化学习笔记（0）</h1><h2 id="机器学习分类">机器学习分类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fsx1t71czwj20lc0dkdjg.jpg" alt="Machine Learning" title>                </div>                <div class="image-caption">Machine Learning</div>            </figure><h2 id="强化学习问题">强化学习问题</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fsx1s6yxgsj20c204vjrh.jpg" alt="RL problem" title>                </div>                <div class="image-caption">RL problem</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fsx1xqsh7ij20c204v0t0.jpg" alt="Child walk" title>                </div>                <div class="image-caption">Child walk</div>            </figure><ul><li><strong>监督学习</strong>：监督学习由任务驱动，需要创造外部的“导师”，“导师”拥有外部环境的所有先验信息，并教导 Agent 完成特定的任务。但是 Agent 可以用很多种子任务相结合的方式去完成相同的任务。所以创造一个全能的“导师”来训练 Agent 在实际中几乎是不可能的。</li><li><strong>非监督学习</strong>：非监督学习是由数据驱动，主要目的是找到底层的模式而不是映射关系。例如给用户推荐新闻时，非监督学习主要是根据用户先前阅读过的新闻来推荐相似的新闻。</li><li><strong>强化学习</strong>：和上面两种方法相比较，强化学习主要是从自身的经验来获取知识，在输入和输出之间存在着映射关系。强化学习将奖励函数作为行为的反馈。</li></ul><h2 id="解决强化学习问题的框架和算法">解决强化学习问题的框架和算法</h2><p>强化学习需要平衡 <strong>exploration vs exploitation</strong> 困境。</p><h3 id="马尔可夫决策过程markov-decision-process">马尔可夫决策过程(Markov Decision Process)</h3><p>在强化学习场景下，数学模型为马尔可夫决策过程，表示为</p><ul><li>状态集合：S</li><li>动作集合：A</li><li>奖励函数：R</li><li>策略：Pi</li><li>值：V</li></ul><p>从起始状态到结束状态<span class="math inline">\(S\)</span>需要经过动作集合 A。执行每个动作后，都会获得奖励 R，每个动作可能会导致好的或者坏的奖励函数值。策略(Policy)就是采取某个系列动作的方法，并且会相应的得到奖励函数的值。因此，求解强化学习的目标就是要选取最佳策略(Policy)，在所有可能的状态和时间范围内使得评估函数最大，即</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1ft298te49zj203001c0si.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="最短路径问题shortest-path-problem">最短路径问题(Shortest Path Problem)</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fsx3dp18t2j20md0bq74c.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>求解以最小代价，从地点 A 到地点 F 的最短路径问题，转化为</p><ul><li>节点集合 {A, B, C, D, E, F}</li><li>从点到点移动成为动作，{A-&gt;B, C-&gt;D}</li><li>奖励函数为每条边的花费</li><li>完成 A 点到 F 行走路线成为策略，如 {A-&gt;B-&gt;D-&gt;F}</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器人强化学习笔记0&quot;&gt;机器人强化学习笔记（0）&lt;/h1&gt;
&lt;h2 id=&quot;机器学习分类&quot;&gt;机器学习分类&lt;/h2&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
 
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Reinforment Learning" scheme="http://thinkhard.tech/tags/Reinforment-Learning/"/>
    
  </entry>
  
  <entry>
    <title>效率工具网站推荐</title>
    <link href="http://thinkhard.tech/2018/06/09/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <id>http://thinkhard.tech/2018/06/09/工具网站推荐/</id>
    <published>2018-06-09T01:58:48.000Z</published>
    <updated>2019-10-31T02:10:38.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提升生活品质个人效率工具与资讯网站推荐">提升生活品质——个人效率工具与资讯网站推荐</h1><ul><li>这个世界上软件太多，懂你的工具太少；</li><li>我是个工具控，经常搜集和自己写一些工具和插件来提高生活品质；</li><li>本文将持续更新和记录我平时工作中<strong>重度使用</strong>的一些效率工具和网站；</li></ul><h2 id="工具类">工具类</h2><h3 id="emacs">Emacs</h3><ul><li>地址：<a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">https://github.com/syl20bnr/spacemacs</a></li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li><li>目前用到 Emacs 最多的功能就是 Org mode，用于平时的想法收集、思路整理、任务分配。Emacs 功能实在强大，任何能想到的功能基本上都有插件，但是刚开始上手会非常不习惯。要想全面掌握，还是要看一些 Lisp。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs476peynoj20o80d2tcb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="org-mode">Org mode</h3><ul><li>地址：<a href="https://orgmode.org/" target="_blank" rel="noopener">https://orgmode.org/</a></li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li><li>鉴于 Org mode 实在是太好用了，所以再单独推荐一次。Org mode 是基于节点的结构，利用它可以实现脑图的功能，而且还可以设置每个节点的状态。大多数人(包括我)都是将它作为 GTD 工具来使用，或者可以用来写博客文章。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs479c7cbej20du0ab0vt.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="brook">Brook</h3><ul><li>地址：<a href="https://github.com/txthinking/brook" target="_blank" rel="noopener">https://github.com/txthinking/brook</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li><li>Brook 是一个跨平台的代理工具，作者编译出了各个平台的 Release，在我试过 Brook 协议后，一下子被惊艳到了，代理速度十分惊艳，瞬间我的龟速服务器焕发青春。本来想给 Brook 五星的，但是由于目前它的客户端还不太完善，偶尔存在服务端退出的问题。后续还会持续关注该项目。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47ar7actj20k10dhabc.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="typora">Typora</h3><ul><li>地址：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li><li>像我这种 Markdown 业余程序员，写的最多很多时候却是文档。Typora 是一个精而美的开源跨平台 Markdown 编辑器，支持 MacOS 、Windows、Linux，对 Markdown 渲染是我见过较为漂亮的，输入的体验也超级棒，同时还可以输出 Pdf 文件。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47btl76vj20mx0gcq57.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="picgo">PicGo</h3><ul><li>地址：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li><li>一个开源免费图床上传工具，PicGo 目前支持了微博图床，七牛图床，腾讯云 COS v4</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47cqhkdxj218e0p0kjl.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="cerebro">Cerebro</h3><ul><li>地址：<a href="https://github.com/KELiON/cerebro" target="_blank" rel="noopener">https://github.com/KELiON/cerebro</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li><li>一个开源免费的对话式快速启动工具，支持 MacOs、Windows、Linux。目前我在 MacOs 下面切换窗口启动软件都离不开这个工具，还为 Cerebro 写了很多插件。当然类似的工具还有 Alfred 和 Wox 等，但是一个能自己随心所欲修改的软件才是好软件，对吧？</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cloud.githubusercontent.com/assets/594298/20180624/858a483a-a75b-11e6-94a1-ef1edc4d95c3.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="sharemouse">ShareMouse</h3><ul><li>地址：<a href="http://www.keyboard-and-mouse-sharing.com/" target="_blank" rel="noopener">http://www.keyboard-and-mouse-sharing.com/</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li><li>如果你需要在不同系统和电脑之间共享同一个键盘鼠标的话，ShareMouse 可能就是完美地解决方案，但是需要收费。相对于 Synergy，可以在不同窗口之间拖拽和复制文件，美中不足的是需要收费不开源。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47ed6llqj20hq06yaa4.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="fish-shell">Fish Shell</h3><ul><li>地址：<a href="https://fishshell.com/" target="_blank" rel="noopener">https://fishshell.com/</a></li><li>推荐指数：⭐️⭐️⭐️⭐️</li><li>相较于 Zsh Shell，我认为 Fish 在配置上面更人性化一些，但是有一个槽点就是对 Bash 的指令不完全兼容。推荐使用 Oh-my-fish 和 Fisherman 来进行 Fish 的插件管理。推荐 <code>主题 Agnoster</code> + <code>配色 Dracula</code>，好看到没朋友。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47g5r1lej20l9092jtb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="资讯网站">资讯网站</h2><h3 id="github-每日-trending"><a href="https://github.com/trending" target="_blank" rel="noopener">Github 每日 Trending</a></h3><ul><li><strong>地址</strong>: <a href="https://github.com/trending" target="_blank" rel="noopener">https://github.com/trending</a></li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li><li>每天必须要浏览一遍，能上 Github Trending 的项目，必定存在着创意和骚操作（有幸上过两次月榜）。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47hj5jl8j20k30f60ug.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="hacker-news"><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News</a></h2><ul><li>地址：<a href="https://news.ycombinator.com/" target="_blank" rel="noopener">https://news.ycombinator.com/</a></li><li>推荐指数：⭐️⭐️⭐️⭐️⭐️</li><li>在 Hacker News 热榜上面的新闻，绝对算得上技术界的大新闻，强烈值得每日浏览(需要梯子)。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47iearlnj20en08wgle.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="总结">总结</h2><p>工具或者软件，适合自己才是最好的。单纯的夸耀某某语言或者 IDE 是最好的，实在没有太大的必要。</p><p>一些技术新闻资讯，还是建议多看英文的原文链接，很多中文的营销号只是粗略的翻译和转载，在这个过程中，原有的信息可能发生扭曲和丢失，实在像被人咀嚼过的甘蔗，没有太多的营养。</p><p>最后欢迎关注我的微信公众号：<strong>神奇的战士</strong> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fs47krv4owj2076076t9i.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;提升生活品质个人效率工具与资讯网站推荐&quot;&gt;提升生活品质——个人效率工具与资讯网站推荐&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;这个世界上软件太多，懂你的工具太少；&lt;/li&gt;
&lt;li&gt;我是个工具控，经常搜集和自己写一些工具和插件来提高生活品质；&lt;/li&gt;
&lt;li&gt;本文将持续更新
      
    
    </summary>
    
    
      <category term="Tool" scheme="http://thinkhard.tech/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Python抖音机器人，论如何在抖音上找到漂亮小姐姐？</title>
    <link href="http://thinkhard.tech/2018/05/28/Python%E6%8A%96%E9%9F%B3%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%8C%E8%AE%BA%E5%A6%82%E4%BD%95%E5%9C%A8%E6%8A%96%E9%9F%B3%E4%B8%8A%E6%89%BE%E5%88%B0%E6%BC%82%E4%BA%AE%E5%B0%8F%E5%A7%90%E5%A7%90%EF%BC%9F/"/>
    <id>http://thinkhard.tech/2018/05/28/Python抖音机器人，论如何在抖音上找到漂亮小姐姐？/</id>
    <published>2018-05-28T06:38:32.000Z</published>
    <updated>2019-04-04T10:10:23.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在抖音上找到漂亮小姐姐----抖音机器人">如何在抖音上找到漂亮小姐姐----抖音机器人</h1><p>最近沉迷于抖音无法自拔，常常花好几个小时在抖音<strong>漂亮小姐姐</strong>身上。</p><p>为了<strong>高效、直接</strong>地找到漂亮小姐姐，我用 Python + ADB 做了一个 Python 抖音机器人 Douyin-Bot。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/wangshub/Douyin-Bot/raw/master/screenshot/demo.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="特性">特性</h2><ul><li><input type="checkbox" disabled checked><strong>自动翻页</strong></li><li><input type="checkbox" disabled checked><strong>颜值检测</strong></li><li><input type="checkbox" disabled checked><strong>人脸识别</strong></li><li><input type="checkbox" disabled checked><strong>自动点赞</strong></li><li><input type="checkbox" disabled checked><strong>自动关注</strong></li><li><input type="checkbox" disabled checked>随机防 Ban</li><li><input type="checkbox" disabled>自动回复</li></ul><h2 id="原理">原理</h2><ul><li>打开《抖音短视频》APP，进入主界面</li><li>获取手机截图，并对截图进行压缩 (Size &lt; 1MB)；</li><li>请求 <a href="http://ai.qq.com/" target="_blank" rel="noopener">人脸识别 API</a>；</li><li>解析返回的人脸 Json 信息，对人脸检测切割；</li><li>当颜值大于门限值 <code>BEAUTY_THRESHOLD</code>时，点赞并关注；</li><li>下一页，返回第一步；</li></ul><h2 id="使用教程">使用教程</h2><ul><li>相关软件工具安装和使用步骤请参考 <a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">wechat_jump_game</a> 和 <a href="https://github.com/wangshub/wechat_jump_game/wiki/Android-%E5%92%8C-iOS-%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4" target="_blank" rel="noopener">Android 和 iOS 操作步骤</a></li></ul><ol type="1"><li>获取源码：<code>git clone https://github.com/wangshub/Douyin-Bot.git</code></li><li>进入源码目录： <code>cd Douyin-Bot</code></li><li>安装依赖： <code>pip install -r requirements.txt</code></li><li>运行程序：<code>python douyin-bot.py</code></li></ol><h2 id="注意">注意</h2><ul><li>目前暂时只适配了 一加5(1920x1080 分辨率)，如果手机不是该分辨率，请修改 <code>config/</code> 文件夹下面的配置文件；</li></ul><h2 id="脸部截取">脸部截取</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/wangshub/Douyin-Bot/raw/master/screenshot/faces.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="license">LICENSE</h2><p>MIT</p><p>欢迎 Star 和 Fork ~</p><p><strong>项目地址:</strong><a href="https://github.com/wangshub/Douyin-Bot" target="_blank" rel="noopener">https://github.com/wangshub/Douyin-Bot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何在抖音上找到漂亮小姐姐----抖音机器人&quot;&gt;如何在抖音上找到漂亮小姐姐----抖音机器人&lt;/h1&gt;
&lt;p&gt;最近沉迷于抖音无法自拔，常常花好几个小时在抖音&lt;strong&gt;漂亮小姐姐&lt;/strong&gt;身上。&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;高效、直接&lt;/stro
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="ADB" scheme="http://thinkhard.tech/tags/ADB/"/>
    
  </entry>
  
  <entry>
    <title>给博客网站加个球(访客统计)</title>
    <link href="http://thinkhard.tech/2018/05/20/%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%AA%E7%90%83-%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1/"/>
    <id>http://thinkhard.tech/2018/05/20/给博客加个球-访客统计/</id>
    <published>2018-05-20T09:09:18.000Z</published>
    <updated>2019-04-04T10:10:23.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给博客网站加个球-访客统计脚本">给博客网站加个球-访客统计脚本</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhx77kz3yj20dg0autd0.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最近无意中发现了 Revolvermaps 这个网站，可以对网站页面上的访客进行统计。</p><h2 id="demo-演示">Demo 演示</h2><p><strong><a href="http://thinkhard.tech/">神奇的战士的博客</a></strong></p><h2 id="主要特征">主要特征</h2><ul><li>访客 IP 地点统计；</li><li>访客人数统计；</li><li>页面停留时间统计；</li><li>多样式定制；</li><li>免费、易使用；</li></ul><h2 id="使用方法">使用方法</h2><ul><li>访问 <a href="https://www.revolvermaps.com/" target="_blank" rel="noopener">https://www.revolvermaps.com</a></li><li>复制脚本代码</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhxg9k3n0j20n90a3wg1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>插入到博客网站中的 Html；</li></ul><h2 id="效果展示">效果展示</h2><ul><li>过去 24 小时访客统计</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhxjg7qa3j20kb0lomyp.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>不同地区统计</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhxkeoz6qj20kj0fd408.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>各地区访问人数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhxlcmny8j20gp0di0z1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>各个地区的访问时间</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhxmixiqbj20kl0gkn63.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="最后">最后</h2><blockquote><p>Happy 520 Day ~</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;给博客网站加个球-访客统计脚本&quot;&gt;给博客网站加个球-访客统计脚本&lt;/h1&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://thinkhard.tech/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>使用Emacs进行日程管理（GTD）</title>
    <link href="http://thinkhard.tech/2018/05/13/%E4%BD%BF%E7%94%A8Emacs%E8%BF%9B%E8%A1%8C%E6%97%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88GTD%EF%BC%89/"/>
    <id>http://thinkhard.tech/2018/05/13/使用Emacs进行日程管理（GTD）/</id>
    <published>2018-05-13T06:19:22.000Z</published>
    <updated>2019-04-04T10:10:23.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-emacs-进行日程管理-gtd">使用 Emacs 进行日程管理 (GTD)</h1><h2 id="什么是-gtd">什么是 GTD ?</h2><blockquote><p>Your mind is for having ideas, not holding them. --- David Allen</p></blockquote><p><strong>GTD</strong> (Getting Things Done) 是一个组织和跟进任务或待办事项的系统架构，但是它的目标要高于仅仅是将事情做完，而是要将待办事项以一个更好的方式完成。GTD 的目标是让人 100% 地相信 GTD 的系统来收集任务、想法。这样才能卸下记忆这些想法的思想包袱，专注的完成当下的任务。GTD 将所有的事情罗列下来，然后再进行分类，你就能从一个比较宏观的角度来看待这一堆问题，并且确定下一步的处理方法，将所有悬而未决的事情尽量地处于我们个人的掌握之中。</p><p>更多关于 GTD 方法的介绍可以参考 <a href="https://gettingthingsdone.com/" target="_blank" rel="noopener">David Allen</a> 的博客和相关书籍。</p><p>理论就介绍到这里了，目前市面上有许许多多在各种平台上收费 GTD 任务管理软件、也有许多开源免费的软件，如</p><ul><li><a href="Taskwarrior%20-%20What&#39;s%20next?">Taskwarrior</a></li><li><a href="Todo.txt:%20Future-proof%20task%20tracking%20in%20a%20file%20you%20control" target="_blank" rel="noopener">Todo.txt</a></li><li><a href="https://orgmode.org/" target="_blank" rel="noopener">Emacs Org-mode</a></li><li>...</li></ul><p>今天主要 Show 一下在 Emacs 中使用 Org-mode 来记录、分类、保存、跟进我的想法和任务</p><p><strong>主要特点</strong></p><ul><li>基于 Spacemacs 功能强大；</li><li>操作难度较大，可定制性强；</li><li>利用 Git 工具定期自动备份笔记；</li></ul><h2 id="emacs-插件安装步骤">Emacs 插件安装步骤</h2><p>项目地址：<a href="https://github.com/carlos-wong/org-agenda-carlos" target="_blank" rel="noopener">https://github.com/carlos-wong/org-agenda-carlos</a></p><h2 id="在-emacs-中进行日程管理">在 Emacs 中进行日程管理</h2><p>安装并配置好插件后，使用时主要分三步：<strong>录入、显示、保存</strong>。</p><h3 id="todo-录入">Todo 录入</h3><p>绑定输入快捷键：<code>F7</code> 绑定显示快捷键：<code>F6</code></p><ul><li>选择 Todo 类型</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhv25t2b7j20b505a0sq.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>输入事项</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhv5kx5hwj20ea02jt8v.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>安排节点</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhvn7ahrqj20eb02iaac.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="todo-显示">Todo 显示</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1frhva450zgj20ud0dz427.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="结语">结语</h2><p>现在，每天打开 Emacs 的第一件事就是看今天的 Org ,又有做不完的事情了 ~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-emacs-进行日程管理-gtd&quot;&gt;使用 Emacs 进行日程管理 (GTD)&lt;/h1&gt;
&lt;h2 id=&quot;什么是-gtd&quot;&gt;什么是 GTD ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Your mind is for having ideas, not h
      
    
    </summary>
    
    
      <category term="Emacs" scheme="http://thinkhard.tech/tags/Emacs/"/>
    
      <category term="Lisp" scheme="http://thinkhard.tech/tags/Lisp/"/>
    
  </entry>
  
  <entry>
    <title>开源跨平台效率软件Cerebro</title>
    <link href="http://thinkhard.tech/2018/04/30/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6Cerebro/"/>
    <id>http://thinkhard.tech/2018/04/30/跨平台效率软件Cerebro/</id>
    <published>2018-04-30T12:26:25.000Z</published>
    <updated>2019-04-04T10:10:23.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开源跨平台效率软件cerebro">开源跨平台效率软件Cerebro</h1><!-- TOC --><ul><li><a href="#%E5%BC%80%E6%BA%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%95%88%E7%8E%87%E8%BD%AF%E4%BB%B6cerebro">开源跨平台效率软件Cerebro</a><ul><li><a href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">主要特性</a></li><li><a href="#%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA">功能展示</a><ul><li><a href="#%08%E5%BA%94%E7%94%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2">应用与文件搜索</a></li><li><a href="#%E5%9F%BA%E4%BA%8E-electron%EF%BC%8C%E4%BB%80%E4%B9%88%E9%83%BD%E8%83%BD%E7%9C%8B">基于 Electron，什么都能看</a></li><li><a href="#%E6%98%93%E4%B8%8A%E6%89%8B%E7%9A%84%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91">易上手的插件开发</a></li></ul></li><li><a href="#%08%E6%8F%92%E4%BB%B6%E5%B1%95%E7%A4%BA">插件展示</a></li><li><a href="#%E6%88%91%E4%BB%AC%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6">我们写的一些插件</a><ul><li><a href="#cerebro-torrent">Cerebro-torrent</a></li><li><a href="#cerebro-codelf">Cerebro-codelf</a></li></ul></li><li><a href="#%E7%BB%93%E8%AF%AD">结语</a></li></ul></li></ul><!-- /TOC --><p>在 Mac 下面有很多制作精美的第三方软件，其中就有大名鼎鼎的效率神器 <a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a> 。但是只能在 Mac 下面才能使用，而且收费不开源。</p><p>今天隆重介绍一下另一款大杀器 <a href="https://github.com/KELiON/cerebro" target="_blank" rel="noopener">Cerebro</a> 以及我是如何在平时工作学习中使用它提升效率的。</p><p>不同于菜单，Ui 交互的工作方式，类似接自然对话的交互方式，这类对话式的操作软件还是有不少项目，但是跨平台、插件开发来说 Cerebro 是比较出色的，毕竟一个能让自己任意修改的软件才是好软件。@<a href="https://github.com/carlos-wong" target="_blank" rel="noopener">carlos-wong</a></p><h2 id="主要特性">主要特性</h2><ul><li>美好的生活从 <code>Ctrl-Space</code> 开始；</li><li>App 快速启动；</li><li>电脑文件搜索；</li><li>基于 <strong>JavaScript</strong>, 一定要试试自己写插件；</li><li>跨平台 Mac、Windows、Linux；</li><li>做你能想到的任何事；</li></ul><p>理论上 Alfred 能做的事情，Cerebro 同样能做到，更重要的是 <strong>跨平台开源免费！</strong>、<strong>跨平台开源免费！</strong>、<strong>跨平台开源免费！</strong></p><h2 id="功能展示">功能展示</h2><h3 id="应用与文件搜索">应用与文件搜索</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fquyzyes0jj20rs0pln0z.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="基于-electron什么都能看">基于 Electron，什么都能看</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fquz6vi2f2j20rs0ll11s.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="易上手的插件开发">易上手的插件开发</h3><p>如果你正好是 JavaScript 的爱好者的话，这款软件绝对是你的大杀器，Cerebro 的插件是同类软件中最容易上手开发的。只需要遵从 <a href="https://github.com/KELiON/cerebro/blob/master/docs/plugins.md" target="_blank" rel="noopener">Cerebro API</a> ，如果你连文档都懒得看的话，个人建议直接从插件列表 <a href="https://github.com/lubien/awesome-cerebro" target="_blank" rel="noopener">Awesome-cerebro</a> 选一个改成你想要的样子就行，开源就是这么有魅力！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fquz8pmuunj20rs0inn7m.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="插件展示">插件展示</h2><ul><li>密码管理</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/maximbaz/cerebro-pass/raw/master/docs/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>执行 Shell 命令</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/KELiON/cerebro-shell/raw/master/screenshot.gif" alt="shell" title>                </div>                <div class="image-caption">shell</div>            </figure><ul><li>搜索 npm 包</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/JordanAdams/cerebro-npm/master/.github/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>生成二维码</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/LaercioSantana/cerebro-qrcode/raw/master/cerebro-qrcode.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>搜索 Emoji 表情</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/KELiON/cerebro-emoj/raw/master/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>更多插件列表 <a href="https://github.com/lubien/awesome-cerebro" target="_blank" rel="noopener">Awesome-cerebro</a></li></ul><h2 id="我们写的一些插件">我们写的一些插件</h2><h3 id="cerebro-torrent">Cerebro-torrent</h3><ul><li><a href="https://github.com/wangshub" target="_blank" rel="noopener">我</a>写的种子搜片儿神器 <a href="https://github.com/wangshub/cerebro-torrent" target="_blank" rel="noopener">Cerebro-torrent</a> &gt; 看个片儿还要打开网页慢慢找?！ <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/wangshub/cerebro-torrent/raw/master/resource/magnet_demo_2M.gif" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="cerebro-codelf">Cerebro-codelf</h3><ul><li><span class="citation" data-cites="carlos-wong">[@carlos-wong]</span>(https://github.com/carlos-wong) 制作快速地变量名搜索神器 <a href="https://github.com/carlos-wong/cerebro-codelf" target="_blank" rel="noopener">Cerebro-codelf</a> &gt; 给变量起名的事情上，为你生命省 3s <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/carlos-wong/cerebro-codelf/raw/master/res/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="结语">结语</h2><p>如果你生活中存在着一些机械重复的劳动的话，比如煮个咖啡、回复相同内容的邮件、打开特定的网页等等，完全可以写成 Cerebro 插件提升效率，而节省下来的时间再用来改进工具，形成正循环！</p><p>欢迎入坑 ~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开源跨平台效率软件cerebro&quot;&gt;开源跨平台效率软件Cerebro&lt;/h1&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%95%88%E7%8E
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://thinkhard.tech/tags/JavaScript/"/>
    
      <category term="Cerebro" scheme="http://thinkhard.tech/tags/Cerebro/"/>
    
  </entry>
  
  <entry>
    <title>cerebro-codelf给变量起名的事情上，为你生命省3s</title>
    <link href="http://thinkhard.tech/2018/04/30/cerebro-codelf%E7%BB%99%E5%8F%98%E9%87%8F%E8%B5%B7%E5%90%8D%E7%9A%84%E4%BA%8B%E6%83%85%E4%B8%8A%EF%BC%8C%E4%B8%BA%E4%BD%A0%E7%94%9F%E5%91%BD%E7%9C%813s/"/>
    <id>http://thinkhard.tech/2018/04/30/cerebro-codelf给变量起名的事情上，为你生命省3s/</id>
    <published>2018-04-30T12:11:27.000Z</published>
    <updated>2019-04-04T10:10:23.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cerebro-codelf">cerebro-codelf</h1><blockquote><p>There are only two hard things in Computer Science: cache invalidation and naming things. -- Phil Karlton</p></blockquote><blockquote><p>给变量起名的事情上，为你生命省 <strong>3s</strong>。</p></blockquote><p><strong><a href="https://github.com/KELiON/cerebro.git" target="_blank" rel="noopener">Cerebro</a> 变量名搜索插件</strong>，项目灵感来源 <a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">codelf</a>。通过 Cerebro 的搜索窗口快速查找变量名。</p><h2 id="特性">特性</h2><ul><li>快速启动、搜索</li><li>中英文搜索</li><li>自由定制</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/carlos-wong/cerebro-codelf/raw/master/res/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="安装">安装</h2><ul><li>插件依赖于 <a href="https://github.com/KELiON/cerebro.git" target="_blank" rel="noopener">Cerebro</a></li><li><code>Ctrl-Space</code> 打开 Cerebro</li><li>输入 <code>plugins codelf</code>，点击安装</li></ul><h2 id="使用">使用</h2><ul><li>Cerebro 中，输入 <code>codelf</code> + <code>[待搜索的变量名]</code>；</li><li>上下选择变量名，敲回车 <code>Enter</code> 复制到剪切板；</li></ul><h2 id="license">LICENSE</h2><p>MIT</p><p>项目地址 <a href="https://github.com/carlos-wong/cerebro-codelf" target="_blank" rel="noopener">https://github.com/carlos-wong/cerebro-codelf</a></p><p>欢迎 fork :fork_and_knife: 和 star :star:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cerebro-codelf&quot;&gt;cerebro-codelf&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and namin
      
    
    </summary>
    
    
      <category term="JacaScript" scheme="http://thinkhard.tech/tags/JacaScript/"/>
    
      <category term="Cerebro" scheme="http://thinkhard.tech/tags/Cerebro/"/>
    
  </entry>
  
  <entry>
    <title>python插件式爬虫</title>
    <link href="http://thinkhard.tech/2018/04/25/python%E6%8F%92%E4%BB%B6%E5%BC%8F%E7%88%AC%E8%99%AB/"/>
    <id>http://thinkhard.tech/2018/04/25/python插件式爬虫/</id>
    <published>2018-04-25T07:51:05.000Z</published>
    <updated>2019-04-04T10:10:23.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-插件式的信息爬虫">Python 插件式的信息爬虫</h1><blockquote><p>🐝 一群不辞劳苦采花小蜜蜂</p></blockquote><ul><li><a href="https://github.com/wangshub/beehive" target="_blank" rel="noopener">项目代码地址</a></li></ul><p>本项目运行在可以运行在本地或者服务器端，将不同插件程序获取的信息如：每日天气、新闻等，通过 Github Api 上传到仓库进行保存。当然，你还可以你日常机械重复性的劳动在插件中帮你完成，比如煮咖啡、发邮件等等，真是棒极了。</p><blockquote><p><strong>额外收获</strong> ：定期稳定运行在服务器上，还可以每日贡献一次 Github 贡献度 ... 点亮你的人生！</p></blockquote><h2 id="工程说明">工程说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">│   └── plugins</span><br><span class="line">│       └── weather.py</span><br><span class="line">├── builtin_plugins</span><br><span class="line">├── config</span><br><span class="line">│   └── config.json</span><br><span class="line">├── main.py</span><br><span class="line">└── upload_github.py</span><br></pre></td></tr></table></figure><ul><li><code>main.py</code> : 加载 <code>builtin_plugins/</code> 和 <code>app/</code> 下的插件；</li><li><code>app/plugins/</code> : 插件程序存放路径；</li><li><code>builtin_plugins</code> ： 内置插件路径；</li><li><code>upload_github.py</code> : 通过 Github Api 提交一次 Commit；</li></ul><h2 id="使用步骤">使用步骤</h2><ul><li><p>生成 Github Token</p></li><li><p>运行代码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="插件接口-json-格式">插件接口 Json 格式</h2><p>可以自己补充插件，各个插件的返回值为字典类型，必须满足如下格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"weather"</span>,</span><br><span class="line">  <span class="attr">"date"</span>: <span class="string">"2018-04-23 20:18:03"</span>,</span><br><span class="line">  <span class="attr">"content"</span>: &#123;</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"\u6df1\u5733"</span>, <span class="attr">"weather"</span>: <span class="string">"\u591a\u4e91"</span>, <span class="attr">"temperature"</span>: <span class="string">"21 ~ 26\u2103"</span>, <span class="attr">"humidity"</span>: <span class="string">"\u6e7f\u5ea6\uff1a63%"</span>, <span class="attr">"wind"</span>: <span class="string">"\u98ce\u5411\uff1a\u5317\u98ce 2\u7ea7"</span>, <span class="attr">"radiation"</span>: <span class="string">"\u7d2b\u5916\u7ebf\uff1a\u5f31"</span>, <span class="attr">"air"</span>: <span class="string">"PM: 43"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><code>code</code>: <code>0</code> 成功、<code>-1</code> 失败；</li><li><code>type</code>: 例如 [<code>weather</code>, <code>stock</code>, <code>news</code>] 等；</li><li><code>date</code>: 当天日期，如 <code>2018-05-01</code>；</li><li><code>content</code>: 获取的 Json 格式信息，这部分提交到仓库保存；</li></ul><h2 id="todo">Todo</h2><ul><li><p><input type="checkbox" disabled checked>Python 插件化信息管理，可拓展；</p></li><li><p><input type="checkbox" disabled checked>信息保存到 Github 仓库；</p></li><li><p><input type="checkbox" disabled>更多插件补充；</p></li><li><p><input type="checkbox" disabled>Docker一键部署到本地或服务器；</p></li><li><p><input type="checkbox" disabled>信息可视化</p><ul><li><input type="checkbox" disabled>Pyeacharts 网页显示</li><li><input type="checkbox" disabled>Gitpage 静态页面每日渲染</li></ul></li><li><p><input type="checkbox" disabled>Itchat 微信推送</p><ul><li><input type="checkbox" disabled>自动登录</li><li><input type="checkbox" disabled>自动推送</li><li><input type="checkbox" disabled>信息查询</li></ul></li><li><p><input type="checkbox" disabled>补充插件内容</p><ul><li><input type="checkbox" disabled>插件思路收集</li><li><input type="checkbox" disabled><strong>大新闻</strong>日常备份</li><li><input type="checkbox" disabled>商品价格记录插件</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-插件式的信息爬虫&quot;&gt;Python 插件式的信息爬虫&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;🐝 一群不辞劳苦采花小蜜蜂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wangshub
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python插件式程序结构设计</title>
    <link href="http://thinkhard.tech/2018/04/23/Python%E6%8F%92%E4%BB%B6%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://thinkhard.tech/2018/04/23/Python插件式程序结构设计/</id>
    <published>2018-04-23T06:27:19.000Z</published>
    <updated>2019-04-04T10:10:23.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-插件式程序结构设计">Python 插件式程序结构设计</h1><blockquote><p>小姐姐，你的插件掉了</p></blockquote><p>本文源码在 <a href="github/wangshub">github/wangshub</a></p><p>最近有个问题一直困扰着我，我经常会遇到对以前的程序或者代码进行功能的扩充，但是由于前期没有太多程序架构上的设计，导致功能扩充时冗余代码太多，而且不方便维护( YC 创始人 Paul Graham 其实推荐这种做法，产品快速上线，获取用户反馈进行修改)。</p><p>知名的插件式设计的项目有</p><ul><li>Emacs</li><li>Vs-code</li><li>Atom</li></ul><p>为了拓展软件的功能，经常会将软件设计成插件式结构，所以就从我熟悉的 Python 开始了解这部分知识。 通过 Google， 发现了 <a href="http://pluginbase.pocoo.org/" target="_blank" rel="noopener">Pluginbase</a> Python 插件框架，可以快速实现一个 Python 插件式结构，这篇博客作为阅读笔记。</p><h2 id="项目文件结构">项目文件结构</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── app1</span><br><span class="line">│   └── plugins</span><br><span class="line">│       └── secret.py</span><br><span class="line">├── app2</span><br><span class="line">│   └── plugins</span><br><span class="line">│       └── randomstr.py</span><br><span class="line">├── builtin_plugins</span><br><span class="line">│   ├── lowercase.py</span><br><span class="line">│   └── uppercase.py</span><br><span class="line">└── example.py</span><br></pre></td></tr></table></figure><h2 id="插件管理器">插件管理器</h2><ul><li>获取当前项目的路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> pluginbase <span class="keyword">import</span> PluginBase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># For easier usage calculate the path relative to here.</span></span><br><span class="line">here = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line"><span class="comment"># 函数包装，重新定义函数签名，减少调用参数</span></span><br><span class="line">get_path = partial(os.path.join, here)</span><br><span class="line">print(<span class="string">'here:'</span>, here)</span><br><span class="line">print(<span class="string">'get_path:'</span>, get_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup a plugin base for "example.modules" and make sure to load</span></span><br><span class="line"><span class="comment"># all the default built-in plugins from the builtin_plugins folder.</span></span><br><span class="line">plugin_base = PluginBase(package=<span class="string">'example.plugins'</span>,</span><br><span class="line">                         searchpath=[get_path(<span class="string">'./builtin_plugins'</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Represents a simple example application."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># Each application has a name</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># And a dictionary where it stores "formatters".  These will be</span></span><br><span class="line">        <span class="comment"># functions provided by plugins which format strings.</span></span><br><span class="line">        self.formatters = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and a source which loads the plugins from the "&#123;app_name&#125;/plugins"</span></span><br><span class="line">        <span class="comment"># folder.  We also pass the application name as identifier.  This</span></span><br><span class="line">        <span class="comment"># is optional but by doing this out plugins have consistent</span></span><br><span class="line">        <span class="comment"># internal module names which allows pickle to work.</span></span><br><span class="line">        self.source = plugin_base.make_plugin_source(</span><br><span class="line">            searchpath=[get_path(<span class="string">'./%s/plugins'</span> % name)],</span><br><span class="line">            identifier=self.name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Here we list all the plugins the source knows about, load them</span></span><br><span class="line">        <span class="comment"># and the use the "setup" function provided by the plugin to</span></span><br><span class="line">        <span class="comment"># initialize the plugin.</span></span><br><span class="line">        <span class="keyword">for</span> plugin_name <span class="keyword">in</span> self.source.list_plugins():</span><br><span class="line">            plugin = self.source.load_plugin(plugin_name)</span><br><span class="line">            plugin.setup(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_formatter</span><span class="params">(self, name, formatter)</span>:</span></span><br><span class="line">        <span class="string">"""A function a plugin can use to register a formatter."""</span></span><br><span class="line">        self.formatters[name] = formatter</span><br></pre></td></tr></table></figure><h2 id="实现插件">实现插件</h2><h3 id="插件-1-app1">插件 1 ： App1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_secret</span><span class="params">(s)</span>:</span></span><br><span class="line">    chars = list(s)</span><br><span class="line">    <span class="keyword">for</span> idx, char <span class="keyword">in</span> enumerate(chars):</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation <span class="keyword">and</span> <span class="keyword">not</span> char.isspace():</span><br><span class="line">            chars[idx] = <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chars)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(app)</span>:</span></span><br><span class="line">    app.register_formatter(<span class="string">'secret'</span>, make_secret)</span><br></pre></td></tr></table></figure><h3 id="插件-2-app2">插件 2 ： App2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_random</span><span class="params">(s)</span>:</span></span><br><span class="line">    chars = list(s)</span><br><span class="line">    <span class="keyword">for</span> idx, char <span class="keyword">in</span> enumerate(chars):</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> string.punctuation <span class="keyword">and</span> <span class="keyword">not</span> char.isspace():</span><br><span class="line">            chars[idx] = random.choice(string.ascii_letters)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(chars)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(app)</span>:</span></span><br><span class="line">    app.register_formatter(<span class="string">'random'</span>, make_random)</span><br></pre></td></tr></table></figure><h3 id="内置插件">内置插件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lowercase</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s.lower()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(app)</span>:</span></span><br><span class="line">    app.register_formatter(<span class="string">'lowercase'</span>, make_lowercase)</span><br></pre></td></tr></table></figure><h2 id="调用你的插件">调用你的插件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_demo</span><span class="params">(app, source)</span>:</span></span><br><span class="line">    <span class="string">"""Shows all formatters in demo mode of an application."""</span></span><br><span class="line">    print(<span class="string">'Formatters for %s:'</span> % app.name)</span><br><span class="line">    print(<span class="string">'       input: %s'</span> % source)</span><br><span class="line">    <span class="keyword">for</span> name, fmt <span class="keyword">in</span> sorted(app.formatters.items()):</span><br><span class="line">        print(<span class="string">'  %10s: %s'</span> % (name, fmt(source)))</span><br><span class="line">    print(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="相关参考链接">相关参考链接</h2><ul><li><a href="http://hgoldfish.com/blogs/article/81/" target="_blank" rel="noopener">如何设计插件式结构的程序，兼谈Python语言的动态性</a></li><li><a href="https://github.com/wangshub/pluginbase" target="_blank" rel="noopener">A simple but flexible plugin system for Python.</a></li><li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">Python Classes</a></li><li><a href="http://www.wklken.me/posts/2013/08/18/python-extra-functools.html" target="_blank" rel="noopener">PYTHON-进阶-FUNCTOOLS模块小结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-插件式程序结构设计&quot;&gt;Python 插件式程序结构设计&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;小姐姐，你的插件掉了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文源码在 &lt;a href=&quot;github/wangshub&quot;&gt;github/wangs
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Cerebro插件之电影磁力搜索神器</title>
    <link href="http://thinkhard.tech/2018/03/31/Cerebro%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%94%B5%E5%BD%B1%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2%E7%A5%9E%E5%99%A8/"/>
    <id>http://thinkhard.tech/2018/03/31/Cerebro插件之电影磁力搜索神器/</id>
    <published>2018-03-31T07:34:51.000Z</published>
    <updated>2019-04-04T10:10:23.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cerebro-插件之电影磁力搜索神器">Cerebro 插件之电影磁力搜索神器</h1><blockquote><p>Cerebro plugin to search torrent of movies 什么？看个片儿还要打开网页慢慢找?！</p></blockquote><p>这周在学 Node.js, 看了 <span class="citation" data-cites="carlos-wong">[@carlos-wong]</span>(https://github.com/carlos-wong) 推荐的<a href="https://eloquentjavascript.net" target="_blank" rel="noopener">《Eloquent JavaScript》</a> 这本书的前几章，就抑制不住想写点什么练手。<a href="https://github.com/KELiON/cerebro" target="_blank" rel="noopener">Cerebro</a> 是一个跨平台的快速启动工具（同时支持 Windows、MacOs、Linux），并且可以用 Javascript 定制各种自己喜欢的插件。所以做了一个<strong>电影磁力搜索器</strong>的插件。</p><h2 id="支持平台">支持平台</h2><p>Windows、Linux、MacOS</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/wangshub/cerebro-torrent/raw/master/resource/magnet_demo_2M.gif" alt="截图" title>                </div>                <div class="image-caption">截图</div>            </figure><h2 id="使用">使用</h2><p>在 Cerebro 对话框中输入电影名称，使用键盘上/下按键选择电影，敲击 <code>回车</code> ,磁力链接就会自动复制到剪贴板。</p><ul><li><code>magnet [电影名称][空格]</code></li></ul><h2 id="安装步骤">安装步骤</h2><h3 id="cerebro-内安装插件">Cerebro 内安装插件</h3><ul><li><code>ctrl-space</code> 启动 Cerebro</li><li>输入 <code>plugins torrent</code></li><li>点击 <code>install</code></li></ul><h3 id="源码安装">源码安装</h3><ul><li><p>确保安装好了 <a href="https://github.com/KELiON/cerebro" target="_blank" rel="noopener">Cerebro</a></p></li><li><p><code>Clone</code> 代码到本地，并执行 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wangshub/cerebro-torrent.git</span><br><span class="line">cd cerebro-torrent</span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure></p></li><li><p>将 <code>cerebro-torrent</code> 文件夹拷贝或者软链接到 <code>Cerebro</code> 的 <code>node_module</code> 文件夹下；</p></li><li><p>启动 <code>Cerebro</code>，输入 <code>magnets 葫芦娃</code>，然后敲击 <code>空格</code>；</p></li><li><p>稍等片刻，上下选择，敲击回车就可以将磁力链接复制到剪贴板；</p></li><li><p>打开迅雷或者其他下载器，尽情享受吧！</p></li></ul><h2 id="原理说明">原理说明</h2><ul><li>解析输入的指令；</li><li>利用 async 和 request 库并发爬取网站；</li><li>使用 cheerio 解析网页节点；</li><li>嵌入一段 html 对爬取结果进行显示；</li></ul><h2 id="代码地址">代码地址</h2><p>欢迎 <code>star ⭐️</code> 和 <code>fork 💫</code> 多提 Issue ! <a href="https://github.com/wangshub/cerebro-torrent" target="_blank" rel="noopener">wangshub/cerebro-torrent</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cerebro-插件之电影磁力搜索神器&quot;&gt;Cerebro 插件之电影磁力搜索神器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Cerebro plugin to search torrent of movies 什么？看个片儿还要打开网页慢慢找?！&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://thinkhard.tech/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何解决EDAS上传论文时fonts问题</title>
    <link href="http://thinkhard.tech/2018/02/10/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3EDAS%E4%B8%8A%E4%BC%A0%E8%AE%BA%E6%96%87%E6%97%B6fonts%E9%97%AE%E9%A2%98/"/>
    <id>http://thinkhard.tech/2018/02/10/如何解决EDAS上传论文时fonts问题/</id>
    <published>2018-02-10T09:29:54.000Z</published>
    <updated>2019-04-04T10:10:23.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何解决-edas-上传论文时-pdf-fonts-问题">如何解决 EDAS 上传论文时 PDF fonts 问题</h1><h2 id="问题描述">问题描述</h2><p>今天在上传 <strong>IEEE xplore</strong> 论文时遇到上传字体出错的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload failed: One or more fonts are not embedded. See EDAS FAQ</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fo91n03t4pj20z1079t8y.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="解决办法">解决办法</h2><h3 id="检查字体子集">检查字体子集</h3><p>在 <strong>EDAS</strong> 上传 <strong>Latex</strong> 输出的 PDF 文档时，需要检查 PDF 文档的中所有的字体是否是都是 <strong>已嵌入子集</strong>，检查方式是：</p><ol type="1"><li>用 <code>Acrobat pdf</code>或 <code>Foxit PDF</code>工具打开待检查的 PDF 文件 <code>paper.pdf</code></li><li>打开 <code>文件(file)-&gt;属性(property)-&gt;字体(fonts)</code></li><li>查看所有的字体是否是<strong>已嵌入</strong>或者<strong>已嵌入子集</strong></li></ol><h3 id="更改字体">更改字体</h3><p>如果出现未嵌入的子集</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fo91n01ymzj209k060743.jpg" alt="helvitica" title>                </div>                <div class="image-caption">helvitica</div>            </figure><p><code>helvitica</code>字体未嵌入的原因是论文中使用了<strong>Matlab</strong>生成的图像，<strong>Matlab</strong> 默认使用了 <code>Helvetica</code> 字体，Latex 在引用该图片时，也默认使用了 <code>Helvetica</code> 字体，导致生成的 PDF 文件不能将这个字体嵌入。</p><p><strong>解决步骤：</strong></p><ol type="1"><li><p>如果是引用的图片是pdf格式，需要使用 <code>shell</code> 命令<code>ps2pdf13</code>，将<code>Helvetica</code> 进行转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps2pdf13 -dPDFSETTINGS=/prepress fig_non_embedded.pdf fig_embedded.pdf</span><br></pre></td></tr></table></figure></li><li><p>如果你需要嵌入 <code>*.esp</code>图片文件到你的 Latex 文章中，还需要将<strong>步骤1</strong>中的 <code>*.pdf</code> 转成 <code>*.esp</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdftops -eps -level2 [pdfname] [epsname]</span><br></pre></td></tr></table></figure><h2 id="参考链接">参考链接</h2><p><a href="https://sites.google.com/site/xyzliwen/resource/embed_font_ieee_pdf_explore" target="_blank" rel="noopener">https://sites.google.com/site/xyzliwen/resource/embed_font_ieee_pdf_explore</a></p><p><a href="http://www.mit.edu/~kimo/blog/matlab_figures.html" target="_blank" rel="noopener">http://www.mit.edu/~kimo/blog/matlab_figures.html</a></p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何解决-edas-上传论文时-pdf-fonts-问题&quot;&gt;如何解决 EDAS 上传论文时 PDF fonts 问题&lt;/h1&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;今天在上传 &lt;strong&gt;IEEE xplore&lt;/strong&gt; 论文时遇到上
      
    
    </summary>
    
    
      <category term="latex" scheme="http://thinkhard.tech/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>python装饰器学习笔记</title>
    <link href="http://thinkhard.tech/2018/02/07/python%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://thinkhard.tech/2018/02/07/python装饰器学习笔记/</id>
    <published>2018-02-07T06:02:39.000Z</published>
    <updated>2019-04-04T10:10:23.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-装饰器学习笔记">python 装饰器学习笔记</h1><h2 id="概括">概括</h2><blockquote><p>装饰器的作用就是为已经存在的对象添加额外的功能</p></blockquote><p>我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样就提高了程序的可重复利用性，并增加了程序的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-装饰器学习笔记&quot;&gt;python 装饰器学习笔记&lt;/h1&gt;
&lt;h2 id=&quot;概括&quot;&gt;概括&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;装饰器的作用就是为已经存在的对象添加额外的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以继续调用装饰器来修饰函
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用python对github用户followers分析</title>
    <link href="http://thinkhard.tech/2018/01/15/%E7%94%A8python%E5%AF%B9github%E7%94%A8%E6%88%B7followers%E5%88%86%E6%9E%90/"/>
    <id>http://thinkhard.tech/2018/01/15/用python对github用户followers分析/</id>
    <published>2018-01-15T01:40:16.000Z</published>
    <updated>2019-04-04T10:10:23.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github-用户-followers-分析">github 用户 followers 分析</h1><p><strong>如何分析一个github用户的followers？</strong></p><p>周末手痒，用python分析了一下自己 <a href="https://github.com/wangshub" target="_blank" rel="noopener">github</a> 的 <strong>followers</strong> 用户，统计结果如下</p><h2 id="问题分析">问题分析</h2><p>在github上，一个用户的主页显示如下，主要对如下用户信息进行提取 - 用户名称 - 所在的位置 - 用户仓库、stars、Followers、Following数量 - 去年一年的贡献度</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngknl9cckj20uh0g6wfm.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们需要对上图红框里面的数据进行提取，最直接的方法是使用<code>requests</code>，通过<code>BeautifulSoup</code>对<code>html</code>中的信息进行提取。</p><h2 id="一些弯路">一些弯路</h2><p>最开始没打算用爬虫的方式来获取用户信息，因为github有公开的<a href="https://developer.github.com/v3/" target="_blank" rel="noopener">REST API v3</a>可以对指定用户的信息进行访问，并且已经有打包好的<a href="https://github.com/PyGithub/PyGithub" target="_blank" rel="noopener">PyGithub</a>方便调用。但是我实验下来有如下问题所以放弃使用<a href="https://developer.github.com/v3/" target="_blank" rel="noopener">REST API v3</a> 1. API请求频率有限制，无法运用多线程快速获取批量的用户信息 2. 不知道是不是小BUG，通过API无法获得用户去年一年的贡献度<strong>contributions</strong></p><h2 id="工具">工具</h2><ul><li><strong>python 3</strong> ： 彻底告别我的py2</li><li><strong>BeaufulSoup</strong> ：从HTML或XML文件中提取数据</li><li><strong>Requests</strong> ： 请求网页</li><li><strong>多进程</strong> ： 为了更快</li><li><strong>pyecharts</strong> ： 美的令人窒息的绘图工具</li></ul><h2 id="操作步骤">操作步骤</h2><ol type="1"><li>获取目标用户如<code>https://github.com/wangshub?page=1&amp;tab=followers</code>的所有followers；</li><li>改变<code>page</code>编号，遍历所有用户；</li><li>提取用户关键信息，保存成<code>csv</code>文件；</li><li>数据清洗，过滤；</li><li>利用<a href="https://github.com/pyecharts/pyecharts" target="_blank" rel="noopener">pyecharts</a>绘图；</li><li>进行地点词频统计；</li></ol><h2 id="实验结果">实验结果</h2><p>截止<code>2018-01-15</code>,我的github账号一共有<code>1214</code>名follower，分析结果如下</p><h3 id="用户地点分析">用户地点分析</h3><p>排除掉没有填写地点信息的用户，将中文转化成pinyin后，词云如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngljy93kjj20rs0nwtdv.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>用户基本上都是来自<code>北京、上海、深圳</code>等地</p><h3 id="去年一年用户贡献度分析">去年一年用户贡献度分析</h3><p>如果看用户是否活跃，肯定是看<code>contributions</code>啦</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngln8yfgij20m80b4t94.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看出超过一般多的用户，去年的贡献度都在都在 <strong>1~50</strong> 之间，新的一年要加油啦。其中一年贡献最多的用户是<span class="citation" data-cites="dragon-yuan">[@dragon-yuan]</span>(https://github.com/dragon-yuan), 在2017年有整整 <strong>4,197</strong> 个贡献度，不多说了，前去关注一波。</p><h3 id="用户followers分析">用户followers分析</h3><p>哇，有大牛，别拦着我，我要去点关注了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngmed2kovj20m80b474m.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="用户仓库数量分析">用户仓库数量分析</h3><p>通过爬取用户的仓库数量，进行统计如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fnglp9onenj20m80b4jrs.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到一个有意思的现象，有少数的人仓库数量超过了<strong>1000</strong>，打开这几位仁兄的github主页，大部分是fork的项目，其中仓库最多的用户有<strong>13100个</strong>仓库，叫<span class="citation" data-cites="ProgrammerAndHacker">[@ProgrammerAndHacker]</span>(https://github.com/ProgrammerAndHacker)，他是这么介绍自己的 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I follow best programmer and hacker， </span><br><span class="line">Do you want to hacked by them? ^_^ </span><br><span class="line">Best programmers and hackers are here: </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="用户stars分析">用户stars分析</h3><p>都说点击star是一个好习惯，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngm1vx9oij20m80b4dg8.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>不得不说，github上面还是有点赞狂魔的，这位老铁<span class="citation" data-cites="chenruibin">[@chenruibin]</span>(https://github.com/chenruibin)一共点击了<code>10100</code>个赞，真是好习惯～</p><h3 id="用户-following-分析">用户 following 分析</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fngm814cbgj20m80b43yw.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>同样是<span class="citation" data-cites="ProgrammerAndHacker">[@ProgrammerAndHacker]</span>(https://github.com/ProgrammerAndHacker)这位仁兄，一共follow了<strong>19600</strong>个用户，严重怀疑是不是机器人。</p><h2 id="最后">最后</h2><p>不搞了，我要去写论文了TAT，要代码的，来这里找<a href="https://github.com/wangshub/who_is_following" target="_blank" rel="noopener">https://github.com/wangshub/who_is_following</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;github-用户-followers-分析&quot;&gt;github 用户 followers 分析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;如何分析一个github用户的followers？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周末手痒，用python分析了一下自己 &lt;a href
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
      <category term="github" scheme="http://thinkhard.tech/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>教你用Python来玩微信跳一跳</title>
    <link href="http://thinkhard.tech/2017/12/29/%E6%95%99%E4%BD%A0%E7%94%A8Python%E6%9D%A5%E7%8E%A9%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3/"/>
    <id>http://thinkhard.tech/2017/12/29/教你用Python来玩微信跳一跳/</id>
    <published>2017-12-29T02:02:41.000Z</published>
    <updated>2019-04-04T10:10:23.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="教你用python来玩微信跳一跳">教你用Python来玩微信跳一跳</h1><blockquote><p>2017年12月28日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 demo「跳一跳」。</p></blockquote><p><a href="https://wangshub.github.io" target="_blank" rel="noopener">blog 地址</a></p><p><a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">github 地址</a></p><p><a href="https://zhuanlan.zhihu.com/p/32452473" target="_blank" rel="noopener">知乎专栏</a></p><h2 id="游戏模式">游戏模式</h2><p>这是一个 2.5D 插画风格的益智游戏，玩家可以通过按压屏幕时间的长短来控制这个「小人」跳跃的距离。可能刚开始上手的时候，因为时间距离之间的关系把握不恰当，只能跳出几个就掉到了台子下面。 玩法类似于《flappy bird》</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmxe4gnfhnj20hs0a0t8q.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>如果能精确测量出起始和目标点之间测距离，就可以估计按压的时间来精确跳跃？所以花2个小时写了一个python脚本进行验证</strong></p><h2 id="工具介绍">工具介绍</h2><ul><li>Python 2.7</li><li>Android 手机</li><li>Adb 驱动</li><li>Python Matplot绘图</li></ul><h2 id="原理说明">原理说明</h2><ol type="1"><li>将手机点击到《跳一跳》小程序界面；</li><li>用Adb 工具获取当前手机截图，并用adb将截图pull上来</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/1.png</span><br><span class="line">adb pull /sdcard/1.png .</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>用matplot显示截图；</li><li>用鼠标点击起始点和目标位置，计算像素距离；</li><li>根据像素距离，计算按压时间；</li><li>用Adb工具点击屏幕蓄力一跳；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input swipe x y x y time</span><br></pre></td></tr></table></figure><h2 id="实验结果">实验结果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmxel5dkxvj20u01hcmzx.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="todo">TODO</h2><p>可以对拉上来的图片进行颜色分割，识别小人和目标中心店，这样就不需要手动点击自动弹跳。 事实证明，机器人比人更会玩儿游戏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;教你用python来玩微信跳一跳&quot;&gt;教你用Python来玩微信跳一跳&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2017年12月28日下午，微信发布了 6.6.1 版本，加入了「小游戏」功能，并提供了官方 demo「跳一跳」。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python蔡英文facebook主页分析_by神奇的战士</title>
    <link href="http://thinkhard.tech/2017/12/25/Python%E8%94%A1%E8%8B%B1%E6%96%87facebook%E4%B8%BB%E9%A1%B5%E5%88%86%E6%9E%90-by%E7%A5%9E%E5%A5%87%E7%9A%84%E6%88%98%E5%A3%AB/"/>
    <id>http://thinkhard.tech/2017/12/25/Python蔡英文facebook主页分析-by神奇的战士/</id>
    <published>2017-12-25T07:14:39.000Z</published>
    <updated>2019-04-04T10:10:23.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python蔡英文facebook主页分析by神奇的战士"><strong>Python</strong>蔡英文facebook主页分析(by神奇的战士)</h1><ul><li>博客地址：<a href="https://wangshub.github.io/" target="_blank" rel="noopener">https://wangshub.github.io/</a></li><li>公众号：神奇的战士</li><li>拒绝转载</li></ul><p>用<a href="https://developers.facebook.com/tools/explorer/?method=GET&amp;path=tsaiingwen%2Fposts&amp;version=v2.11" target="_blank" rel="noopener">Facebook Graph API</a>和情绪分析API对蔡英文Facebook主页进行统计分析。</p><h2 id="说明">1. 说明</h2><p><a href="https://baike.baidu.com/item/%E8%94%A1%E8%8B%B1%E6%96%87/353?fr=aladdin" target="_blank" rel="noopener">蔡英文</a>2016年5月20日，蔡英文正式就任台湾地区领导人，成为台湾地区首位女性领导人。</p><p>最近台湾省地区新闻主要有： &gt; 新闻来源： 人民网 &gt; <a href="http://tw.people.com.cn/n1/2017/1222/c14657-29722289.html" target="_blank" rel="noopener">坚决惩治电信诈骗犯罪 切实维护两岸同胞利益</a> &gt; <a href="http://tw.people.com.cn/n1/2017/1221/c14657-29720989.html" target="_blank" rel="noopener">两岸学者评新党人士被调查事件：民进党当局逆流而动终将自掘坟墓</a> &gt; <a href="http://tw.people.com.cn/n1/2017/1126/c14657-29668078.html" target="_blank" rel="noopener">台民众高呼“醒来”，蔡英文不能继续装睡</a> &gt; ...</p><p><strong>但是真实的台湾同胞们是如何看待她的执政表现呢？</strong></p><h2 id="实现工具">2. 实现工具</h2><p>如果是直接爬取脸书的主页，需要进行模拟登陆，反爬虫，代理，验证等等一系列的操作。幸好脸书开放出了图API，可以在一定的请求限制下对脸书上的数据进行访问。注意在多线程请求API的时候，不应该请求的太快，否则会被系统封禁一段时间(不要问我为什么-_-)。</p><p><strong>目前为止使用了如下这些工具：</strong></p><ul><li>python 2.7</li><li><a href="https://developers.facebook.com/tools/explorer/?method=GET&amp;path=tsaiingwen%2Fposts&amp;version=v2.11" target="_blank" rel="noopener">Facebook Graph API</a></li><li>情感分析API</li><li>python 词云</li><li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">python 中文jieba分词</a></li><li>python Pandas</li><li>python 多线程</li></ul><h2 id="数据处理">3. 数据处理</h2><h3 id="posts">3.1 posts</h3><p>首先测试脸书<a href="https://developers.facebook.com/tools/explorer/?method=GET&amp;path=tsaiingwen%2Fposts&amp;version=v2.11" target="_blank" rel="noopener">Facebook Graph API</a>，对蔡小姐的post进行访问，</p><p><strong>curl测试脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X GET \</span><br><span class="line"> "https://graph.facebook.com/v2.11/tsaiingwen/posts?access_token=xxxxxxxxxxxxxxxxx"</span><br></pre></td></tr></table></figure><p><strong>返回示例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"data": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created_time"</span>: <span class="string">"2017-12-24T11:50:06+0000"</span>,</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"蔡想想🐱祝福大家聖誕快樂🎅</span></span><br><span class="line"><span class="string">        #MerryChristmas"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"46251501064_10154820163381065"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">],</span><br><span class="line">"paging": &#123;</span><br><span class="line">    "cursors": &#123;</span><br><span class="line">      "before": "xxxxxx",</span><br><span class="line">      "after": "xxxxx"</span><br><span class="line">    &#125;,</span><br><span class="line">    "next": "xxxxxxxxxxxxxxxxxxxxxx"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以观察到，脸书的每一个post都对应了一个唯一的<strong>id</strong>，由于post的数量是在太多，所以一次请求无法完整获取。根据<strong>next</strong>可以得到下一页的post，直到<strong>next</strong>为空时，表示所有的post获取完毕。</p><p>根据以上原理，我获取了蔡小姐从开通脸书第一天起到今天，发的每一条post。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmsa0xjo5fj21py0ht0ul.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>横坐标：时间</li><li>纵坐标：每天发文数量</li></ul><p>自 <em>2008-10-22T13:55:20+0000</em>蔡小姐发了第一条post以来，一共发了<strong>4120</strong>篇状态，基本上在脸书上还是非常活跃的，在2012年最多一天发送了24条状态，成功刷屏。</p><h3 id="comments">3.2 comments</h3><p>与 <strong>3.1</strong>节类似，每一个post下都会有网友进行评论，那么如何获取所有评论?参考图谱API文档，利用测试脚本</p><p><strong>curl测试脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X GET \</span><br><span class="line"> "https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxxxxxx"</span><br></pre></td></tr></table></figure><p><strong>返回示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"created_time"</span>: <span class="string">"2017-11-13T07:15:25+0000"</span>,</span><br><span class="line">      <span class="attr">"message"</span>: <span class="string">"XXXXXXXX"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"10154729068451065_10154729097936065"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  <span class="string">"paging"</span>: &#123;</span><br><span class="line">  <span class="attr">"cursors"</span>: &#123;</span><br><span class="line">      <span class="attr">"before"</span>: <span class="string">"MTQyNQZDZD"</span>,</span><br><span class="line">      <span class="attr">"after"</span>: <span class="string">"MTM5MQZDZD"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"next"</span>: <span class="string">"https://graph.facebook.com/v2.11/46251501064_10154729068451065/comments?access_token=xxxxxxxx&amp;pretty=0&amp;limit=25&amp;after=MTM5MQZDZD"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每一条评论都对应着唯一的<strong>id</strong>，<strong>next</strong>字段是下一页的评论内容。可以通过设置，选择一夜最多显示100条评论。以此逐级获取所有的评论。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmsadx87t0j20m80goacm.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>横坐标：时间</li><li>纵坐标：每条状态对应的评论数量</li></ul><p>一共爬取了<strong>1830322</strong>条网友评论，最多评论数是<strong>23630</strong>条。其中几次出现了较大值，原因应该是前几次大陆网友自发组织的Facebook远征军去进行<strong>友好访问</strong>了。具体内容可以接下来对这几次的峰值进行详细分析。</p><blockquote><p><strong>相关新闻</strong>： <a href="http://news.163.com/16/0122/19/BDV5H0O200014SEH.html" target="_blank" rel="noopener">帝吧“远征”facebook｜一场表情包大战的爱国交流</a> <a href="https://www.zhihu.com/question/39663757" target="_blank" rel="noopener">如何评价李毅吧 2016 年 1 月 20 日「出征」Facebook？</a></p></blockquote><h2 id="数据分析">4. 数据分析</h2><h3 id="蔡英文主页分析">4.1. 蔡英文主页分析</h3><p>一共获取了蔡小姐的<strong>4120</strong>状态，对json的message字段进行提取，将所有的状态的文字保存进行词云分析，看哪些词汇出现的频率最高。</p><ol type="1"><li>首先利用Pandas对状态的结构数据进行保存；</li><li>读取Pandas表格，获取所有的状态文字；</li><li>利用jieba中文分词库，对所有的文字进行分割；</li><li>显示，保存图片；</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmsaval30qj21041taaom.jpg" alt="蔡小姐词云" title>                </div>                <div class="image-caption">蔡小姐词云</div>            </figure><h3 id="蔡英文评论分析">4.2. 蔡英文评论分析</h3><p>从蔡小姐的post的所有评论当中，我找出了一条评论最多的状态，共有<strong>23630</strong>条评论，对应id为<code>46251501064_10154244975341065</code>，读取对应数据文件，利用词云分析可得</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmt0ape4h1j20b405kt9b.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>看来台湾网友也十分注意<strong>安全开车</strong>，其实这条post的评论区被台湾网友刷屏了，看来怨气挺重呢，哈哈哈哈，霸屏具体内容是 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.政府請正視目前台灣改裝汽機車問題！</span><br><span class="line">排氣管及改裝品可以合法製造 合法販賣 合法進口但裝載車上就不合法 這是什麼邏輯 政府要課稅又要開罰單又是什麼想法？</span><br><span class="line">排氣管或車上零件是原廠被惡意檢舉驗車那是否能跟監理單位或環保署拿今日上班請假損失？</span><br><span class="line">2.環保局 監理站 警察執法單位 專業度嚴重不足 原廠排氣管也開單 叫民眾到監理單位驗車 當做民眾都很有時間？</span><br><span class="line">3.請提供可比照國外變更車體，如重機行李箱、遮陽板、避震、制動煞車系統在不影響行車安全的部份合乎法規</span><br><span class="line">4.如民眾遭受到檢舉達人惡意檢舉，因此需要請假驗車，若屬於惡意檢舉，政府需要支付民眾請假之當天工資</span><br><span class="line">蔡??...您不是希望台灣能跟世界接軌，那請您重視汽機車改裝合法性與可變更性，在不影響行車安全與噪音的&gt; 情況下，請把檢舉改裝還於司法單位執行，才不構成擾民。</span><br></pre></td></tr></table></figure></p><p>既然这条被刷屏了，那就换成最新的一篇post，看看网友又关心啥问题。。。 截止爬取脸书时，最新一条博客是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你有吃過越南生春捲、香蘭娘惹糕或是薑黃飯嗎？它們是來自東南亞各國的美食，現在也是台灣的美食。</span><br><span class="line">今天是國際移民日，前幾天，我邀請了幾位新移民的好朋友來到總統府，一起準備午餐。在這場午餐的約會中，他們和我分享來到台灣生活的點點滴滴，也給我很多建議。</span><br><span class="line">謝謝你們來到台灣，讓我們的社會更多元、更茁壯。祝大家國際移民日快樂！</span><br><span class="line">#留言告訴我你最喜歡的新南向美食</span><br><span class="line">#晚餐文&quot;,</span><br></pre></td></tr></table></figure><p>蔡小姐问网友喜欢吃啥美食，我们来看看网友是如何回复的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/c3a916a7gy1fmt0p0kbpbj218g0m8drx.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>结合最近的新党王炳忠事件，评论中出现了较多<strong>绿色恐怖、王炳忠、白色恐怖</strong>等高频词汇</p><h2 id="todo">5. TODO</h2><p>可以分析的数据还有很多，就先分析这么多了，接下来，可以对评论进行情感分析，看下网友对蔡小姐的评论是积极还是消极的多一些。不过经过这一年的时间来看，应该是消极多一点。哈哈哈</p><p>总结下来，我认为：</p><ol type="1"><li>台湾社会的认知是处于一个分裂的状态；</li><li>不少年轻人还是无脑反对大陆；</li><li>真正理性思考人太少；</li><li>不少人处于岛内的小确幸当中；</li><li>结合最近的新闻来看，猜测台湾的士兵在开战时会不会遇到<strong>为了什么而战斗</strong>的信仰问题。哈哈，一百分将军太逗啦</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python蔡英文facebook主页分析by神奇的战士&quot;&gt;&lt;strong&gt;Python&lt;/strong&gt;蔡英文facebook主页分析(by神奇的战士)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;博客地址：&lt;a href=&quot;https://wangshub.github.io
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>linux驱动器和分区的备份，使用dd命令示例</title>
    <link href="http://thinkhard.tech/2017/12/18/linux%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%92%8C%E5%88%86%E5%8C%BA%E7%9A%84%E5%A4%87%E4%BB%BD%EF%BC%8C%E4%BD%BF%E7%94%A8dd%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B/"/>
    <id>http://thinkhard.tech/2017/12/18/linux驱动器和分区的备份，使用dd命令示例/</id>
    <published>2017-12-18T12:04:51.000Z</published>
    <updated>2019-04-04T10:10:23.692Z</updated>
    
    <content type="html"><![CDATA[<p>dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，下面这篇文章将帮助你学习一些有用的“dd”命令。 ## 1：创建现有分区备份</p><p>以下命令将整个分区/dev/sdb1备份到/opt/sdb1.img文件。</p><p><code># dd if=/dev/sdb1 of=/opt/sdb1.img</code></p><p>样本输出 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16064937+0 records in</span><br><span class="line">16064937+0 records out</span><br><span class="line">8225247744 bytes (8.2 GB) copied, 123.319 s, 66.7 MB/s</span><br></pre></td></tr></table></figure></p><h2 id="恢复备份到其他分区">2：恢复备份到其他分区</h2><p>上面 /opt/sdb1.img备份文件可以恢复到其他分区（/dev/sdb2），我们可以用以下命令恢复。</p><p><code># dd if=/opt/sdb1.img of=/dev/sdb2</code></p><p>样本输出 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16064937+0 records in</span><br><span class="line">16064937+0 records out</span><br><span class="line">8225247744 bytes (8.2 GB) copied, 197.688 s, 41.6 MB/s</span><br></pre></td></tr></table></figure></p><p>现在，你可以看到的/dev/sdb2 是/dev/sdb1 的翻版。 ## 3：创建与现有分区副本</p><p>我们可以直接从现有的分区副本来分区。以下命令将创建的/dev/sdb1 到 /dev/sdb2 的副本。</p><p><code># dd if=/dev/sdb1 of=/dev/sdb2</code></p><p>样本输出 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16064937+0 records in</span><br><span class="line">16064937+0 records out</span><br><span class="line">8225247744 bytes (8.2 GB) copied, 221.431 s, 37.1 MB/s</span><br></pre></td></tr></table></figure></p><h2 id="创建现有的硬盘克隆">4：创建现有的硬盘克隆</h2><p>以下命令将复制前446个字节这是MBR从第一个磁盘到第二个磁盘。这将创建第二个磁盘引导。 。</p><p><code># dd if=/dev/sda of=/dev/sdb bs=446 count=1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">446 bytes (446 B) copied, 0.00174812 s, 255 kB/s</span><br></pre></td></tr></table></figure><p>现在确保在/dev/sdb的匹配为/dev/sda的分区。一旦做到这一点，您可以使用复制每个分区：</p><p><code># dd if=/dev/sda1 of=/dev/sdb1</code></p><p><code># dd if=/dev/sda2 of=/dev/sdb2</code></p><h2 id="备份和恢复的mbr镜像文件">5：备份和恢复的MBR镜像文件</h2><p>创建使用以下命令MBR的镜像文件的备份。</p><p><code># dd if=/dev/sda of=/opt/backup-mbr-sda.img bs=512 count=1</code></p><p>示例输出 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1+0 records in</span><br><span class="line">1+0 records out</span><br><span class="line">512 bytes (512 B) copied, 0.0115243 s, 44.4 kB/s</span><br></pre></td></tr></table></figure></p><p>接下来的步骤是MBR恢复到不同的磁盘，使用下面的命令来做到这一点。</p><p><code># dd if=/opt/backup-mbr-sda.img of=/dev/sdb bs=446 count=1</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dd命令是Linux发行版非常简单的备份工具。 “dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 dd 命令是Linux发行版非常简单的备份工具。该“dd”工具简单的拷贝标准输入到标准输出，在512字节块读取。 用dd命令，我们可以创建整盘，磁盘驱动器等备份，
      
    
    </summary>
    
    
      <category term="linux" scheme="http://thinkhard.tech/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python数字图像处理-图像噪声与去噪算法</title>
    <link href="http://thinkhard.tech/2017/12/16/python%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0%E4%B8%8E%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95/"/>
    <id>http://thinkhard.tech/2017/12/16/python数字图像处理-图像噪声与去噪算法/</id>
    <published>2017-12-16T09:19:29.000Z</published>
    <updated>2019-04-04T10:10:23.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python数字图像处理-图像噪声与去噪算法">python数字图像处理-图像噪声与去噪算法</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e6accc01f.png" alt="figure_1.png" title>                </div>                <div class="image-caption">figure_1.png</div>            </figure><h2 id="图像噪声">图像噪声</h2><h3 id="椒盐噪声">椒盐噪声</h3><p><strong>概述：</strong> 椒盐噪声（salt &amp; pepper noise）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，产生该噪声的算法也比较简单。</p><p>给一副数字图像加上椒盐噪声的步骤如下：</p><ol type="1"><li>指定信噪比 SNR （其取值范围在[0, 1]之间）</li><li>计算总像素数目 SP， 得到要加噪的像素数目 NP = SP * (1-SNR)</li><li>随机获取要加噪的每个像素位置P（i, j）</li><li>指定像素值为255或者0。</li><li>重复3,4两个步骤完成所有像素的NP个像素</li><li>输出加噪以后的图像</li></ol><h3 id="高斯噪声">高斯噪声</h3><p><strong>概述：</strong> 加性高斯白噪声(Additive white Gaussian noise，AWGN)在通信领域中指的是一种功率谱函数是常数(即白噪声), 且幅度服从高斯分布的噪声信号. 这类噪声通常来自感光元件, 且无法避免.</p><h2 id="去噪算法">去噪算法</h2><h3 id="中值滤波">中值滤波</h3><p><strong>概述：</strong> 中值滤波是一种非线性空间滤波器, 它的响应基于图像滤波器包围的图像区域中像素的统计排序, 然后由统计排序结果的值代替中心像素的值. 中值滤波器将其像素邻域内的灰度中值代替代替该像素的值. 中值滤波器的使用非常普遍, 这是因为对于一定类型的随机噪声, 它提供了一种优秀的去噪能力, 比小尺寸的均值滤波器模糊程度明显要低. 中值滤波器对处理脉冲噪声(也称椒盐噪声)非常有效, 因为该噪声是以黑白点叠加在图像上面的.</p><p>与中值滤波相似的还有最大值滤波器和最小值滤波器.</p><h3 id="均值滤波">均值滤波</h3><p><strong>概述：</strong> 均值滤波器的输出是包含在滤波掩模领域内像素的简单平均值. 均值滤波器最常用的目的就是减噪. 然而, 图像边缘也是由图像灰度尖锐变化带来的特性, 所以均值滤波还是存在不希望的边缘模糊负面效应.</p><p>均值滤波还有一个重要应用, 为了对感兴趣的图像得出一个粗略描述而模糊一幅图像. 这样, 那些较小物体的强度与背景揉合在一起了, 较大物体变得像斑点而易于检测.掩模的大小由即将融入背景中的物体尺寸决定.</p><h3 id="代码">代码</h3><p>见<a href="https://github.com/wangshub/python-image-process" target="_blank" rel="noopener">https://github.com/wangshub/python-image-process</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python数字图像处理-图像噪声与去噪算法&quot;&gt;python数字图像处理-图像噪声与去噪算法&lt;/h1&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
       
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
      <category term="algorithm" scheme="http://thinkhard.tech/tags/algorithm/"/>
    
      <category term="image" scheme="http://thinkhard.tech/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>python数字图像处理-图像的基本结构和基础知识</title>
    <link href="http://thinkhard.tech/2017/12/16/python%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://thinkhard.tech/2017/12/16/python数字图像处理-图像的基本结构和基础知识/</id>
    <published>2017-12-16T09:10:39.000Z</published>
    <updated>2019-04-04T10:10:23.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字图像处理-图像的基本结构和基础知识">数字图像处理-图像的基本结构和基础知识</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e2a04b0bc.bmp" alt="LenaRGB.bmp" title>                </div>                <div class="image-caption">LenaRGB.bmp</div>            </figure><h2 id="一python实现bmp图像的读取和显示">一、python实现BMP图像的读取和显示</h2><p>BMP文件格式，又称为Bitmap（位图）或是DIB(Device-Independent Device，设备无关位图)，是Windows系统中广泛使用的图像文件格式。由于它可以不作任何变换地保存图像像素域的数据，因此成为我们取得RAW数据的重要来源。Windows的图形用户界面（graphical user interfaces）也在它的内建图像子系统GDI中对BMP格式提供了支持。</p><p>BMP文件的数据按照从文件头开始的先后顺序分为四个部分：</p><ol type="1"><li><p><strong>bmp文件头(bmp file header)</strong> ：提供文件的格式、大小等信息</p></li><li><p><strong>位图信息头(bitmap information)</strong>：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息</p></li><li><p><strong>调色板(color palette)</strong>：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表</p></li><li><p><strong>位图数据(bitmap data)</strong>：就是图像数据</p></li></ol><blockquote><p>参考链接 <a href="https://zh.wikipedia.org/wiki/BMP" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/BMP</a></p></blockquote><h2 id="二python统计图像的直方图">二、python统计图像的直方图</h2><p><strong>图像直方图</strong>（英语：Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布。这种直方图中，横坐标的左侧为纯黑、较暗的区域，而右侧为较亮、纯白的区域。因此，一张较暗图片的图像直方图中的数据多集中于左侧和中间部分；而整体明亮、只有少量阴影的图像则相反。 很多数码相机提供图像直方图功能，拍摄者可以通过观察图像直方图了解到当前图像是否过分曝光或者曝光不足。 计算机视觉领域常借助图像直方图来实现图像的二值化</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e49c0fd38.png" alt="2 统计直方图.png" title>                </div>                <div class="image-caption">2 统计直方图.png</div>            </figure><blockquote><p>参考链接 <a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE#%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE</a></p></blockquote><h2 id="三rgbyiqhsixyz颜色空间">三、RGB、YIQ、HSI、XYZ颜色空间</h2><h3 id="yiq">YIQ</h3><p>YIQ色彩空间通常被北美的电视系统所采用，属于NTSC（National Television Standards Committee）系统。这里Y不是指黄色，而是指颜色的明视度（Luminance），即亮度（Brightness）。其实Y就是图像的灰度值（Gray value），而I和Q则是指色调（Chrominance），即描述图像色彩及饱和度的属性。在YIQ系统中，Y分量代表图像的亮度信息，I、Q两个分量则携带颜色信息，I分量代表从橙色到青色的颜色变化，而Q分量则代表从紫色到黄绿色的颜色变化。</p><p>NTSC制为了进一步压缩色度带宽，用色差信号I,Q来代替U,V。若采用U,V色差信号，则色度、亮度信号的共频带部分极大，低端不共频带的亮度信号带宽很小，亮、色干扰大。将彩色图像从RGB转换到YIQ色彩空间，可以把彩色图像中的亮度信息与色度信息分开，分别独立进行处理。</p><p>RGB和YIQ的对应关系用下面的方程式表示： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y=0.299R+0.587G+0.114B</span><br><span class="line">I=0.596R-0.274G-0.322B</span><br><span class="line">Q=0.211R-0.523G+0.312B</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e49c3a072.png" alt="3 YIQ分量.png" title>                </div>                <div class="image-caption">3 YIQ分量.png</div>            </figure><h3 id="hsi">HSI</h3><ul><li><p>色调H（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受，如红色、绿色、蓝色等，它也可表示一定范围的颜色，如暖色、冷色等。</p></li><li><p>饱和度S（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的，加入白光会稀释饱和度。饱和度越大，颜色看起来就会越鲜艳，反之亦然。</p></li><li><p>亮度I（Intensity）：对应成像亮度和图像灰度，是颜色的明亮程度。 若将RGB单位立方体沿主对角线进行投影，可得到六边形，这样，原来沿主对角线的灰色都投影到中心白色点，而红色点（1，0，0）则位于右边的角上，绿色点（0，1，0）位于左上角，蓝色点（0，0，1）则位于左下角。</p></li></ul><p>HSI颜色模型的双六棱锥表示，I是强度轴，色调H的角度范围为[0，2π]，其中，纯红色的角度为0，纯绿色的角度为2π/3，纯蓝色的角度为4π/3。饱和度S是颜色空间任一点距I轴的距离。当然，若用圆表示RGB模型的投影，则HSI色度空间为双圆锥3D表示。</p><p>注意： 当强度I=0时，色调H、饱和度S无定义；当S=0时，色调H无定义。 HSI模型也可用圆柱来表示，如图9-5所示。若将其展开，并按图9-6进行定义，可得到HSI调色板。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e15929e62.jpg" alt="HSI_Formula.jpg" title>                </div>                <div class="image-caption">HSI_Formula.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e49c37be5.png" alt="5 HSI分量.png" title>                </div>                <div class="image-caption">5 HSI分量.png</div>            </figure><h3 id="xyz">XYZ</h3><p>国际照明委员会(CIE)在进行了大量正常人视觉测量和统计,1931年建立了"标准色度观察者"， 从而奠定了现代CIE标准色度学的定量基础。由于"标准色度观察者"用来标定光谱色时出现负 刺激值，计算不便，也不易理解，因此1931年CIE在RGB系统基础上，改用三个假想的原色X、Y、 Z建立了一个新的色度系统。将它匹配等能光谱的三刺激值，定名为"CIE1931 标准色度观察者 光谱三刺激值"，简称为"CIE1931标准色度观察者"。这一系统叫做"CIE1931标准色度系统"或称为" 2° 视场XYZ色度系统"。CIEXYZ颜色空间稍加变换就可得到Yxy色彩空间，其中Y取三刺激值中Y的值， 表示亮度，x、y反映颜色的色度特性。定义如下：在色彩管理中，选择与设备无关的颜色空间是 十分重要的，与设备无关的颜色空间由国际照明委员会(CIE)制定，包括CIEXYZ和CIELAB两个标准。 它们包含了人眼所能辨别的全部颜色。而且，CIEYxy测色制的建立给定量的确定颜色创造了条件。 但是，在这一空间中，两种不同颜色之间的距离值并不能正确地反映人们色彩感觉差别的大小， 也就是说在CIEYxy色厦图中，在 不同的位置不同方向上颜色的宽容量是不同的，这就是Yxy颜色空间 的不均匀性。这一缺陷的存在，使得在Yxy及XYZ空间不能直观地评价颜色。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e26b25e70.jpg" alt="xyz.jpg" title>                </div>                <div class="image-caption">xyz.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/12/16/5a34e49c3b8d4.png" alt="6 XYZ分量.png" title>                </div>                <div class="image-caption">6 XYZ分量.png</div>            </figure><h2 id="四python代码实现">四、python代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_bmp</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># BMP 的读取与显示</span></span><br><span class="line">    plt.figure(<span class="string">"LenaRGB.bmp"</span>)</span><br><span class="line">    plt.title(<span class="string">"LenaRGB.bmp"</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_hist</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 直方图</span></span><br><span class="line">    plt.figure(<span class="string">"Lena hist"</span>)</span><br><span class="line">    plt.title(<span class="string">'Lena hist figure'</span>)</span><br><span class="line">    arr = img.flatten()</span><br><span class="line">    n, bins, patches = plt.hist(arr, bins=<span class="number">256</span>, normed=<span class="number">1</span>, facecolor=<span class="string">'green'</span>, alpha=<span class="number">0.75</span>)  </span><br><span class="line">    plt.show()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rgb</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 显示RGB图像    </span></span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.title(<span class="string">'orignal'</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.title(<span class="string">'R'</span>)</span><br><span class="line">    plt.imshow(img[:, :, <span class="number">0</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.title(<span class="string">'G'</span>)</span><br><span class="line">    plt.imshow(img[:, :, <span class="number">1</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.title(<span class="string">'B'</span>)</span><br><span class="line">    plt.imshow(img[:, :, <span class="number">2</span>], cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shou_yiq</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 显示YIQ分量</span></span><br><span class="line">    R = np.mat(img[:, :, <span class="number">0</span>])</span><br><span class="line">    G = np.mat(img[:, :, <span class="number">1</span>])</span><br><span class="line">    B = np.mat(img[:, :, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># aH = np.array([(0.299, 0.587, 0.114), </span></span><br><span class="line">    <span class="comment">#               (0.596, -0.274, -0.322), </span></span><br><span class="line">    <span class="comment">#               (0.211, -0.523, 0.312)])</span></span><br><span class="line">    Y = <span class="number">0.299</span> * R + <span class="number">0.587</span> * G + <span class="number">0.114</span> * B</span><br><span class="line">    I = <span class="number">0.596</span> * R - <span class="number">0.274</span> * G - <span class="number">0.322</span> * B</span><br><span class="line">    Q = <span class="number">0.211</span> * R - <span class="number">0.523</span> * G - <span class="number">0.312</span> * B</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.title(<span class="string">'orignal'</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.title(<span class="string">'Y'</span>)</span><br><span class="line">    plt.imshow(Y, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.title(<span class="string">'I'</span>)</span><br><span class="line">    plt.imshow(I, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.title(<span class="string">'Q'</span>)</span><br><span class="line">    plt.imshow(Q, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="comment"># YIQ = </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_xyz</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 显示YIQ分量</span></span><br><span class="line">    R = np.mat(img[:, :, <span class="number">0</span>])</span><br><span class="line">    G = np.mat(img[:, :, <span class="number">1</span>])</span><br><span class="line">    B = np.mat(img[:, :, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># aH = np.array([(0.299, 0.587, 0.114), </span></span><br><span class="line">    <span class="comment">#               (0.596, -0.274, -0.322), </span></span><br><span class="line">    <span class="comment">#               (0.211, -0.523, 0.312)])</span></span><br><span class="line">    X = <span class="number">0.490</span> * R + <span class="number">0.310</span> * G + <span class="number">0.200</span> * B</span><br><span class="line">    Y = <span class="number">0.177</span> * R + <span class="number">0.813</span> * G + <span class="number">0.011</span> * B</span><br><span class="line">    Z = <span class="number">0.000</span> * R + <span class="number">0.010</span> * G + <span class="number">0.990</span> * B</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.title(<span class="string">'orignal'</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.title(<span class="string">'X'</span>)</span><br><span class="line">    plt.imshow(X, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.title(<span class="string">'Y'</span>)</span><br><span class="line">    plt.imshow(Y, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.title(<span class="string">'Z'</span>)</span><br><span class="line">    plt.imshow(Z, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_hsi</span><span class="params">(img)</span>:</span></span><br><span class="line">    rows, cols, dims = img.shape </span><br><span class="line">    R = np.mat(img[:, :, <span class="number">0</span>])</span><br><span class="line">    G = np.mat(img[:, :, <span class="number">1</span>])</span><br><span class="line">    B = np.mat(img[:, :, <span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    I = (R + G + B) / <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    E = np.mat(np.ones([rows, cols]))</span><br><span class="line">    minRGB = np.mat(img.min(<span class="number">2</span>))</span><br><span class="line">    lv = <span class="number">3</span> * E / (R + G + B)</span><br><span class="line">    S = E - np.multiply(lv, minRGB)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># S = np.mat(np.zeros([rows, cols]))</span></span><br><span class="line">    <span class="comment"># for i in range(rows):</span></span><br><span class="line">    <span class="comment">#     for j in range(cols):</span></span><br><span class="line">    <span class="comment">#         S[i, j] = 1 - 3/(R[i, j] + G[i, j] + B[i, j]) * min([R[i, j], G[i, j], B[i, j]])</span></span><br><span class="line"></span><br><span class="line">    H = np.mat(np.zeros([rows, cols]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            up = (R[i, j] - G[i, j] + R[i, j] - B[i, j]) / <span class="number">2</span></span><br><span class="line">            down = (R[i, j] - G[i, j])**<span class="number">2</span> + (R[i, j] - B[i, j]) * (G[i, j] - B[i, j])**<span class="number">0.5</span></span><br><span class="line">            H[i, j] = math.acos(up / down)</span><br><span class="line">            </span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.title(<span class="string">'orignal'</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.title(<span class="string">'I'</span>)</span><br><span class="line">    plt.imshow(I, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.title(<span class="string">'S'</span>)</span><br><span class="line">    plt.imshow(S, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.title(<span class="string">'H'</span>)</span><br><span class="line">    plt.imshow(H, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    img = np.array(Image.open(<span class="string">'/home/sun/Desktop/PycharmProjects/Digital_image_process_lxk/lab1/LenaRGB.bmp'</span>))</span><br><span class="line">    rows, cols, dims = img.shape</span><br><span class="line">    <span class="keyword">print</span> img.shape  </span><br><span class="line">    <span class="keyword">print</span> img.dtype </span><br><span class="line">    <span class="keyword">print</span> img.size </span><br><span class="line">    <span class="keyword">print</span> type(img)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># show_bmp(img)</span></span><br><span class="line">    <span class="comment"># show_hist(img)</span></span><br><span class="line">    <span class="comment"># show_rgb(img)</span></span><br><span class="line">    <span class="comment"># shou_yiq(img)</span></span><br><span class="line">    <span class="comment"># show_hsi(img)</span></span><br><span class="line">    <span class="comment"># show_xyz(img)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数字图像处理-图像的基本结构和基础知识&quot;&gt;数字图像处理-图像的基本结构和基础知识&lt;/h1&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
             
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
      <category term="algorithm" scheme="http://thinkhard.tech/tags/algorithm/"/>
    
      <category term="image" scheme="http://thinkhard.tech/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>python：将图片转换成excel文档</title>
    <link href="http://thinkhard.tech/2017/12/14/image-to-excel/"/>
    <id>http://thinkhard.tech/2017/12/14/image-to-excel/</id>
    <published>2017-12-14T13:28:12.000Z</published>
    <updated>2019-04-04T10:10:23.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python将图片转换成excel文档">python：将图片转换成excel文档</h1><h2 id="实现步骤">实现步骤</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/large/c3a916a7gy1fmgmi7aqirj20dd09zmy2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ol type="1"><li>读取图像，获取图像每个像素点的RGB值；</li><li>根据每个像素点的RGB值设置excel每个方格的颜色值；</li><li>根据像素点的坐标，写入excel文件；</li><li>保存退出；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xy</span><span class="params">(row, col)</span>:</span></span><br><span class="line">    table = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">    num1 = col / <span class="number">26</span></span><br><span class="line">    num2 = col % <span class="number">26</span></span><br><span class="line">    <span class="comment"># print num1, num2</span></span><br><span class="line">    <span class="keyword">if</span> num1 == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> table[num2 - <span class="number">1</span>] + str(row)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> table[num1<span class="number">-1</span>] + table[num2 - <span class="number">1</span>] + str(row)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    img = np.array(Image.open(<span class="string">'whale.jpeg'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plt.figure("whale")</span></span><br><span class="line">    <span class="comment"># plt.imshow(img)</span></span><br><span class="line">    <span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">    rows, cols, dims = img.shape</span><br><span class="line">    <span class="keyword">print</span> img.shape  </span><br><span class="line">    <span class="keyword">print</span> img.dtype </span><br><span class="line">    <span class="keyword">print</span> img.size </span><br><span class="line">    <span class="keyword">print</span> type(img)</span><br><span class="line">    <span class="comment"># print img[188, 188, 0]</span></span><br><span class="line"></span><br><span class="line">    excel = xlsxwriter.Workbook(<span class="string">'image_excel.xlsx'</span>)</span><br><span class="line">    cellformat = excel.add_format(&#123;<span class="string">'bg_color'</span>: <span class="string">'#123456'</span>,</span><br><span class="line">                                   <span class="string">'font_color'</span>: <span class="string">'#654321'</span>&#125;)</span><br><span class="line">    worksheet1 = excel.add_worksheet()</span><br><span class="line"></span><br><span class="line">    data = []</span><br><span class="line">    color = [<span class="string">''</span>] * cols</span><br><span class="line">    cellcolor = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            <span class="comment"># print hex(img[i, j, 0]), hex(img[i, j, 1]), hex(img[i, j, 2])</span></span><br><span class="line">            cellcolor = (hex(img[i, j, <span class="number">0</span>]) + hex(img[i, j, <span class="number">1</span>]) + hex(img[i, j, <span class="number">2</span>])).replace(<span class="string">'0x'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="comment"># print cellcolor</span></span><br><span class="line">           </span><br><span class="line">            cellformat = excel.add_format(&#123;<span class="string">'bg_color'</span>: <span class="string">'#'</span>+cellcolor, </span><br><span class="line">                                           <span class="string">'font_color'</span>: <span class="string">'#'</span>+cellcolor&#125;)</span><br><span class="line">           </span><br><span class="line">            <span class="comment"># cellformat = excel.add_format(&#123;'bg_color': '#C6EFCE', </span></span><br><span class="line">            <span class="comment">#                                'font_color': '#006100'&#125;)</span></span><br><span class="line">            </span><br><span class="line">            worksheet1.conditional_format(get_xy(i, j), &#123;<span class="string">'type'</span>: <span class="string">'cell'</span>,</span><br><span class="line">                                                        <span class="string">'criteria'</span>: <span class="string">'&lt;'</span>,</span><br><span class="line">                                                        <span class="string">'value'</span>: <span class="number">50</span>,</span><br><span class="line">                                                        <span class="string">'format'</span>: cellformat&#125;)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># data.append(data_row)</span></span><br><span class="line">    excel.close()    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    <span class="comment"># print get_xy(133, 27)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python将图片转换成excel文档&quot;&gt;python：将图片转换成excel文档&lt;/h1&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;实现步骤&lt;/h2&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img
      
    
    </summary>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python check hosts update</title>
    <link href="http://thinkhard.tech/2017/07/20/python-check-hosts-update/"/>
    <id>http://thinkhard.tech/2017/07/20/python-check-hosts-update/</id>
    <published>2017-07-20T14:33:15.000Z</published>
    <updated>2019-04-04T10:10:23.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用python检查-hosts-更新">用Python检查 <em>hosts</em> 更新</h1><p>最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者是否有更新。所以这种苦力活就让Python干好了。</p><h2 id="hosts地址">hosts地址</h2><p><em>hosts_info.py</em> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts_source = [<span class="string">"https://raw.githubusercontent.com/racaljk/hosts/master/hosts"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="检查hosts是否有更新">检查hosts是否有更新</h2><p><em>check_hosts.py</em> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> .hosts_info <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> filecmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hosts_download</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'hosts'</span>):</span><br><span class="line">        hosts_name = <span class="string">'hosts_new'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hosts_name = <span class="string">'hosts'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">todo:</span> overtime detection</span></span><br><span class="line">    f = urllib2.urlopen(hosts_source[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"downloading hosts"</span></span><br><span class="line">    <span class="keyword">with</span> open(hosts_name, <span class="string">"wb"</span>) <span class="keyword">as</span> code:</span><br><span class="line">       code.write(f.read())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_hosts_new</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    hosts_download()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'hosts'</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'oops, hosts not exists'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(<span class="string">'hosts'</span>) <span class="keyword">and</span> (<span class="keyword">not</span> os.path.exists(<span class="string">'hosts_new'</span>)):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'first run, only one hosts file'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(<span class="string">'hosts'</span>) <span class="keyword">and</span> (os.path.exists(<span class="string">'hosts_new'</span>)):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'compare hosts &amp; hosts_new'</span></span><br><span class="line">        diff_status = filecmp.cmp(<span class="string">'hosts'</span>, <span class="string">'hosts_new'</span>)</span><br><span class="line">        <span class="keyword">if</span> diff_status:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'same file'</span></span><br><span class="line">            os.remove(<span class="string">'hosts_new'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'diff file'</span></span><br><span class="line">            os.remove(<span class="string">'hosts'</span>)</span><br><span class="line">            os.rename(<span class="string">'hosts_new'</span>, <span class="string">"hosts"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h2 id="主程序调用">主程序调用</h2><p><em>main.py</em> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> check_hosts.check_hosts <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">diff_status = is_hosts_new()</span><br><span class="line"><span class="keyword">if</span> diff_status:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"new hosts !"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'code: '</span>,diff_status</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用python检查-hosts-更新&quot;&gt;用Python检查 &lt;em&gt;hosts&lt;/em&gt; 更新&lt;/h1&gt;
&lt;p&gt;最近各种代理纷纷关闭，常见的翻墙方式就剩lantern和更改hosts的方式依旧坚挺，关注了一些更新hosts的git仓库，但是又不想登录网页查看原作者
      
    
    </summary>
    
      <category term="Python" scheme="http://thinkhard.tech/categories/Python/"/>
    
      <category term="VPN" scheme="http://thinkhard.tech/categories/Python/VPN/"/>
    
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="VPN" scheme="http://thinkhard.tech/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>python mail sender</title>
    <link href="http://thinkhard.tech/2017/07/20/python-mail-sender/"/>
    <id>http://thinkhard.tech/2017/07/20/python-mail-sender/</id>
    <published>2017-07-20T14:22:06.000Z</published>
    <updated>2019-04-04T10:10:23.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-发送邮件">python 发送邮件</h1><h2 id="配置服务器和邮箱">配置服务器和邮箱</h2><blockquote><p>mail_info.py <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mail_host = <span class="string">'smtp.yeah.net'</span></span><br><span class="line">mail_user = <span class="string">'mail_name'</span></span><br><span class="line">mail_pass = <span class="string">'mail_password'</span></span><br><span class="line"></span><br><span class="line">sender = <span class="string">'mail_name@yeah.net'</span></span><br><span class="line">receivers = [<span class="string">'target@mail.com'</span>]</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="发送邮件">发送邮件</h2><blockquote><p>mail_trans.py <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .mail_info <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail_text_send</span><span class="params">(title, text)</span>:</span></span><br><span class="line">    message = MIMEText(text, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = title</span><br><span class="line">    message[<span class="string">'From'</span>] = sender</span><br><span class="line">    message[<span class="string">'To'</span>] = receivers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        smtpObj = smtplib.SMTP()</span><br><span class="line">        <span class="comment"># connect host</span></span><br><span class="line">        smtpObj.connect(mail_host, <span class="number">25</span>)</span><br><span class="line">        <span class="comment"># login host</span></span><br><span class="line">        smtpObj.login(mail_user, mail_pass)</span><br><span class="line">        <span class="comment"># send</span></span><br><span class="line">        smtpObj.sendmail(sender, receivers, message.as_string())</span><br><span class="line">        <span class="comment"># quit</span></span><br><span class="line">        smtpObj.quit()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> smtplib.SMTPException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="主程序调用">主程序调用</h2><blockquote><p>main.py <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mail_trans <span class="keyword">import</span> *</span><br><span class="line">mail_text_send(<span class="string">'title'</span>, <span class="string">'hello world!'</span>)</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-发送邮件&quot;&gt;python 发送邮件&lt;/h1&gt;
&lt;h2 id=&quot;配置服务器和邮箱&quot;&gt;配置服务器和邮箱&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;mail_info.py &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://thinkhard.tech/categories/Python/"/>
    
      <category term="Code" scheme="http://thinkhard.tech/categories/Python/Code/"/>
    
      <category term="Mail" scheme="http://thinkhard.tech/categories/Python/Code/Mail/"/>
    
    
      <category term="Code" scheme="http://thinkhard.tech/tags/Code/"/>
    
      <category term="Python" scheme="http://thinkhard.tech/tags/Python/"/>
    
      <category term="Mail" scheme="http://thinkhard.tech/tags/Mail/"/>
    
  </entry>
  
  <entry>
    <title>使用python备份博客图床图片</title>
    <link href="http://thinkhard.tech/2017/06/05/use-python-to-backup-markdown-images/"/>
    <id>http://thinkhard.tech/2017/06/05/use-python-to-backup-markdown-images/</id>
    <published>2017-06-05T15:09:29.000Z</published>
    <updated>2019-04-04T10:10:23.770Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p># 说明</p><p>最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误.<br> 所以花了一点时间,用python <em>正则匹配</em> markdown中图片链接,然后下载图片保存到本地文件夹<code>img</code>中.这样就不用担心图片失效啦,当我找到稳定的图床,可以随时把这些图片再上传更新,美滋滋~~~</p><h1 id="功能">功能</h1><ul><li><input type="checkbox" disabled checked><code>.md</code>文件自动搜索</li><li><input type="checkbox" disabled checked>正则匹配图片链接</li><li><input type="checkbox" disabled checked>爬取图片内容</li><li><input type="checkbox" disabled checked>保存文本到本地</li></ul><h1 id="步骤">步骤</h1><p><strong>读取文件</strong> =&gt; <strong>正则匹配</strong> =&gt; <strong>图片下载</strong> =&gt; <strong>保存本地</strong></p><h1 id="python代码">python代码</h1><p>详细见我的github地址: www.github.com/wangshub</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(path, word)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        fp = os.path.join(path, filename)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(fp) <span class="keyword">and</span> word <span class="keyword">in</span> filename:</span><br><span class="line">            <span class="keyword">print</span> fp</span><br><span class="line">            download(str(fp))</span><br><span class="line">        <span class="keyword">elif</span> os.path.isdir(fp):</span><br><span class="line">            search(fp, word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="comment"># filename = "test"</span></span><br><span class="line">    name = file_path.split(<span class="string">u"/"</span>)</span><br><span class="line">    filename = name[<span class="number">-1</span>]</span><br><span class="line">    f_md = open(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># all text of md file</span></span><br><span class="line">    text = f_md.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment"># regex</span></span><br><span class="line">    img_reg = <span class="string">r'\!&#123;1&#125;\[(.*?)\]\((.*?)\)'</span></span><br><span class="line">    result = re.findall(<span class="string">'!\[(.*)\]\((.*)\)'</span>, text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</span><br><span class="line">        img_quote = result[i][<span class="number">0</span>]</span><br><span class="line">        img_url = result[i][<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># download img</span></span><br><span class="line">        request = urllib2.Request(img_url)</span><br><span class="line">        response = urllib2.urlopen(request)</span><br><span class="line">        img_contents = response.read()</span><br><span class="line">        <span class="comment"># img name spell</span></span><br><span class="line">        urlname = img_url.split(<span class="string">u"/"</span>)</span><br><span class="line">        img_name = filename + <span class="string">'_'</span> + \</span><br><span class="line">            str(i) + <span class="string">'_'</span> + img_quote + str(urlname[len(urlname) - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">print</span> img_name, <span class="string">'~~~'</span>, img_url</span><br><span class="line">        <span class="comment"># write to file</span></span><br><span class="line">        f_img = open(<span class="string">'img/'</span> + img_name, <span class="string">'wb'</span>)</span><br><span class="line">        f_img.write(img_contents)</span><br><span class="line">        f_img.close()</span><br><span class="line">    f_md.close()</span><br><span class="line"></span><br><span class="line">search(sys.argv[<span class="number">1</span>], <span class="string">'.md'</span>)</span><br></pre></td></tr></table></figure><h1 id="食用方法">食用方法</h1><p><code>python md_image_bacup.py /path/to/your/file/</code></p><h1 id="作者">作者</h1><blockquote><p>Author : <em>WangSong</em><br> E-mail : <em>easternslope@yeah.net</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;# 说明&lt;/p&gt;
&lt;p&gt;最近在写markdown文档的过程中,经常需要插入一些图片.因为托管博客的服务器空间有限,所以上传图片到图床再插入到markdown中.有时候又插入网上的图片,这些图片随时可能失效.导致我的博客网站显示图片错误.&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://thinkhard.tech/categories/python/"/>
    
      <category term="markdown" scheme="http://thinkhard.tech/categories/python/markdown/"/>
    
      <category term="code" scheme="http://thinkhard.tech/categories/python/markdown/code/"/>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
      <category term="code" scheme="http://thinkhard.tech/tags/code/"/>
    
      <category term="markdown" scheme="http://thinkhard.tech/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>从机sshfs访问主机文件系统</title>
    <link href="http://thinkhard.tech/2017/05/31/sshfs-mount-net-disk/"/>
    <id>http://thinkhard.tech/2017/05/31/sshfs-mount-net-disk/</id>
    <published>2017-05-31T13:16:00.000Z</published>
    <updated>2019-04-04T10:10:23.769Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p># 说明</p><p>需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到<code>scp</code>命令 <code>scp -r /主机/文件 从机名@192.168.x.x:从机目录/</code>.利用<code>sshfs</code>可以直接在从机进行编译,省略拷贝步骤.</p><h1 id="系统结构框图">系统结构框图</h1><p><strong>Linux 主机</strong> <em>&lt;=====&gt;</em> <strong>Linux 从机</strong></p><h1 id="操作步骤">操作步骤</h1><ol type="1"><li>主机</li></ol><ul><li><code>sudo apt-get install openssh-server</code></li><li><code>ifconfig -a</code>获取局域网内 <em>IP地址</em></li></ul><ol start="2" type="1"><li>从机</li></ol><ul><li><code>sudo apt-get install sshfs</code></li><li><code>sshfs -o idmap=user -o reconnect host_name@192.168.20.236:/path/to/your/workspace /path/to/your/workspace</code></li></ul><ol start="3" type="1"><li>现在可以从从机开心地访问主机文件了</li></ol><blockquote><p><em>author</em> : Wangsong<br> <em>mail</em> : easternslope@yeah.net</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;# 说明&lt;/p&gt;
&lt;p&gt;需要在PC主机(Linux)上编写代码,每次都要将代码拷贝到从机(Linux)上编译运行程序.这里用到&lt;code&gt;scp&lt;/code&gt;命令 &lt;code&gt;scp -r /主机/文件 从机名@192.168.x.x:从
      
    
    </summary>
    
      <category term="linux" scheme="http://thinkhard.tech/categories/linux/"/>
    
      <category term="tool" scheme="http://thinkhard.tech/categories/linux/tool/"/>
    
    
      <category term="linux" scheme="http://thinkhard.tech/tags/linux/"/>
    
      <category term="tool" scheme="http://thinkhard.tech/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>python 数据结构之二叉搜索树</title>
    <link href="http://thinkhard.tech/2017/05/29/python-data-structure-BST/"/>
    <id>http://thinkhard.tech/2017/05/29/python-data-structure-BST/</id>
    <published>2017-05-29T15:06:12.000Z</published>
    <updated>2019-04-04T10:10:23.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树定义">二叉搜索树定义</h1><p>一颗二叉搜索树是以二叉树来组织的,每个节点除了 <em>Key</em> 还包括 <em>左孩子</em>, <em>右孩子</em>, <em>父节点</em> 等信息. BST满足限制条件: <em>对于任意节点的X,他的 <strong>左子树中关键字最大值&lt;=X.key</strong> , <strong>右子树关键字最小值&gt;=X.key</strong></em> 这个关系表示如下<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-anatomy.png" alt="二叉" title>                </div>                <div class="image-caption">二叉</div>            </figure><br> 根据上图定义,一个二叉搜索树的例子是<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-subtree-count.png" alt title>                </div>                <div class="image-caption"></div>            </figure></p><h1 id="二叉树操作">二叉树操作</h1><ul><li>查询</li><li>插入</li><li>删除</li></ul><h2 id="查询搜索">查询(搜索)</h2><p>二叉树搜索采用递归的方式来进行查询,根据二叉搜索树的定义: 左子树存储小值, 右子树存储大值,一个完整的二叉搜索示意图如下<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-search.png" alt title>                </div>                <div class="image-caption"></div>            </figure><br> 可以写成 <em>伪代码</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TREE-SEARCH(x, k)</span><br><span class="line">  <span class="keyword">if</span> x == NULL  <span class="keyword">or</span> k == x.key</span><br><span class="line">    <span class="keyword">return</span> x  </span><br><span class="line">  <span class="keyword">if</span> k &lt; x.key</span><br><span class="line">    <span class="keyword">return</span> TREE-SEARCH(x.left)</span><br><span class="line">  <span class="keyword">if</span> k &gt; x.key</span><br><span class="line">    <span class="keyword">return</span> TREE-SEARCH(x.right)</span><br></pre></td></tr></table></figure><p>转换成python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get</span><span class="params">(self, key, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">            <span class="keyword">return</span> self._get(key, node.left)</span><br><span class="line">        <span class="keyword">elif</span> key &gt; node.key:</span><br><span class="line">            <span class="keyword">return</span> self._get(key, node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return the value paired with 'key'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Worst Case Complexity: O(N)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Balanced Tree Complexity: O(lg N)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self._get(key, self.root)</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>插入和删除比查询呢稍微复杂一些,因为该操作会引起二叉搜索树的大小变化,会改变动态集合的结构.插入呢又比删除稍微容易实现.插入分为两部</p><ul><li>查询插入节点</li><li>改变目标节点附近的数据结构</li></ul><p>插入过程示意图如下<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-insert.png" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>相应的伪代码如下, 输入节点 <em>z</em> , <em>z.key = v</em>, <em>z.left = NULL</em>, <em>z.right = NULL</em>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TREE-INSERT(T, x)</span><br><span class="line">  y = NULL</span><br><span class="line">  x = T.root   <span class="comment"># 从根节点开始</span></span><br><span class="line">  <span class="keyword">while</span> x != NULL</span><br><span class="line">    y = x      <span class="comment"># 保存上一节点</span></span><br><span class="line">    <span class="keyword">if</span> z.key &lt; x.key <span class="comment"># 往左</span></span><br><span class="line">      x = x.left</span><br><span class="line">    <span class="keyword">else</span>             <span class="comment"># 往右</span></span><br><span class="line">      x = x.right</span><br><span class="line"></span><br><span class="line">  z.p = y        <span class="comment"># 父节点</span></span><br><span class="line">  <span class="keyword">if</span> y == NULL   <span class="comment"># tree T 为空</span></span><br><span class="line">    T.root = z</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">    y.left = z</span><br><span class="line">  <span class="keyword">else</span> y.right = z</span><br></pre></td></tr></table></figure><p>程序的运行复杂度取决于二叉树的形状<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-typical.png" alt title>                </div>                <div class="image-caption"></div>            </figure><br> 插入的运行时间取决于二叉搜索树的_高度h_,程序的运行时间_O(h)_ ,所以二叉树形状的好坏直接影响算法的运行时间.</p><p>python代码实现为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_put</span><span class="params">(self, key, val, node)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If we hit the end of a branch, create a new node</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Node(key, val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Follow left branch</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">            node.left = self._put(key, val, node.left)</span><br><span class="line">        <span class="comment"># Follow right branch</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; node.key:</span><br><span class="line">            node.right = self._put(key, val, node.right)</span><br><span class="line">        <span class="comment"># Overwrite value</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.val = val</span><br><span class="line"></span><br><span class="line">        node.size_of_subtree = self._size(node.left) + self._size(node.right)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">          <span class="string">"""</span></span><br><span class="line"><span class="string">        Add a new key-value pair.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Worst Case Complexity: O(N)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Balanced Tree Complexity: O(lg N)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = self._put(key, val, self.root)</span><br></pre></td></tr></table></figure><h2 id="删除">删除</h2><p>删除总共分为三种情况:</p><ul><li><p>如果删除节点x没有孩子,直接删除即可;</p></li><li><p>如果删除节点x有1个孩子,用孩子替换该节点位置;</p></li><li><p>如果删除节点x有2个孩子, 这个情况有些复杂.关键是要找到节点 <em>x的继承者</em> . 节点z的继承者在节点z的右子树中有最小的关键值.这种情况下的操作分为下面步骤:</p><ol type="1"><li>输入待删除的节点x 和 二叉搜索树T.</li><li>在节点x的右子树开始搜索:往右再往左找到最小值节点H;</li><li>H右孩子为H的父节点, H的左孩子为X的左孩子;</li></ol></li></ul><p>示意图如下,应该一目了然:<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://algs4.cs.princeton.edu/32bst/images/bst-delete.png" alt="](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![" title>                </div>                <div class="image-caption">](http://algs4.cs.princeton.edu/32bst/images/bst-deletemin.png) ![</div>            </figure></p><p>根据上面的描述,删除的伪代码可以分为两部分:</p><ol type="1"><li>为了移动子树, 用一棵子树替换一棵子树,并成为双亲的孩子节点.</li></ol><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TRANSPLANT(T, u, v)</span><br><span class="line"><span class="keyword">if</span> u.p == NULL</span><br><span class="line">T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u = u.p.left</span><br><span class="line">u.p.left = v</span><br><span class="line"><span class="keyword">else</span> u.p.right = v</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v!= NULL</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>根据第一步完成二叉搜索树的删除过程:</li></ol><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z)</span><br><span class="line"><span class="keyword">if</span> z.left = NULL</span><br><span class="line">TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (z.right == NULL)</span><br><span class="line">TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">y = TREE-MINIMUM(z.right)</span><br><span class="line"><span class="keyword">if</span> y.p != z</span><br><span class="line">TRANSPLANT(T, y, y.right)</span><br><span class="line">y.right = z.right</span><br><span class="line">y.right.p = y</span><br><span class="line">TRANSPLANT(T, z, y)</span><br><span class="line">y.left = z.left</span><br><span class="line">y.left.p = y</span><br></pre></td></tr></table></figure></p><p>用python 实现如下:</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_delete</span><span class="params">(self, key, node)</span>:</span></span><br><span class="line"> <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">     node.left = self._delete(key, node.left)</span><br><span class="line"> <span class="keyword">elif</span> key &gt; node.key:</span><br><span class="line">     node.right = self._delete(key, node.right)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">     <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">         <span class="keyword">return</span> node.left</span><br><span class="line">     <span class="keyword">elif</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">         <span class="keyword">return</span> node.right</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         old_node = node</span><br><span class="line">         node = self._ceiling_node(key, node.right)</span><br><span class="line">         node.right = self._delete_min(old_node.right)</span><br><span class="line">         node.left = old_node.left</span><br><span class="line"> node.size_of_subtree = self._size(node.left) + self._size(node.right)+<span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_delete_min</span><span class="params">(self, node)</span>:</span></span><br><span class="line"> <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">     <span class="keyword">return</span> node.right</span><br><span class="line"></span><br><span class="line"> node.left = self._delete_min(node.left)</span><br><span class="line"> node.size_of_subtree = self._size(node.left) + self._size(node.right)+<span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> node</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ceiling_node</span><span class="params">(self, key, node)</span>:</span></span><br><span class="line"> <span class="string">"""</span></span><br><span class="line"><span class="string"> Returns the node with the smallest key that is greater than or equal to</span></span><br><span class="line"><span class="string"> the given value 'key'</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"> <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">     <span class="comment"># Ceiling is either in left subtree or is this node</span></span><br><span class="line">     attempt_in_left = self._ceiling_node(key, node.left)</span><br><span class="line">     <span class="keyword">if</span> attempt_in_left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">         <span class="keyword">return</span> node</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">return</span> attempt_in_left</span><br><span class="line"> <span class="keyword">elif</span> key &gt; node.key:</span><br><span class="line">     <span class="comment"># Ceiling must be in right subtree</span></span><br><span class="line">     <span class="keyword">return</span> self._ceiling_node(key, node.right)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">     <span class="comment"># Keys are equal so ceiling is node with this key</span></span><br><span class="line">     <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p><h2 id="参考文献">参考文献</h2><ol type="1"><li>&lt;<算法导论第三版>&gt;</算法导论第三版></li><li><a href="http://algs4.cs.princeton.edu/32bst/" class="uri" target="_blank" rel="noopener">http://algs4.cs.princeton.edu/32bst/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉搜索树定义&quot;&gt;二叉搜索树定义&lt;/h1&gt;
&lt;p&gt;一颗二叉搜索树是以二叉树来组织的,每个节点除了 &lt;em&gt;Key&lt;/em&gt; 还包括 &lt;em&gt;左孩子&lt;/em&gt;, &lt;em&gt;右孩子&lt;/em&gt;, &lt;em&gt;父节点&lt;/em&gt; 等信息. BST满足限制条件: &lt;em&gt;对于任意节
      
    
    </summary>
    
      <category term="python" scheme="http://thinkhard.tech/categories/python/"/>
    
      <category term="code" scheme="http://thinkhard.tech/categories/python/code/"/>
    
      <category term="algorithm" scheme="http://thinkhard.tech/categories/python/code/algorithm/"/>
    
    
      <category term="python" scheme="http://thinkhard.tech/tags/python/"/>
    
      <category term="code" scheme="http://thinkhard.tech/tags/code/"/>
    
      <category term="algorithm" scheme="http://thinkhard.tech/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>python的webrtc库实现语音端点检测</title>
    <link href="http://thinkhard.tech/2017/05/25/python-vad/"/>
    <id>http://thinkhard.tech/2017/05/25/python-vad/</id>
    <published>2017-05-25T13:47:56.000Z</published>
    <updated>2019-04-04T10:10:23.767Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚搭了博客<a href="thinkhard.tech">thinkhard.tech</a>,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.<br>但是目前的语音端点检测,尤其是检测 <em>人声</em> 开始和结束的端点始终是属于技术难点,各家公司始终处于 <strong>能判断</strong>,但是不敢保证 <strong>判别准确性</strong> 的阶段.<br><img src="https://ooo.0o0.ooo/2017/05/25/5926ed7fcc2b3.png" alt="Screenshot from 2017-05-25 22-42-50.png"><br>现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 <strong>Alexa/Echo</strong> 智能音箱.<br><img src="https://ooo.0o0.ooo/2017/05/25/5926ee0cbc85b.jpg" alt="timg.jpg"></p><p>国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势.<br><img src="https://ooo.0o0.ooo/2017/05/25/5926f2220cae2.jpg" alt="timg (1).jpg"></p><p>通常搭建机器人聊天系统主要包括以下三个方面:<br>* 语音转文字(ASR/STT)<br>* 语义内容(NLU/NLP)<br>* 文字转语音(TTS)</p><h2 id="语音转文字asrstt">语音转文字(ASR/STT)</h2><p>在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩</p><a id="more"></a><h2 id="python-端点检测">python 端点检测</h2><p>由于实际应用中,单纯依靠能量检测特征检测等方法很难判断人声说话的起始点,所以市面上大多数的语音产品都是使用唤醒词判断语音起始.另外加上声音回路,还可以做语音打断.这样的交互方式可能有些傻,每次必须喊一下 <em>唤醒词</em> 才能继续聊天.这种方式聊多了,个人感觉会嘴巴疼:-O .现在github上有snowboy唤醒词的开源库,大家可以登录snowboy官网训练自己的唤醒词模型. * Kitt-AI : <a href="https://github.com/Kitt-AI/snowboy" target="_blank" rel="noopener">Snowboy</a> * Sensory : <a href="http://www.sensory.com/" target="_blank" rel="noopener">Sensory</a></p><p>考虑到用唤醒词嘴巴会累,所以大致调研了一下,python拥有丰富的库,直接import就能食用.这种方式容易受强噪声干扰,适合一个人在家玩玩. * pyaudio: <code>pip install pyaudio</code> 可以从设备节点读取原始音频流数据,音频编码是PCM格式; * webrtcvad: <code>pip install webrtcvad</code> 检测判断一组语音数据是否为空语音; 当检测到持续时间长度 <em>T1</em> vad检测都有语音活动,可以判定为语音起始; 当检测到持续时间长度 <em>T2</em> vad检测都没有有语音活动,可以判定为语音结束;</p><p>完整程序代码可以从我的<a href="https://github.com/wangshub/python-vad" target="_blank" rel="noopener">github</a>下载<br>程序很简单,相信看一会儿就明白了</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">&#39;&#39;&#39;</span></span><span id="cb1-2"><a href="#cb1-2"></a><span class="co">Requirements:</span></span><span id="cb1-3"><a href="#cb1-3"></a><span class="co">+ pyaudio - `pip install pyaudio`</span></span><span id="cb1-4"><a href="#cb1-4"></a><span class="co">+ py-webrtcvad - `pip install webrtcvad`</span></span><span id="cb1-5"><a href="#cb1-5"></a><span class="co">&#39;&#39;&#39;</span></span><span id="cb1-6"><a href="#cb1-6"></a><span class="im">import</span> webrtcvad</span><span id="cb1-7"><a href="#cb1-7"></a><span class="im">import</span> collections</span><span id="cb1-8"><a href="#cb1-8"></a><span class="im">import</span> sys</span><span id="cb1-9"><a href="#cb1-9"></a><span class="im">import</span> signal</span><span id="cb1-10"><a href="#cb1-10"></a><span class="im">import</span> pyaudio</span><span id="cb1-11"><a href="#cb1-11"></a></span><span id="cb1-12"><a href="#cb1-12"></a><span class="im">from</span> array <span class="im">import</span> array</span><span id="cb1-13"><a href="#cb1-13"></a><span class="im">from</span> struct <span class="im">import</span> pack</span><span id="cb1-14"><a href="#cb1-14"></a><span class="im">import</span> wave</span><span id="cb1-15"><a href="#cb1-15"></a><span class="im">import</span> time</span><span id="cb1-16"><a href="#cb1-16"></a></span><span id="cb1-17"><a href="#cb1-17"></a>FORMAT <span class="op">=</span> pyaudio.paInt16</span><span id="cb1-18"><a href="#cb1-18"></a>CHANNELS <span class="op">=</span> <span class="dv">1</span></span><span id="cb1-19"><a href="#cb1-19"></a>RATE <span class="op">=</span> <span class="dv">16000</span></span><span id="cb1-20"><a href="#cb1-20"></a>CHUNK_DURATION_MS <span class="op">=</span> <span class="dv">30</span>       <span class="co"># supports 10, 20 and 30 (ms)</span></span><span id="cb1-21"><a href="#cb1-21"></a>PADDING_DURATION_MS <span class="op">=</span> <span class="dv">1500</span>   <span class="co"># 1 sec jugement</span></span><span id="cb1-22"><a href="#cb1-22"></a>CHUNK_SIZE <span class="op">=</span> <span class="bu">int</span>(RATE <span class="op">*</span> CHUNK_DURATION_MS <span class="op">/</span> <span class="dv">1000</span>)  <span class="co"># chunk to read</span></span><span id="cb1-23"><a href="#cb1-23"></a>CHUNK_BYTES <span class="op">=</span> CHUNK_SIZE <span class="op">*</span> <span class="dv">2</span>  <span class="co"># 16bit = 2 bytes, PCM</span></span><span id="cb1-24"><a href="#cb1-24"></a>NUM_PADDING_CHUNKS <span class="op">=</span> <span class="bu">int</span>(PADDING_DURATION_MS <span class="op">/</span> CHUNK_DURATION_MS)</span><span id="cb1-25"><a href="#cb1-25"></a><span class="co"># NUM_WINDOW_CHUNKS = int(240 / CHUNK_DURATION_MS)</span></span><span id="cb1-26"><a href="#cb1-26"></a>NUM_WINDOW_CHUNKS <span class="op">=</span> <span class="bu">int</span>(<span class="dv">400</span> <span class="op">/</span> CHUNK_DURATION_MS)  <span class="co"># 400 ms/ 30ms  ge</span></span><span id="cb1-27"><a href="#cb1-27"></a>NUM_WINDOW_CHUNKS_END <span class="op">=</span> NUM_WINDOW_CHUNKS <span class="op">*</span> <span class="dv">2</span></span><span id="cb1-28"><a href="#cb1-28"></a></span><span id="cb1-29"><a href="#cb1-29"></a>START_OFFSET <span class="op">=</span> <span class="bu">int</span>(NUM_WINDOW_CHUNKS <span class="op">*</span> CHUNK_DURATION_MS <span class="op">*</span> <span class="fl">0.5</span> <span class="op">*</span> RATE)</span><span id="cb1-30"><a href="#cb1-30"></a></span><span id="cb1-31"><a href="#cb1-31"></a>vad <span class="op">=</span> webrtcvad.Vad(<span class="dv">1</span>)</span><span id="cb1-32"><a href="#cb1-32"></a></span><span id="cb1-33"><a href="#cb1-33"></a>pa <span class="op">=</span> pyaudio.PyAudio()</span><span id="cb1-34"><a href="#cb1-34"></a>stream <span class="op">=</span> pa.<span class="bu">open</span>(<span class="bu">format</span><span class="op">=</span>FORMAT,</span><span id="cb1-35"><a href="#cb1-35"></a>                 channels<span class="op">=</span>CHANNELS,</span><span id="cb1-36"><a href="#cb1-36"></a>                 rate<span class="op">=</span>RATE,</span><span id="cb1-37"><a href="#cb1-37"></a>                 <span class="bu">input</span><span class="op">=</span><span class="va">True</span>,</span><span id="cb1-38"><a href="#cb1-38"></a>                 start<span class="op">=</span><span class="va">False</span>,</span><span id="cb1-39"><a href="#cb1-39"></a>                 <span class="co"># input_device_index=2,</span></span><span id="cb1-40"><a href="#cb1-40"></a>                 frames_per_buffer<span class="op">=</span>CHUNK_SIZE)</span><span id="cb1-41"><a href="#cb1-41"></a></span><span id="cb1-42"><a href="#cb1-42"></a></span><span id="cb1-43"><a href="#cb1-43"></a>got_a_sentence <span class="op">=</span> <span class="va">False</span></span><span id="cb1-44"><a href="#cb1-44"></a>leave <span class="op">=</span> <span class="va">False</span></span><span id="cb1-45"><a href="#cb1-45"></a></span><span id="cb1-46"><a href="#cb1-46"></a></span><span id="cb1-47"><a href="#cb1-47"></a><span class="kw">def</span> handle_int(sig, chunk):</span><span id="cb1-48"><a href="#cb1-48"></a>    <span class="kw">global</span> leave, got_a_sentence</span><span id="cb1-49"><a href="#cb1-49"></a>    leave <span class="op">=</span> <span class="va">True</span></span><span id="cb1-50"><a href="#cb1-50"></a>    got_a_sentence <span class="op">=</span> <span class="va">True</span></span><span id="cb1-51"><a href="#cb1-51"></a></span><span id="cb1-52"><a href="#cb1-52"></a></span><span id="cb1-53"><a href="#cb1-53"></a><span class="kw">def</span> record_to_file(path, data, sample_width):</span><span id="cb1-54"><a href="#cb1-54"></a>    <span class="co">&quot;Records from the microphone and outputs the resulting data to &#39;path&#39;&quot;</span></span><span id="cb1-55"><a href="#cb1-55"></a>    <span class="co"># sample_width, data = record()</span></span><span id="cb1-56"><a href="#cb1-56"></a>    data <span class="op">=</span> pack(<span class="st">&#39;&lt;&#39;</span> <span class="op">+</span> (<span class="st">&#39;h&#39;</span> <span class="op">*</span> <span class="bu">len</span>(data)), <span class="op">*</span>data)</span><span id="cb1-57"><a href="#cb1-57"></a>    wf <span class="op">=</span> wave.<span class="bu">open</span>(path, <span class="st">&#39;wb&#39;</span>)</span><span id="cb1-58"><a href="#cb1-58"></a>    wf.setnchannels(<span class="dv">1</span>)</span><span id="cb1-59"><a href="#cb1-59"></a>    wf.setsampwidth(sample_width)</span><span id="cb1-60"><a href="#cb1-60"></a>    wf.setframerate(RATE)</span><span id="cb1-61"><a href="#cb1-61"></a>    wf.writeframes(data)</span><span id="cb1-62"><a href="#cb1-62"></a>    wf.close()</span><span id="cb1-63"><a href="#cb1-63"></a></span><span id="cb1-64"><a href="#cb1-64"></a></span><span id="cb1-65"><a href="#cb1-65"></a><span class="kw">def</span> normalize(snd_data):</span><span id="cb1-66"><a href="#cb1-66"></a>    <span class="co">&quot;Average the volume out&quot;</span></span><span id="cb1-67"><a href="#cb1-67"></a>    MAXIMUM <span class="op">=</span> <span class="dv">32767</span>  <span class="co"># 16384</span></span><span id="cb1-68"><a href="#cb1-68"></a>    times <span class="op">=</span> <span class="bu">float</span>(MAXIMUM) <span class="op">/</span> <span class="bu">max</span>(<span class="bu">abs</span>(i) <span class="cf">for</span> i <span class="kw">in</span> snd_data)</span><span id="cb1-69"><a href="#cb1-69"></a>    r <span class="op">=</span> array(<span class="st">&#39;h&#39;</span>)</span><span id="cb1-70"><a href="#cb1-70"></a>    <span class="cf">for</span> i <span class="kw">in</span> snd_data:</span><span id="cb1-71"><a href="#cb1-71"></a>        r.append(<span class="bu">int</span>(i <span class="op">*</span> times))</span><span id="cb1-72"><a href="#cb1-72"></a>    <span class="cf">return</span> r</span><span id="cb1-73"><a href="#cb1-73"></a></span><span id="cb1-74"><a href="#cb1-74"></a>signal.signal(signal.SIGINT, handle_int)</span><span id="cb1-75"><a href="#cb1-75"></a></span><span id="cb1-76"><a href="#cb1-76"></a><span class="cf">while</span> <span class="kw">not</span> leave:</span><span id="cb1-77"><a href="#cb1-77"></a>    ring_buffer <span class="op">=</span> collections.deque(maxlen<span class="op">=</span>NUM_PADDING_CHUNKS)</span><span id="cb1-78"><a href="#cb1-78"></a>    triggered <span class="op">=</span> <span class="va">False</span></span><span id="cb1-79"><a href="#cb1-79"></a>    voiced_frames <span class="op">=</span> []</span><span id="cb1-80"><a href="#cb1-80"></a>    ring_buffer_flags <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> NUM_WINDOW_CHUNKS</span><span id="cb1-81"><a href="#cb1-81"></a>    ring_buffer_index <span class="op">=</span> <span class="dv">0</span></span><span id="cb1-82"><a href="#cb1-82"></a></span><span id="cb1-83"><a href="#cb1-83"></a>    ring_buffer_flags_end <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> NUM_WINDOW_CHUNKS_END</span><span id="cb1-84"><a href="#cb1-84"></a>    ring_buffer_index_end <span class="op">=</span> <span class="dv">0</span></span><span id="cb1-85"><a href="#cb1-85"></a>    buffer_in <span class="op">=</span> <span class="st">&#39;&#39;</span></span><span id="cb1-86"><a href="#cb1-86"></a>    <span class="co"># WangS</span></span><span id="cb1-87"><a href="#cb1-87"></a>    raw_data <span class="op">=</span> array(<span class="st">&#39;h&#39;</span>)</span><span id="cb1-88"><a href="#cb1-88"></a>    index <span class="op">=</span> <span class="dv">0</span></span><span id="cb1-89"><a href="#cb1-89"></a>    start_point <span class="op">=</span> <span class="dv">0</span></span><span id="cb1-90"><a href="#cb1-90"></a>    StartTime <span class="op">=</span> time.time()</span><span id="cb1-91"><a href="#cb1-91"></a>    <span class="bu">print</span>(<span class="st">&quot;* recording: &quot;</span>)</span><span id="cb1-92"><a href="#cb1-92"></a>    stream.start_stream()</span><span id="cb1-93"><a href="#cb1-93"></a></span><span id="cb1-94"><a href="#cb1-94"></a>    <span class="cf">while</span> <span class="kw">not</span> got_a_sentence <span class="kw">and</span> <span class="kw">not</span> leave:</span><span id="cb1-95"><a href="#cb1-95"></a>        chunk <span class="op">=</span> stream.read(CHUNK_SIZE)</span><span id="cb1-96"><a href="#cb1-96"></a>        <span class="co"># add WangS</span></span><span id="cb1-97"><a href="#cb1-97"></a>        raw_data.extend(array(<span class="st">&#39;h&#39;</span>, chunk))</span><span id="cb1-98"><a href="#cb1-98"></a>        index <span class="op">+=</span> CHUNK_SIZE</span><span id="cb1-99"><a href="#cb1-99"></a>        TimeUse <span class="op">=</span> time.time() <span class="op">-</span> StartTime</span><span id="cb1-100"><a href="#cb1-100"></a></span><span id="cb1-101"><a href="#cb1-101"></a>        active <span class="op">=</span> vad.is_speech(chunk, RATE)</span><span id="cb1-102"><a href="#cb1-102"></a></span><span id="cb1-103"><a href="#cb1-103"></a>        sys.stdout.write(<span class="st">&#39;1&#39;</span> <span class="cf">if</span> active <span class="cf">else</span> <span class="st">&#39;_&#39;</span>)</span><span id="cb1-104"><a href="#cb1-104"></a>        ring_buffer_flags[ring_buffer_index] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> active <span class="cf">else</span> <span class="dv">0</span></span><span id="cb1-105"><a href="#cb1-105"></a>        ring_buffer_index <span class="op">+=</span> <span class="dv">1</span></span><span id="cb1-106"><a href="#cb1-106"></a>        ring_buffer_index <span class="op">%=</span> NUM_WINDOW_CHUNKS</span><span id="cb1-107"><a href="#cb1-107"></a></span><span id="cb1-108"><a href="#cb1-108"></a>        ring_buffer_flags_end[ring_buffer_index_end] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> active <span class="cf">else</span> <span class="dv">0</span></span><span id="cb1-109"><a href="#cb1-109"></a>        ring_buffer_index_end <span class="op">+=</span> <span class="dv">1</span></span><span id="cb1-110"><a href="#cb1-110"></a>        ring_buffer_index_end <span class="op">%=</span> NUM_WINDOW_CHUNKS_END</span><span id="cb1-111"><a href="#cb1-111"></a></span><span id="cb1-112"><a href="#cb1-112"></a>        <span class="co"># start point detection</span></span><span id="cb1-113"><a href="#cb1-113"></a>        <span class="cf">if</span> <span class="kw">not</span> triggered:</span><span id="cb1-114"><a href="#cb1-114"></a>            ring_buffer.append(chunk)</span><span id="cb1-115"><a href="#cb1-115"></a>            num_voiced <span class="op">=</span> <span class="bu">sum</span>(ring_buffer_flags)</span><span id="cb1-116"><a href="#cb1-116"></a>            <span class="cf">if</span> num_voiced <span class="op">&gt;</span> <span class="fl">0.8</span> <span class="op">*</span> NUM_WINDOW_CHUNKS:</span><span id="cb1-117"><a href="#cb1-117"></a>                sys.stdout.write(<span class="st">&#39; Open &#39;</span>)</span><span id="cb1-118"><a href="#cb1-118"></a>                triggered <span class="op">=</span> <span class="va">True</span></span><span id="cb1-119"><a href="#cb1-119"></a>                start_point <span class="op">=</span> index <span class="op">-</span> CHUNK_SIZE <span class="op">*</span> <span class="dv">20</span>  <span class="co"># start point</span></span><span id="cb1-120"><a href="#cb1-120"></a>                <span class="co"># voiced_frames.extend(ring_buffer)</span></span><span id="cb1-121"><a href="#cb1-121"></a>                ring_buffer.clear()</span><span id="cb1-122"><a href="#cb1-122"></a>        <span class="co"># end point detection</span></span><span id="cb1-123"><a href="#cb1-123"></a>        <span class="cf">else</span>:</span><span id="cb1-124"><a href="#cb1-124"></a>            <span class="co"># voiced_frames.append(chunk)</span></span><span id="cb1-125"><a href="#cb1-125"></a>            ring_buffer.append(chunk)</span><span id="cb1-126"><a href="#cb1-126"></a>            num_unvoiced <span class="op">=</span> NUM_WINDOW_CHUNKS_END <span class="op">-</span> <span class="bu">sum</span>(ring_buffer_flags_end)</span><span id="cb1-127"><a href="#cb1-127"></a>            <span class="cf">if</span> num_unvoiced <span class="op">&gt;</span> <span class="fl">0.90</span> <span class="op">*</span> NUM_WINDOW_CHUNKS_END <span class="kw">or</span> TimeUse <span class="op">&gt;</span> <span class="dv">10</span>:</span><span id="cb1-128"><a href="#cb1-128"></a>                sys.stdout.write(<span class="st">&#39; Close &#39;</span>)</span><span id="cb1-129"><a href="#cb1-129"></a>                triggered <span class="op">=</span> <span class="va">False</span></span><span id="cb1-130"><a href="#cb1-130"></a>                got_a_sentence <span class="op">=</span> <span class="va">True</span></span><span id="cb1-131"><a href="#cb1-131"></a></span><span id="cb1-132"><a href="#cb1-132"></a>        sys.stdout.flush()</span><span id="cb1-133"><a href="#cb1-133"></a></span><span id="cb1-134"><a href="#cb1-134"></a>    sys.stdout.write(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)</span><span id="cb1-135"><a href="#cb1-135"></a>    <span class="co"># data = b&#39;&#39;.join(voiced_frames)</span></span><span id="cb1-136"><a href="#cb1-136"></a></span><span id="cb1-137"><a href="#cb1-137"></a>    stream.stop_stream()</span><span id="cb1-138"><a href="#cb1-138"></a>    <span class="bu">print</span>(<span class="st">&quot;* done recording&quot;</span>)</span><span id="cb1-139"><a href="#cb1-139"></a>    got_a_sentence <span class="op">=</span> <span class="va">False</span></span><span id="cb1-140"><a href="#cb1-140"></a></span><span id="cb1-141"><a href="#cb1-141"></a>    <span class="co"># write to file</span></span><span id="cb1-142"><a href="#cb1-142"></a>    raw_data.reverse()</span><span id="cb1-143"><a href="#cb1-143"></a>    <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(start_point):</span><span id="cb1-144"><a href="#cb1-144"></a>        raw_data.pop()</span><span id="cb1-145"><a href="#cb1-145"></a>    raw_data.reverse()</span><span id="cb1-146"><a href="#cb1-146"></a>    raw_data <span class="op">=</span> normalize(raw_data)</span><span id="cb1-147"><a href="#cb1-147"></a>    record_to_file(<span class="st">&quot;recording.wav&quot;</span>, raw_data, <span class="dv">2</span>)</span><span id="cb1-148"><a href="#cb1-148"></a>    leave <span class="op">=</span> <span class="va">True</span></span><span id="cb1-149"><a href="#cb1-149"></a></span><span id="cb1-150"><a href="#cb1-150"></a>stream.close()</span></code></pre></div><p>程序运行方式<code>sudo python vad.py</code><br>qrcode_for_gh_3586401957c4_258.jpg Remove</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚搭了博客&lt;a href=&quot;thinkhard.tech&quot;&gt;thinkhard.tech&lt;/a&gt;,欢迎踩踩~ ## 引言 语音端点检测最早应用于电话传输和检测系统当中,用于通信信道的时间分配,提高传输线路的利用效率.端点检测属于语音处理系统的前端操作,在语音检测领域意义重大.&lt;br&gt;
但是目前的语音端点检测,尤其是检测 &lt;em&gt;人声&lt;/em&gt; 开始和结束的端点始终是属于技术难点,各家公司始终处于 &lt;strong&gt;能判断&lt;/strong&gt;,但是不敢保证 &lt;strong&gt;判别准确性&lt;/strong&gt; 的阶段.&lt;br&gt;
&lt;img src=&quot;https://ooo.0o0.ooo/2017/05/25/5926ed7fcc2b3.png&quot; alt=&quot;Screenshot from 2017-05-25 22-42-50.png&quot;&gt;&lt;br&gt;
现在基于云端语义库的聊天机器人层出不穷,其中最著名的当属amazon的 &lt;strong&gt;Alexa/Echo&lt;/strong&gt; 智能音箱.&lt;br&gt;
&lt;img src=&quot;https://ooo.0o0.ooo/2017/05/25/5926ee0cbc85b.jpg&quot; alt=&quot;timg.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;国内如雨后春笋般出现了各种搭载语音聊天的智能音箱(如前几天在知乎上广告的若琪机器人)和各类智能机器人产品.国内语音服务提供商主要面对中文语音服务,由于语音不像图像有分辨率等等较为客观的指标,很多时候凭主观判断,所以较难判断各家语音识别和合成技术的好坏.但是我个人认为,国内的中文语音服务和国外的英文语音服务,在某些方面已经有超越的趋势.&lt;br&gt;
&lt;img src=&quot;https://ooo.0o0.ooo/2017/05/25/5926f2220cae2.jpg&quot; alt=&quot;timg (1).jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常搭建机器人聊天系统主要包括以下三个方面:&lt;br&gt;
* 语音转文字(ASR/STT)&lt;br&gt;
* 语义内容(NLU/NLP)&lt;br&gt;
* 文字转语音(TTS)&lt;/p&gt;
&lt;h2 id=&quot;语音转文字asrstt&quot;&gt;语音转文字(ASR/STT)&lt;/h2&gt;
&lt;p&gt;在将语音传给云端API之前,是本地前端的语音采集,这部分主要包括如下几个方面: * 麦克风降噪 * 声源定位 * 回声消除 * 唤醒词 * 语音端点检测 * 音频格式压缩&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://thinkhard.tech/categories/Python/"/>
    
      <category term="Code" scheme="http://thinkhard.tech/categories/Python/Code/"/>
    
    
      <category term="Code" scheme="http://thinkhard.tech/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>Atom editor</title>
    <link href="http://thinkhard.tech/2017/05/25/Atom-editor/"/>
    <id>http://thinkhard.tech/2017/05/25/Atom-editor/</id>
    <published>2017-05-25T13:27:42.000Z</published>
    <updated>2019-04-04T10:10:23.685Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.clker.com/cliparts/3/8/9/1/1195436863389690204logomancer_Atom_Model.svg.hi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是</p><blockquote><ul><li>易安装，上手容易</li><li>插件安装方便</li><li>配置可备份</li></ul></blockquote><h1 id="atom的安装">Atom的安装</h1><p>我的系统是ubuntu16.04,直接<a href="atom.io">官网下载</a><code>*.deb</code>安装包，运行<code>dpkg -i atom.deb</code>.</p><h1 id="atom插件">Atom插件</h1><p>Atom下的插件安装十分便捷，在<code>install a package</code>下就能搜索安装。但是<code>GUI</code>的安装方式常常会安装失败，建议终端使用<code>apm install PackageName</code>安装插件。下面是我安装的一些插件：</p><ol type="1"><li><code>highlight-selected</code> 代码高亮插件；</li><li><code>terminal-fusion</code>Atom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了；</li><li><code>simplified-chinese-menu</code>：简体中文插件；</li><li>待补充。。。</li></ol><h1 id="atom配置">Atom配置</h1><p>Atom自带的插件就能满足基本的日常需求，我能记起来的配置</p><ul><li><code>Markdown</code>文件预览：快捷键<code>Ctl-Shift-m</code>；</li><li>文件树，快捷键：<code>ctrl-\</code>；</li><li>文件查找：<code>ctrl-F</code>当前buffer中查找，<code>ctrl-shift-f</code>当前工程中查找；</li><li>代码跳转：首先首先<code>ctrl-alt-g</code>生成<code>.tags</code>文件，选中待跳转的函数，<code>ctrl-shift-r</code>完成跳转；</li><li><code>alt</code>键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽；</li></ul><h1 id="atom备份">Atom备份</h1><p>经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和<code>emacs</code>类似，可以将配置<code>～/.atom/</code>文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在<a href="https://github.com/wangshub/.atom.git" target="_blank" rel="noopener">这里</a></p><p>最后，上一张我的Atom效果图 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ooo.0o0.ooo/2017/05/25/5926dc8d83d5c.png" alt="Screenshot from 2017-05-25 21-29-45.png" title>                </div>                <div class="image-caption">Screenshot from 2017-05-25 21-29-45.png</div>            </figure></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;http://www.clker.com/cliparts/3/8/9/1/1195436863389690204logomancer_Atom_Model.svg.hi.png&quot; alt title&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;网上一直存在着vim和emacs两大阵营，两边的拥护者把这两个编辑器说的神乎其神。私以为，只是工具而已，对个人来说好用就行。Atom使用下来，我的感受就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;易安装，上手容易&lt;/li&gt;
&lt;li&gt;插件安装方便&lt;/li&gt;
&lt;li&gt;配置可备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;atom的安装&quot;&gt;Atom的安装&lt;/h1&gt;
&lt;p&gt;我的系统是ubuntu16.04,直接&lt;a href=&quot;atom.io&quot;&gt;官网下载&lt;/a&gt;&lt;code&gt;*.deb&lt;/code&gt;安装包，运行&lt;code&gt;dpkg -i atom.deb&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;atom插件&quot;&gt;Atom插件&lt;/h1&gt;
&lt;p&gt;Atom下的插件安装十分便捷，在&lt;code&gt;install a package&lt;/code&gt;下就能搜索安装。但是&lt;code&gt;GUI&lt;/code&gt;的安装方式常常会安装失败，建议终端使用&lt;code&gt;apm install PackageName&lt;/code&gt;安装插件。下面是我安装的一些插件：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;highlight-selected&lt;/code&gt; 代码高亮插件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;terminal-fusion&lt;/code&gt;Atom下的终端插件，强烈推荐，再也不用切换屏幕运行终端程序了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;simplified-chinese-menu&lt;/code&gt;：简体中文插件；&lt;/li&gt;
&lt;li&gt;待补充。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;atom配置&quot;&gt;Atom配置&lt;/h1&gt;
&lt;p&gt;Atom自带的插件就能满足基本的日常需求，我能记起来的配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Markdown&lt;/code&gt;文件预览：快捷键&lt;code&gt;Ctl-Shift-m&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;文件树，快捷键：&lt;code&gt;ctrl-\&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;文件查找：&lt;code&gt;ctrl-F&lt;/code&gt;当前buffer中查找，&lt;code&gt;ctrl-shift-f&lt;/code&gt;当前工程中查找；&lt;/li&gt;
&lt;li&gt;代码跳转：首先首先&lt;code&gt;ctrl-alt-g&lt;/code&gt;生成&lt;code&gt;.tags&lt;/code&gt;文件，选中待跳转的函数，&lt;code&gt;ctrl-shift-r&lt;/code&gt;完成跳转；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt&lt;/code&gt;键隐藏菜单栏，对于笔记本太有用了，整个界面也变得清爽；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;atom备份&quot;&gt;Atom备份&lt;/h1&gt;
&lt;p&gt;经常在windows和Linux下进行切换，对于我常常作死把系统搞崩，所以需要备份Atom编辑器的配置，和&lt;code&gt;emacs&lt;/code&gt;类似，可以将配置&lt;code&gt;～/.atom/&lt;/code&gt;文件目录上传github,新装Atom的时候直接clone下来就好，我的配置github地址在&lt;a href=&quot;https://github.com/wangshub/.atom.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，上一张我的Atom效果图 &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ooo.0o0.ooo/2017/05/25/5926dc8d83d5c.png&quot; alt=&quot;Screenshot from 2017-05-25 21-29-45.png&quot; title&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;Screenshot from 2017-05-25 21-29-45.png&lt;/div&gt;
            &lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://thinkhard.tech/categories/Tool/"/>
    
      <category term="Linux" scheme="http://thinkhard.tech/categories/Tool/Linux/"/>
    
    
      <category term="Editor" scheme="http://thinkhard.tech/tags/Editor/"/>
    
  </entry>
  
  <entry>
    <title>Cmake 模板</title>
    <link href="http://thinkhard.tech/2017/05/25/Cmake-tutorial/"/>
    <id>http://thinkhard.tech/2017/05/25/Cmake-tutorial/</id>
    <published>2017-05-24T16:03:34.000Z</published>
    <updated>2019-04-04T10:10:23.685Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ooo.0o0.ooo/2017/05/25/5925af646160e.png" alt title>                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>由于之前的代码Cmake写的比较混乱，库链接的不规范，今天花了一些时间，重写Cmakelist.txt，方便后来的开发。可以根据我的模板开始进行C/C++的项目开发.主要分下面几个方面 &gt; * 更新CMakeList.txt文件 &gt; * 改变头文件位置，索引文件夹 &gt; * 上传新的gitlab</p><h2 id="cmakelist.txt模板">CMakeList.txt模板</h2><h4 id="全局cmakelist.txt文件">全局CMakeList.txt文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (aelos1s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sys dir</span></span><br><span class="line"><span class="keyword">find_package</span> (Threads)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(aelos <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(aelos aeloslib)</span><br><span class="line"><span class="comment"># 多线程链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span> (aelos <span class="variable">$&#123;CMAKE_THREAD_LIBS_INIT&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="头文件库cmakelist.txt文件">头文件库CMakeList.txt文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成 aeloslib 链接库</span><br><span class="line">add_library (aeloslib $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><h4 id="工程目录结构">工程目录结构</h4><pre><code>the file structure is   |----main.cpp    #主程序    |----lib/        #*.cpp and *.h       |----build/      #可执行文件生成文件夹      </code></pre><h4 id="工程参考模板的github地址">工程参考模板的github地址</h4><blockquote><p>https://github.com/wangshub/cmake</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://ooo.0o0.ooo/2017/05/25/5925af646160e.png&quot; alt title&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://thinkhard.tech/categories/Programming/"/>
    
      <category term="Linux" scheme="http://thinkhard.tech/categories/Programming/Linux/"/>
    
      <category term="c/c++" scheme="http://thinkhard.tech/categories/Programming/Linux/c-c/"/>
    
    
      <category term="Code" scheme="http://thinkhard.tech/tags/Code/"/>
    
      <category term="Linux" scheme="http://thinkhard.tech/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://thinkhard.tech/2017/04/14/hello-world/"/>
    <id>http://thinkhard.tech/2017/04/14/hello-world/</id>
    <published>2017-04-14T13:28:12.000Z</published>
    <updated>2019-07-02T02:14:45.335Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><p>Setup pages.</p><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
